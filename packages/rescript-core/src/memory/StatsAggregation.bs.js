// Generated by ReScript, PLEASE EDIT WITH CARE


function buildConversationStatsQuery(conversationId) {
  return "\n  SELECT\n    conversation_id,\n    COUNT(*) as message_count,\n    COALESCE(SUM(tokens), 0) as total_tokens,\n    COALESCE(AVG(tokens), 0.0) as avg_tokens_per_message,\n    SUM(CASE WHEN role = 'user' THEN 1 ELSE 0 END) as user_message_count,\n    SUM(CASE WHEN role = 'assistant' THEN 1 ELSE 0 END) as assistant_message_count,\n    SUM(CASE WHEN role = 'system' THEN 1 ELSE 0 END) as system_message_count\n  FROM messages\n  WHERE conversation_id = '" + conversationId + "'\n    AND deleted_at IS NULL\n  GROUP BY conversation_id\n  ";
}

function buildGlobalStatsQuery() {
  return "\n  SELECT\n    COUNT(DISTINCT conversation_id) as total_conversations,\n    COUNT(*) as total_messages,\n    COALESCE(SUM(tokens), 0) as total_tokens\n  FROM messages\n  WHERE deleted_at IS NULL\n  ";
}

function buildTimeRangeStatsQuery(startTime, endTime) {
  var startStr = String(startTime);
  var endStr = String(endTime);
  return "\n  SELECT\n    COUNT(*) as message_count,\n    COALESCE(AVG(tokens), 0.0) as avg_tokens\n  FROM messages\n  WHERE created_at >= " + startStr + "\n    AND created_at <= " + endStr + "\n    AND deleted_at IS NULL\n  ";
}

function parseConversationStatsRow(row) {
  return {
          conversationId: row.conversation_id,
          messageCount: row.message_count,
          totalTokens: row.total_tokens,
          avgTokensPerMessage: row.avg_tokens_per_message,
          userMessageCount: row.user_message_count,
          assistantMessageCount: row.assistant_message_count,
          systemMessageCount: row.system_message_count
        };
}

function parseGlobalStatsRow(row) {
  var avgMessages = row.total_conversations > 0 ? row.total_messages / row.total_conversations : 0.0;
  var avgTokens = row.total_messages > 0 ? row.total_tokens / row.total_messages : 0.0;
  return {
          totalConversations: row.total_conversations,
          totalMessages: row.total_messages,
          totalTokens: row.total_tokens,
          avgMessagesPerConversation: avgMessages,
          avgTokensPerMessage: avgTokens
        };
}

function parseTimeRangeStatsRow(row, startTime, endTime) {
  return {
          startTime: startTime,
          endTime: endTime,
          messageCount: row.message_count,
          avgTokens: row.avg_tokens
        };
}

function selectStrategy(estimatedRows) {
  if (estimatedRows < 1000) {
    return "InMemory";
  } else if (estimatedRows < 100000) {
    return "Hybrid";
  } else {
    return "DirectSQL";
  }
}

function explainStrategy(strategy) {
  switch (strategy) {
    case "DirectSQL" :
        return "Direct SQL aggregation (fastest, prevents pagination bugs)";
    case "InMemory" :
        return "In-memory aggregation (for complex calculations)";
    case "Hybrid" :
        return "Hybrid approach (SQL pre-filter + in-memory)";
    
  }
}

export {
  buildConversationStatsQuery ,
  buildGlobalStatsQuery ,
  buildTimeRangeStatsQuery ,
  parseConversationStatsRow ,
  parseGlobalStatsRow ,
  parseTimeRangeStatsRow ,
  selectStrategy ,
  explainStrategy ,
}
/* No side effect */
