// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as TaskStateMachine from "./TaskStateMachine.bs.js";

function createTelemetryEvent(eventType, payload) {
  return {
          timestamp: Date.now(),
          eventType: eventType,
          payload: payload
        };
}

function emitTelemetryEvent($$event) {
  var payloadJson = $$event.payload;
  console.log("[Telemetry] " + $$event.eventType + " @ " + String($$event.timestamp));
  console.log("[Telemetry] Payload:", payloadJson);
}

function createPayload(pairs) {
  var dict = {};
  Belt_Array.forEach(pairs, (function (param) {
          dict[param[0]] = param[1];
        }));
  return dict;
}

function placeholderEffect(effect, context) {
  if (typeof effect !== "object") {
    switch (effect) {
      case "EvaluateGuards" :
          var guardVerdictStr = TaskStateMachine.GuardVerdict.toString(context.guardVerdict);
          var payload = createPayload([[
                  "verdict",
                  guardVerdictStr
                ]]);
          return emitTelemetryEvent(createTelemetryEvent("guards.evaluated", payload));
      case "EnterWaitState" :
          var payload$1 = createPayload([[
                  "reason",
                  "dependencies_not_ready"
                ]]);
          return emitTelemetryEvent(createTelemetryEvent("wait_state.entered", payload$1));
      case "ScheduleRetry" :
          var payload$2 = createPayload([[
                  "scheduled",
                  true
                ]]);
          return emitTelemetryEvent(createTelemetryEvent("retry.scheduled", payload$2));
      case "FlushTelemetryBuffer" :
          var payload$3 = createPayload([[
                  "flushed",
                  true
                ]]);
          return emitTelemetryEvent(createTelemetryEvent("telemetry.flushed", payload$3));
      
    }
  } else {
    switch (effect.TAG) {
      case "HydratePlan" :
          var payload$4 = createPayload([
                [
                  "taskId",
                  effect._0
                ],
                [
                  "dependenciesReady",
                  context.dependenciesReady
                ]
              ]);
          return emitTelemetryEvent(createTelemetryEvent("plan.hydrated", payload$4));
      case "StartExecution" :
          var payload$5 = createPayload([[
                  "taskId",
                  effect._0
                ]]);
          return emitTelemetryEvent(createTelemetryEvent("execution.started", payload$5));
      case "EmitTelemetry" :
          var payload$6 = createPayload([[
                  "label",
                  effect._0
                ]]);
          return emitTelemetryEvent(createTelemetryEvent("custom.event", payload$6));
      case "PerformRollback" :
          var payload$7 = createPayload([[
                  "reason",
                  effect._0
                ]]);
          return emitTelemetryEvent(createTelemetryEvent("rollback.performed", payload$7));
      case "RecordCancellation" :
          var payload$8 = createPayload([[
                  "actor",
                  effect._0
                ]]);
          return emitTelemetryEvent(createTelemetryEvent("cancellation.recorded", payload$8));
      
    }
  }
}

function telemetryDecisionHandler(decision) {
  var payload = createPayload([
        [
          "status",
          TaskStateMachine.statusToString(decision.status)
        ],
        [
          "fromState",
          TaskStateMachine.State.toString(decision.fromState)
        ],
        [
          "toState",
          TaskStateMachine.State.toString(decision.toState)
        ],
        [
          "event",
          TaskStateMachine.$$Event.toString(decision.event)
        ],
        [
          "effectCount",
          decision.effects.length
        ]
      ]);
  var reason = decision.reason;
  if (reason !== undefined) {
    payload["reason"] = reason;
  }
  emitTelemetryEvent(createTelemetryEvent("transition.executed", payload));
}

var $$default = {
  onDecision: telemetryDecisionHandler,
  onEffect: placeholderEffect
};

var Handler = {
  placeholderEffect: placeholderEffect,
  telemetryDecisionHandler: telemetryDecisionHandler,
  $$default: $$default
};

function applyEffects(effects, context, handler) {
  Belt_Array.forEach(effects, (function (effect) {
          handler(effect, context);
        }));
}

function dispatchWithHandlers(state, $$event, context, handlers) {
  var decision = TaskStateMachine.transition(state, $$event, context);
  handlers.onDecision(decision);
  applyEffects(decision.effects, context, handlers.onEffect);
  return decision;
}

function dispatch(state, $$event, context) {
  return dispatchWithHandlers(state, $$event, context, $$default);
}

function dispatchSerialized(state, $$event, context, handlers) {
  return TaskStateMachine.serializeOutcome(dispatchWithHandlers(state, $$event, context, handlers));
}

export {
  createTelemetryEvent ,
  emitTelemetryEvent ,
  createPayload ,
  Handler ,
  applyEffects ,
  dispatchWithHandlers ,
  dispatch ,
  dispatchSerialized ,
}
/* No side effect */
