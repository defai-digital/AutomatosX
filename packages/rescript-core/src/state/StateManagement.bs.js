// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function createStateMachine(initial, transitions, onEnterOpt, onExitOpt) {
  var onEnter = onEnterOpt !== undefined ? Caml_option.valFromOption(onEnterOpt) : undefined;
  var onExit = onExitOpt !== undefined ? Caml_option.valFromOption(onExitOpt) : undefined;
  var now = Date.now() | 0;
  return {
          initial: initial,
          current: {
            contents: {
              current: initial,
              previous: undefined,
              enteredAt: now
            }
          },
          transitions: transitions,
          onEnter: onEnter,
          onExit: onExit
        };
}

function getCurrentState(machine) {
  return machine.current.contents.current;
}

function getPreviousState(machine) {
  return machine.current.contents.previous;
}

function getTimeInState(machine) {
  var now = Date.now() | 0;
  return now - machine.current.contents.enteredAt | 0;
}

function isInState(machine, state) {
  return Caml_obj.equal(machine.current.contents.current, state);
}

function findTransition(machine, $$event) {
  var currentState = machine.current.contents.current;
  return Belt_Array.getBy(machine.transitions, (function (t) {
                if (Caml_obj.equal(t.from, currentState)) {
                  return Caml_obj.equal(t.event, $$event);
                } else {
                  return false;
                }
              }));
}

function canTransition(machine, $$event) {
  var t = findTransition(machine, $$event);
  if (t === undefined) {
    return false;
  }
  var guardFn = t.guard;
  if (guardFn !== undefined) {
    return guardFn();
  } else {
    return true;
  }
}

function getValidTransitions(machine) {
  var currentState = machine.current.contents.current;
  return Belt_Array.keep(machine.transitions, (function (t) {
                return Caml_obj.equal(t.from, currentState);
              }));
}

function makeTransition(machine, $$event) {
  var t = findTransition(machine, $$event);
  if (t === undefined) {
    return {
            TAG: "Error",
            _0: "No valid transition for event from current state"
          };
  }
  var guardFn = t.guard;
  if (guardFn !== undefined && !guardFn()) {
    return {
            TAG: "Error",
            _0: "Transition guard failed for event"
          };
  }
  var oldState = machine.current.contents.current;
  var newState = t.to;
  var fn = machine.onExit;
  if (fn !== undefined) {
    fn(oldState, newState);
  }
  var now = Date.now() | 0;
  machine.current.contents = {
    current: newState,
    previous: Caml_option.some(oldState),
    enteredAt: now
  };
  var fn$1 = machine.onEnter;
  if (fn$1 !== undefined) {
    fn$1(oldState, newState);
  }
  return {
          TAG: "Ok",
          _0: newState
        };
}

function reset(machine) {
  var now = Date.now() | 0;
  machine.current.contents = {
    current: machine.initial,
    previous: Caml_option.some(machine.current.contents.current),
    enteredAt: now
  };
}

function taskStateToString(state) {
  switch (state) {
    case "pending" :
        return "pending";
    case "running" :
        return "running";
    case "completed" :
        return "completed";
    case "failed" :
        return "failed";
    case "cancelled" :
        return "cancelled";
    
  }
}

function createTaskStateMachine() {
  return createStateMachine("pending", [
              {
                from: "pending",
                event: "start",
                to: "running",
                guard: undefined
              },
              {
                from: "running",
                event: "complete",
                to: "completed",
                guard: undefined
              },
              {
                from: "running",
                event: "fail",
                to: "failed",
                guard: undefined
              },
              {
                from: "running",
                event: "cancel",
                to: "cancelled",
                guard: undefined
              },
              {
                from: "failed",
                event: "retry",
                to: "pending",
                guard: undefined
              },
              {
                from: "cancelled",
                event: "retry",
                to: "pending",
                guard: undefined
              }
            ], Caml_option.some((function (from, to) {
                    console.log("Task state:", taskStateToString(from) + " -> " + taskStateToString(to));
                  })), Caml_option.some(undefined));
}

function createConnectionStateMachine() {
  return createStateMachine("disconnected", [
              {
                from: "disconnected",
                event: "connect",
                to: "connecting",
                guard: undefined
              },
              {
                from: "connecting",
                event: "connected",
                to: "connected",
                guard: undefined
              },
              {
                from: "connecting",
                event: "error",
                to: "failed",
                guard: undefined
              },
              {
                from: "connected",
                event: "disconnect",
                to: "disconnected",
                guard: undefined
              },
              {
                from: "connected",
                event: "error",
                to: "reconnecting",
                guard: undefined
              },
              {
                from: "failed",
                event: "retry",
                to: "connecting",
                guard: undefined
              },
              {
                from: "reconnecting",
                event: "connected",
                to: "connected",
                guard: undefined
              },
              {
                from: "reconnecting",
                event: "error",
                to: "failed",
                guard: undefined
              }
            ], Caml_option.some(undefined), Caml_option.some(undefined));
}

function createRequestStateMachine() {
  return createStateMachine("idle", [
              {
                from: "idle",
                event: "fetch",
                to: "loading",
                guard: undefined
              },
              {
                from: "loading",
                event: "success",
                to: "success",
                guard: undefined
              },
              {
                from: "loading",
                event: "error",
                to: "error",
                guard: undefined
              },
              {
                from: "success",
                event: "reset",
                to: "idle",
                guard: undefined
              },
              {
                from: "error",
                event: "reset",
                to: "idle",
                guard: undefined
              },
              {
                from: "error",
                event: "fetch",
                to: "loading",
                guard: undefined
              }
            ], Caml_option.some(undefined), Caml_option.some(undefined));
}

function createWithHistory(machine) {
  var now = Date.now() | 0;
  return {
          machine: machine,
          history: {
            contents: [{
                state: machine.initial,
                enteredAt: now,
                exitedAt: undefined
              }]
          }
        };
}

function makeTransitionWithHistory(sm, $$event) {
  var result = makeTransition(sm.machine, $$event);
  if (result.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: result._0
          };
  }
  var newState = result._0;
  var now = Date.now() | 0;
  var lastIndex = sm.history.contents.length - 1 | 0;
  if (lastIndex >= 0) {
    var entry = Belt_Array.get(sm.history.contents, lastIndex);
    if (entry !== undefined) {
      var updated_state = entry.state;
      var updated_enteredAt = entry.enteredAt;
      var updated_exitedAt = now;
      var updated = {
        state: updated_state,
        enteredAt: updated_enteredAt,
        exitedAt: updated_exitedAt
      };
      sm.history.contents = Belt_Array.mapWithIndex(sm.history.contents, (function (i, e) {
              if (i === lastIndex) {
                return updated;
              } else {
                return e;
              }
            }));
    }
    
  }
  var newEntry = {
    state: newState,
    enteredAt: now,
    exitedAt: undefined
  };
  sm.history.contents = Belt_Array.concat(sm.history.contents, [newEntry]);
  return {
          TAG: "Ok",
          _0: newState
        };
}

function getHistory(sm) {
  return sm.history.contents;
}

function stateToString(state) {
  return "state";
}

function isValidTransition(machine, fromState, $$event) {
  return Belt_Array.some(machine.transitions, (function (t) {
                if (Caml_obj.equal(t.from, fromState)) {
                  return Caml_obj.equal(t.event, $$event);
                } else {
                  return false;
                }
              }));
}

export {
  createStateMachine ,
  getCurrentState ,
  getPreviousState ,
  getTimeInState ,
  isInState ,
  findTransition ,
  canTransition ,
  getValidTransitions ,
  makeTransition ,
  reset ,
  taskStateToString ,
  createTaskStateMachine ,
  createConnectionStateMachine ,
  createRequestStateMachine ,
  createWithHistory ,
  makeTransitionWithHistory ,
  getHistory ,
  stateToString ,
  isValidTransition ,
}
/* No side effect */
