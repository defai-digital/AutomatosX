# üîç AutomatosX v8.0.0 Feature Refinements - PRD

**Date:** 2025-01-13
**Version:** 8.0.0 ‚Üí 8.0.1 (Refinements)
**Status:** Ready for Implementation
**Timeline:** 5 days (1 week)
**Priority:** P1 (Polish & Enhancement)

---

## üéØ EXECUTIVE SUMMARY

### Mission

**Refine and enhance the 3 core features** that are already 50-80% implemented, transforming them from "functional" to "production-ready with exceptional UX".

### What This Is (and Isn't)

**‚úÖ This IS:**
- Polish and refinement of existing features
- UX enhancements and edge case handling
- Performance optimization and testing
- Production-ready hardening

**‚ùå This is NOT:**
- New feature development (already covered in gap closure)
- Major architectural changes
- Complete rewrites

### The 3 Refinement Areas

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  1. Interactive CLI Refinements                            ‚îÇ
‚îÇ  Current: 80% complete, functional                         ‚îÇ
‚îÇ  Need: Multiline input, voice support, rich formatting     ‚îÇ
‚îÇ  Time: 2 days                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  2. Natural Language Query Enhancements                    ‚îÇ
‚îÇ  Current: 50% complete, basic patterns                     ‚îÇ
‚îÇ  Need: Context awareness, learning, fuzzy matching         ‚îÇ
‚îÇ  Time: 2 days                                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  3. Iterate Mode Refinements                               ‚îÇ
‚îÇ  Current: 0% complete (new feature)                        ‚îÇ
‚îÇ  Need: Advanced strategies, learning, telemetry            ‚îÇ
‚îÇ  Time: 1 day (post-implementation polish)                  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

TOTAL: 5 days | 1 developer | Sequential work
```

---

## üìã REFINEMENT 1: INTERACTIVE CLI ENHANCEMENTS

### Current State Analysis

**What Works (80%):**
- ‚úÖ Basic REPL with readline
- ‚úÖ Single-line input handling
- ‚úÖ 13 slash commands
- ‚úÖ Token streaming
- ‚úÖ Session persistence
- ‚úÖ Tab autocomplete (basic)

**What's Missing (20%):**
- ‚ùå Multiline input (code blocks, JSON)
- ‚ùå Syntax highlighting
- ‚ùå Rich table formatting
- ‚ùå File attachment support
- ‚ùå Voice input (optional P2)
- ‚ùå Advanced autocomplete (context-aware)
- ‚ùå Command history search (Ctrl+R)

### Priority Refinements (P0 - Must Have)

#### 1.1 Multiline Input Support

**Problem:**
Users cannot paste code blocks or write multi-line JSON without issues.

**Solution:**
Implement multiline mode with visual indicators.

**User Experience:**
```bash
> Create a function that:
... - Takes an array of numbers
... - Filters out even numbers
... - Returns sum of remaining
```

**Technical Implementation:**

**File:** `src/cli/interactive/REPLSession.ts`

```typescript
export class REPLSession {
  private multilineBuffer: string[] = [];
  private multilineMode: boolean = false;
  private multilineTrigger: string = '```'; // Triple backticks

  private async handleInput(line: string): Promise<void> {
    // Check for multiline trigger
    if (line.trim() === this.multilineTrigger) {
      if (!this.multilineMode) {
        // Start multiline mode
        this.multilineMode = true;
        this.multilineBuffer = [];
        this.rl.setPrompt(chalk.gray('... '));
        console.log(chalk.gray('(Multiline mode - type ``` again to finish)'));
        this.rl.prompt();
        return;
      } else {
        // End multiline mode
        this.multilineMode = false;
        const fullInput = this.multilineBuffer.join('\n');
        this.multilineBuffer = [];
        this.rl.setPrompt(this.options.prompt);

        // Process the full multiline input
        await this.processInput(fullInput);
        this.rl.prompt();
        return;
      }
    }

    if (this.multilineMode) {
      // Accumulate lines
      this.multilineBuffer.push(line);
      this.rl.prompt();
      return;
    }

    // Normal single-line processing
    await this.processInput(line.trim());
  }

  private async processInput(input: string): Promise<void> {
    if (!input) return;

    // Detect code blocks automatically
    if (this.looksLikeCode(input)) {
      console.log(chalk.gray('(Detected code block)'));
      // Syntax highlight before processing
      console.log(this.highlightCode(input));
    }

    // Route to slash command or natural language
    if (input.startsWith('/')) {
      await this.commandRegistry.execute(input, this.conversationContext);
    } else {
      await this.processNaturalLanguage(input);
    }
  }

  private looksLikeCode(input: string): boolean {
    // Heuristics for code detection
    const codeIndicators = [
      /^(function|const|let|var|class|import|export)\s/,
      /^(def|class|import|from)\s/, // Python
      /[{}\[\]();]/g,               // Braces/brackets
      /\n.*\n/,                     // Multiple lines
    ];

    return codeIndicators.some(regex => regex.test(input));
  }
}
```

**Testing:**
```typescript
// src/cli/interactive/__tests__/REPLSession.test.ts
describe('Multiline Input', () => {
  it('should enter multiline mode with triple backticks', async () => {
    await session.handleInput('```');
    expect(session.multilineMode).toBe(true);
  });

  it('should accumulate lines in multiline mode', async () => {
    await session.handleInput('```');
    await session.handleInput('line 1');
    await session.handleInput('line 2');
    await session.handleInput('```');

    expect(lastProcessedInput).toBe('line 1\nline 2');
  });

  it('should detect code blocks automatically', () => {
    const isCode = session.looksLikeCode('function foo() { return 42; }');
    expect(isCode).toBe(true);
  });
});
```

**Time:** 0.5 days (4 hours)

#### 1.2 Syntax Highlighting

**Problem:**
Code and JSON in responses are not syntax-highlighted, making them hard to read.

**Solution:**
Use `chalk` for basic highlighting or `highlight.js` for advanced.

**Dependencies:**
```bash
npm install chalk@5 highlight.js
npm install -D @types/highlight.js
```

**Implementation:**

**File:** `src/cli/interactive/SyntaxHighlighter.ts` (NEW)

```typescript
import chalk from 'chalk';
import hljs from 'highlight.js';

export class SyntaxHighlighter {
  highlightCode(code: string, language?: string): string {
    try {
      const detected = language || hljs.highlightAuto(code).language;
      const highlighted = hljs.highlight(code, { language: detected || 'plaintext' });

      return this.applyChalkColors(highlighted.value);
    } catch (error) {
      // Fallback to basic chalk highlighting
      return this.basicHighlight(code);
    }
  }

  private applyChalkColors(html: string): string {
    // Convert highlight.js HTML to chalk colors
    return html
      .replace(/<span class="hljs-keyword">(.*?)<\/span>/g, chalk.blue('$1'))
      .replace(/<span class="hljs-string">(.*?)<\/span>/g, chalk.green('$1'))
      .replace(/<span class="hljs-number">(.*?)<\/span>/g, chalk.yellow('$1'))
      .replace(/<span class="hljs-comment">(.*?)<\/span>/g, chalk.gray('$1'))
      .replace(/<span class="hljs-function">(.*?)<\/span>/g, chalk.cyan('$1'))
      .replace(/<[^>]+>/g, ''); // Remove remaining tags
  }

  private basicHighlight(code: string): string {
    // Simple regex-based highlighting for common patterns
    return code
      .replace(/(function|const|let|var|class|import|export|async|await)/g, chalk.blue('$1'))
      .replace(/('.*?'|".*?")/g, chalk.green('$1'))
      .replace(/(\d+)/g, chalk.yellow('$1'))
      .replace(/(\/\/.*$)/gm, chalk.gray('$1'));
  }

  highlightJSON(json: string): string {
    try {
      const parsed = JSON.parse(json);
      const formatted = JSON.stringify(parsed, null, 2);

      return formatted
        .replace(/(".*?"):/g, chalk.cyan('$1') + ':')
        .replace(/: (".*?")/g, ': ' + chalk.green('$1'))
        .replace(/: (\d+)/g, ': ' + chalk.yellow('$1'))
        .replace(/: (true|false|null)/g, ': ' + chalk.magenta('$1'));
    } catch {
      return json; // Not valid JSON
    }
  }
}
```

**Integration:**

**File:** `src/cli/interactive/StreamingHandler.ts` (MODIFY)

```typescript
import { SyntaxHighlighter } from './SyntaxHighlighter.js';

export class StreamingHandler {
  private highlighter = new SyntaxHighlighter();

  async streamResponse(content: string): Promise<void> {
    // Detect code blocks in markdown
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;

    let lastIndex = 0;
    let match;

    while ((match = codeBlockRegex.exec(content)) !== null) {
      // Stream text before code block
      const before = content.slice(lastIndex, match.index);
      await this.streamText(before);

      // Highlight and display code block
      const language = match[1];
      const code = match[2];
      const highlighted = this.highlighter.highlightCode(code, language);

      console.log('\n' + highlighted + '\n');

      lastIndex = codeBlockRegex.lastIndex;
    }

    // Stream remaining text
    if (lastIndex < content.length) {
      await this.streamText(content.slice(lastIndex));
    }
  }
}
```

**Time:** 0.5 days (4 hours)

#### 1.3 Rich Table Formatting

**Problem:**
Tabular data (agent lists, status) displayed as plain text, hard to read.

**Solution:**
Use `cli-table3` for beautiful ASCII tables.

**Dependencies:**
```bash
npm install cli-table3
npm install -D @types/cli-table3
```

**Implementation:**

**File:** `src/cli/interactive/TableFormatter.ts` (NEW)

```typescript
import Table from 'cli-table3';
import chalk from 'chalk';

export class TableFormatter {
  createTable(headers: string[], rows: string[][]): string {
    const table = new Table({
      head: headers.map(h => chalk.cyan(h)),
      chars: {
        'top': '‚îÄ',
        'top-mid': '‚î¨',
        'top-left': '‚îå',
        'top-right': '‚îê',
        'bottom': '‚îÄ',
        'bottom-mid': '‚î¥',
        'bottom-left': '‚îî',
        'bottom-right': '‚îò',
        'left': '‚îÇ',
        'left-mid': '‚îú',
        'mid': '‚îÄ',
        'mid-mid': '‚îº',
        'right': '‚îÇ',
        'right-mid': '‚î§',
        'middle': '‚îÇ'
      },
      style: {
        'padding-left': 1,
        'padding-right': 1,
        head: [],
        border: []
      }
    });

    rows.forEach(row => table.push(row));

    return table.toString();
  }

  formatAgents(agents: Agent[]): string {
    const headers = ['Name', 'Type', 'Status', 'Specializations'];
    const rows = agents.map(agent => [
      chalk.white(agent.name),
      chalk.gray(agent.type),
      agent.active ? chalk.green('‚úì Active') : chalk.red('‚úó Inactive'),
      chalk.gray(agent.specializations.slice(0, 2).join(', '))
    ]);

    return this.createTable(headers, rows);
  }

  formatWorkflows(workflows: Workflow[]): string {
    const headers = ['Name', 'Steps', 'Last Run', 'Status'];
    const rows = workflows.map(wf => [
      chalk.white(wf.name),
      chalk.gray(wf.steps.toString()),
      chalk.gray(this.formatDate(wf.lastRun)),
      wf.status === 'success' ? chalk.green('‚úì') : chalk.red('‚úó')
    ]);

    return this.createTable(headers, rows);
  }

  private formatDate(date: Date | null): string {
    if (!date) return 'Never';
    const now = Date.now();
    const diff = now - date.getTime();

    if (diff < 60000) return 'Just now';
    if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
    if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
    return date.toLocaleDateString();
  }
}
```

**Usage in Commands:**

**File:** `src/cli/interactive/commands/AgentsCommand.ts` (MODIFY)

```typescript
import { TableFormatter } from '../TableFormatter.js';

export class AgentsCommand implements SlashCommand {
  private formatter = new TableFormatter();

  async execute(args: string[]): Promise<void> {
    const agents = await this.agentRegistry.list();

    // OLD: Plain text list
    // agents.forEach(a => console.log(`${a.name} - ${a.description}`));

    // NEW: Rich table
    console.log('\n' + this.formatter.formatAgents(agents) + '\n');
  }
}
```

**Time:** 0.5 days (4 hours)

#### 1.4 Command History Search (Ctrl+R)

**Problem:**
Users can't search through command history interactively.

**Solution:**
Implement Ctrl+R reverse search like bash.

**Implementation:**

**File:** `src/cli/interactive/REPLSession.ts` (MODIFY)

```typescript
export class REPLSession {
  private historySearchMode: boolean = false;
  private historySearchTerm: string = '';
  private historySearchIndex: number = -1;

  async start(): Promise<void> {
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: this.options.prompt,
    });

    // Add Ctrl+R listener
    process.stdin.on('keypress', (str, key) => {
      if (key.ctrl && key.name === 'r') {
        this.startHistorySearch();
      } else if (this.historySearchMode) {
        this.handleHistorySearchKey(str, key);
      }
    });

    // Enable keypress events
    if (process.stdin.isTTY) {
      readline.emitKeypressEvents(process.stdin);
      process.stdin.setRawMode(true);
    }
  }

  private startHistorySearch(): void {
    this.historySearchMode = true;
    this.historySearchTerm = '';
    this.historySearchIndex = -1;
    this.updateHistorySearchPrompt();
  }

  private handleHistorySearchKey(str: string, key: any): void {
    if (key.name === 'escape' || (key.ctrl && key.name === 'c')) {
      // Exit search mode
      this.historySearchMode = false;
      this.rl.setPrompt(this.options.prompt);
      this.rl.prompt();
      return;
    }

    if (key.name === 'return') {
      // Accept current match
      const match = this.findHistoryMatch();
      this.historySearchMode = false;
      this.rl.setPrompt(this.options.prompt);
      if (match) {
        this.rl.write(match);
      }
      return;
    }

    if (key.name === 'backspace') {
      this.historySearchTerm = this.historySearchTerm.slice(0, -1);
    } else if (str && str.length === 1) {
      this.historySearchTerm += str;
    }

    this.updateHistorySearchPrompt();
  }

  private findHistoryMatch(): string | null {
    const history = this.loadHistory();
    for (let i = history.length - 1; i >= 0; i--) {
      if (history[i].includes(this.historySearchTerm)) {
        return history[i];
      }
    }
    return null;
  }

  private updateHistorySearchPrompt(): void {
    const match = this.findHistoryMatch();
    const prompt = chalk.yellow(`(reverse-i-search)\`${this.historySearchTerm}': `) +
      (match ? chalk.gray(match) : '');

    readline.clearLine(process.stdout, 0);
    readline.cursorTo(process.stdout, 0);
    process.stdout.write(prompt);
  }
}
```

**Time:** 0.5 days (4 hours)

### Summary: Interactive CLI Refinements

**Total Time:** 2 days

**Deliverables:**
- ‚úÖ Multiline input with ``` delimiters
- ‚úÖ Syntax highlighting for code/JSON
- ‚úÖ Rich table formatting for lists
- ‚úÖ Ctrl+R history search

**P2 Refinements (Future):**
- Voice input (speech-to-text)
- File attachment (`/attach <file>`)
- Collaborative sessions (multiplayer)
- Custom themes

---

## üìã REFINEMENT 2: NATURAL LANGUAGE QUERY ENHANCEMENTS

### Current State Analysis

**What Works (50%):**
- ‚úÖ Basic intent classification (pattern matching)
- ‚úÖ LLM fallback for ambiguous queries
- ‚úÖ 15 intent types defined
- ‚úÖ Simple pattern matching

**What's Missing (50%):**
- ‚ùå Context-aware intent (uses conversation history)
- ‚ùå Learning from user corrections
- ‚ùå Fuzzy matching for typos
- ‚ùå Confidence-based clarification
- ‚ùå Multi-step query handling
- ‚ùå Query expansion and synonyms

### Priority Enhancements (P0 - Must Have)

#### 2.1 Context-Aware Intent Classification

**Problem:**
Current classifier ignores conversation context, leading to misinterpretations.

**Example:**
```
User: "run security audit"
Bot: [executes workflow]

User: "show me the results"  ‚Üê Doesn't understand this refers to audit
Bot: ‚ùå "What results?"
```

**Solution:**
Use conversation context to disambiguate pronouns and references.

**Implementation:**

**File:** `src/cli/interactive/ContextAwareIntentClassifier.ts` (NEW)

```typescript
import { IntentClassifier, ClassificationResult } from './IntentClassifier.js';
import { ConversationContext } from './ConversationContext.js';

export class ContextAwareIntentClassifier extends IntentClassifier {
  constructor(
    providerRouter: ProviderRouterV2,
    private conversationContext: ConversationContext
  ) {
    super(providerRouter);
  }

  async classify(input: string): Promise<ClassificationResult> {
    // Step 1: Check for pronouns and references
    const hasReference = this.containsReference(input);

    if (!hasReference) {
      // No context needed - use base classifier
      return super.classify(input);
    }

    // Step 2: Get recent conversation context
    const recentMessages = await this.conversationContext.getHistory(5);

    // Step 3: Expand query with context
    const expandedQuery = await this.expandWithContext(input, recentMessages);

    // Step 4: Classify expanded query
    const result = await super.classify(expandedQuery);

    // Store original query in metadata
    result.metadata = {
      ...result.metadata,
      originalQuery: input,
      expandedQuery,
      usedContext: true
    };

    return result;
  }

  private containsReference(input: string): boolean {
    const references = [
      /\b(it|this|that|these|those|them)\b/i,
      /\b(the|my|our)\s+(result|output|workflow|agent)/i,
      /\b(show|display|give)\s+me\b/i,
      /^(and|also|then)/i,
    ];

    return references.some(regex => regex.test(input));
  }

  private async expandWithContext(
    input: string,
    history: Message[]
  ): Promise<string> {
    // Find last mentioned entity (workflow, agent, file)
    let lastWorkflow: string | null = null;
    let lastAgent: string | null = null;

    for (let i = history.length - 1; i >= 0; i--) {
      const msg = history[i];

      if (!lastWorkflow) {
        const wfMatch = msg.content.match(/workflow:\s*(\S+)/i);
        if (wfMatch) lastWorkflow = wfMatch[1];
      }

      if (!lastAgent) {
        const agentMatch = msg.content.match(/@(\w+)/i);
        if (agentMatch) lastAgent = agentMatch[1];
      }

      if (lastWorkflow && lastAgent) break;
    }

    // Expand pronouns
    let expanded = input;

    if (/\b(it|this|that)\b/i.test(input) && lastWorkflow) {
      expanded = expanded.replace(/\b(it|this|that)\b/i, lastWorkflow);
    }

    if (/\bthe\s+(result|output)\b/i.test(input) && lastWorkflow) {
      expanded = expanded.replace(/the\s+(result|output)/i, `the $1 from ${lastWorkflow}`);
    }

    if (expanded === input && lastWorkflow) {
      // No pronouns found, append context
      expanded = `${input} (regarding ${lastWorkflow})`;
    }

    return expanded;
  }
}
```

**Testing:**
```typescript
// src/cli/interactive/__tests__/ContextAwareIntentClassifier.test.ts
describe('ContextAwareIntentClassifier', () => {
  it('should expand "show me the results" after workflow execution', async () => {
    // Setup: Previous message mentioned security-audit.yaml
    await context.addMessage('user', 'run security-audit.yaml');
    await context.addMessage('assistant', 'Running workflow: security-audit.yaml');

    const result = await classifier.classify('show me the results');

    expect(result.metadata.expandedQuery).toContain('security-audit');
    expect(result.intent).toBe('workflow_status');
  });

  it('should replace "it" with last mentioned workflow', async () => {
    await context.addMessage('user', 'list workflows');
    await context.addMessage('assistant', 'Found: test-workflow.yaml');

    const result = await classifier.classify('run it');

    expect(result.metadata.expandedQuery).toContain('test-workflow');
    expect(result.intent).toBe('workflow_run');
  });
});
```

**Time:** 0.5 days (4 hours)

#### 2.2 Fuzzy Matching for Typos

**Problem:**
Typos in workflow names or agent names cause failures.

**Example:**
```
User: "run securtiy audit"  ‚Üê Typo in "security"
Bot: ‚ùå "Workflow not found: securtiy audit"
```

**Solution:**
Use Levenshtein distance for fuzzy matching.

**Dependencies:**
```bash
npm install string-similarity
npm install -D @types/string-similarity
```

**Implementation:**

**File:** `src/nlp/FuzzyMatcher.ts` (NEW)

```typescript
import { findBestMatch } from 'string-similarity';

export class FuzzyMatcher {
  findClosestMatch(
    input: string,
    candidates: string[],
    threshold: number = 0.6
  ): { match: string; score: number } | null {
    if (candidates.length === 0) return null;

    const result = findBestMatch(input.toLowerCase(),
      candidates.map(c => c.toLowerCase())
    );

    if (result.bestMatch.rating < threshold) {
      return null;
    }

    return {
      match: candidates[result.bestMatchIndex],
      score: result.bestMatch.rating
    };
  }

  findAllMatches(
    input: string,
    candidates: string[],
    threshold: number = 0.6,
    limit: number = 5
  ): Array<{ match: string; score: number }> {
    const matches = candidates
      .map(candidate => ({
        match: candidate,
        score: this.similarity(input, candidate)
      }))
      .filter(m => m.score >= threshold)
      .sort((a, b) => b.score - a.score)
      .slice(0, limit);

    return matches;
  }

  private similarity(str1: string, str2: string): number {
    const s1 = str1.toLowerCase();
    const s2 = str2.toLowerCase();

    // Use Levenshtein distance
    const matrix: number[][] = [];

    for (let i = 0; i <= s1.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= s2.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= s1.length; i++) {
      for (let j = 1; j <= s2.length; j++) {
        if (s1[i - 1] === s2[j - 1]) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    const distance = matrix[s1.length][s2.length];
    const maxLen = Math.max(s1.length, s2.length);

    return 1 - distance / maxLen;
  }
}
```

**Integration:**

**File:** `src/nlp/EntityExtractor.ts` (MODIFY)

```typescript
import { FuzzyMatcher } from './FuzzyMatcher.js';

export class EntityExtractor {
  private fuzzyMatcher = new FuzzyMatcher();

  async resolveWorkflow(partial: string): Promise<string | null> {
    // Try exact match first
    const exact = await this.findExactWorkflow(partial);
    if (exact) return exact;

    // Fuzzy match
    const allWorkflows = await this.fileSystem.listFiles('workflows');
    const match = this.fuzzyMatcher.findClosestMatch(partial, allWorkflows, 0.7);

    if (match) {
      // Confirm with user
      console.log(chalk.yellow(`Did you mean: ${match.match}? (${(match.score * 100).toFixed(0)}% match)`));
      return match.match;
    }

    return null;
  }
}
```

**Time:** 0.5 days (4 hours)

#### 2.3 Confidence-Based Clarification

**Problem:**
Low-confidence classifications execute anyway, leading to errors.

**Solution:**
Ask for clarification when confidence < 0.7.

**Implementation:**

**File:** `src/nlp/NaturalLanguageProcessor.ts` (MODIFY)

```typescript
export class NaturalLanguageProcessor {
  async process(input: string): Promise<ProcessResult> {
    const classification = await this.intentClassifier.classify(input);

    // Low confidence - ask for clarification
    if (classification.confidence < 0.7) {
      return await this.requestClarification(input, classification);
    }

    // High confidence - proceed
    return await this.executeIntent(classification);
  }

  private async requestClarification(
    input: string,
    classification: ClassificationResult
  ): Promise<ProcessResult> {
    console.log(chalk.yellow(`\n‚ùì I'm not sure what you mean by "${input}"`));
    console.log(chalk.gray(`(Confidence: ${(classification.confidence * 100).toFixed(0)}%)\n`));

    // Show alternatives
    if (classification.alternatives && classification.alternatives.length > 0) {
      console.log(chalk.yellow('Did you mean:'));
      classification.alternatives.forEach((alt, i) => {
        console.log(`  ${i + 1}. ${this.describeIntent(alt.intent)} (${(alt.confidence * 100).toFixed(0)}%)`);
      });
      console.log(`  ${classification.alternatives.length + 1}. Something else (please rephrase)`);

      const choice = await this.promptForChoice(classification.alternatives.length + 1);

      if (choice <= classification.alternatives.length) {
        // User selected an alternative
        const selected = classification.alternatives[choice - 1];
        return await this.executeIntent({ ...classification, intent: selected.intent });
      } else {
        // User wants to rephrase
        return {
          success: false,
          message: 'Please try rephrasing your request.',
          suggestions: this.getSuggestions()
        };
      }
    }

    return {
      success: false,
      message: 'Could not understand. Please try rephrasing.',
      suggestions: this.getSuggestions()
    };
  }

  private describeIntent(intent: Intent): string {
    const descriptions: Record<Intent, string> = {
      workflow_run: 'Run a workflow',
      workflow_list: 'List workflows',
      memory_search: 'Search memory',
      agent_list: 'List agents',
      status: 'Show system status',
      // ... more
    };

    return descriptions[intent] || intent;
  }
}
```

**Time:** 0.5 days (4 hours)

#### 2.4 Learning from User Corrections

**Problem:**
When users correct misclassifications, the system doesn't learn.

**Solution:**
Store corrections and use them to improve pattern matching.

**Implementation:**

**File:** `src/nlp/IntentLearner.ts` (NEW)

```typescript
import { getDatabase } from '../database/connection.js';

export class IntentLearner {
  private db = getDatabase();

  async recordCorrection(
    userInput: string,
    predictedIntent: Intent,
    actualIntent: Intent,
    confidence: number
  ): Promise<void> {
    this.db.prepare(`
      INSERT INTO intent_corrections (
        user_input,
        predicted_intent,
        actual_intent,
        confidence,
        timestamp
      ) VALUES (?, ?, ?, ?, ?)
    `).run(userInput, predictedIntent, actualIntent, confidence, Date.now());
  }

  async getLearnings(intent: Intent, limit: number = 10): Promise<string[]> {
    const rows = this.db.prepare(`
      SELECT user_input, COUNT(*) as count
      FROM intent_corrections
      WHERE actual_intent = ?
      GROUP BY user_input
      ORDER BY count DESC
      LIMIT ?
    `).all(intent, limit) as Array<{ user_input: string; count: number }>;

    return rows.map(r => r.user_input);
  }

  async getImprovedPatterns(intent: Intent): Promise<RegExp[]> {
    const learnings = await this.getLearnings(intent, 20);

    // Extract common patterns
    const patterns: RegExp[] = [];

    for (const learning of learnings) {
      // Create pattern from learning
      const words = learning.toLowerCase().split(/\s+/);
      const pattern = new RegExp(words.join('\\s+'), 'i');
      patterns.push(pattern);
    }

    return patterns;
  }
}
```

**Migration:**

**File:** `src/migrations/014_create_intent_corrections.sql` (NEW)

```sql
CREATE TABLE IF NOT EXISTS intent_corrections (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_input TEXT NOT NULL,
  predicted_intent TEXT NOT NULL,
  actual_intent TEXT NOT NULL,
  confidence REAL NOT NULL,
  timestamp INTEGER NOT NULL
);

CREATE INDEX idx_intent_corrections_actual
  ON intent_corrections(actual_intent);

CREATE INDEX idx_intent_corrections_timestamp
  ON intent_corrections(timestamp DESC);
```

**Time:** 0.5 days (4 hours)

### Summary: Natural Language Enhancements

**Total Time:** 2 days

**Deliverables:**
- ‚úÖ Context-aware intent classification
- ‚úÖ Fuzzy matching for typos
- ‚úÖ Confidence-based clarification
- ‚úÖ Learning from corrections

**P2 Enhancements (Future):**
- Multi-step query handling
- Query expansion with synonyms
- Sentiment analysis
- Multi-language support

---

## üìã REFINEMENT 3: ITERATE MODE REFINEMENTS

### Current State

**Status:** New feature (0% ‚Üí 100% in main implementation)

**Refinements:** Post-implementation polish only

### Priority Refinements (P0 - Must Have)

#### 3.1 Advanced Strategy Patterns

**Problem:**
Only 5 basic strategies implemented in main feature.

**Solution:**
Add 5 more advanced strategies for edge cases.

**Implementation:**

**File:** `src/services/StrategySelector.ts` (ENHANCE)

```typescript
export const ADVANCED_STRATEGIES: Strategy[] = [
  {
    name: 'incremental-retry',
    description: 'Retry with incrementally relaxed constraints',
    config: {
      timeout: 300000,
      retryBackoff: 'exponential',
      parallelism: 5,
      relaxConstraints: true,  // NEW
      constraintSteps: [0.9, 0.7, 0.5]  // Relax to 90%, 70%, 50%
    },
    priority: 4,
    applicableErrors: ['constraint_violation', 'validation_failed']
  },

  {
    name: 'divide-and-conquer',
    description: 'Split large tasks into smaller chunks',
    config: {
      timeout: 300000,
      retryBackoff: 'none',
      parallelism: 10,
      splitTasks: true,  // NEW
      maxChunkSize: 10
    },
    priority: 3,
    applicableErrors: ['too_large', 'memory_exceeded']
  },

  {
    name: 'cached-replay',
    description: 'Replay from cached checkpoint',
    config: {
      timeout: 300000,
      retryBackoff: 'none',
      parallelism: 5,
      useCachedCheckpoint: true,  // NEW
      skipCompletedSteps: true
    },
    priority: 9,
    applicableErrors: ['intermittent_failure']
  },

  {
    name: 'alternative-path',
    description: 'Try alternative workflow path',
    config: {
      timeout: 300000,
      retryBackoff: 'linear',
      parallelism: 5,
      useAlternativePath: true,  // NEW
      fallbackSteps: []
    },
    priority: 6,
    applicableErrors: ['path_blocked', 'dependency_unavailable']
  },

  {
    name: 'graceful-degradation',
    description: 'Skip non-critical steps and complete what's possible',
    config: {
      timeout: 300000,
      retryBackoff: 'exponential',
      parallelism: 5,
      allowPartialCompletion: true,  // NEW
      skipNonCritical: true
    },
    priority: 2,
    applicableErrors: ['partial_failure', 'some_steps_failed']
  }
];
```

**Time:** 0.25 days (2 hours)

#### 3.2 Strategy Effectiveness Telemetry

**Problem:**
No visibility into which strategies work best for different scenarios.

**Solution:**
Track strategy effectiveness and surface insights.

**Implementation:**

**File:** `src/services/StrategyTelemetry.ts` (NEW)

```typescript
export class StrategyTelemetry {
  private db = getDatabase();

  async recordStrategyAttempt(
    strategy: string,
    errorType: string,
    success: boolean,
    duration: number,
    metadata: Record<string, unknown>
  ): Promise<void> {
    this.db.prepare(`
      INSERT INTO strategy_telemetry (
        strategy_name,
        error_type,
        success,
        duration_ms,
        metadata,
        timestamp
      ) VALUES (?, ?, ?, ?, ?, ?)
    `).run(
      strategy,
      errorType,
      success ? 1 : 0,
      duration,
      JSON.stringify(metadata),
      Date.now()
    );
  }

  async getStrategyEffectiveness(
    strategy: string,
    errorType?: string
  ): Promise<StrategyStats> {
    const query = errorType
      ? `WHERE strategy_name = ? AND error_type = ?`
      : `WHERE strategy_name = ?`;

    const params = errorType ? [strategy, errorType] : [strategy];

    const stats = this.db.prepare(`
      SELECT
        COUNT(*) as total_attempts,
        SUM(success) as successes,
        AVG(duration_ms) as avg_duration,
        MIN(duration_ms) as min_duration,
        MAX(duration_ms) as max_duration
      FROM strategy_telemetry
      ${query}
    `).get(...params) as StrategyStats;

    return {
      ...stats,
      success_rate: stats.successes / stats.total_attempts
    };
  }

  async getBestStrategyFor(errorType: string): Promise<string> {
    const row = this.db.prepare(`
      SELECT
        strategy_name,
        CAST(SUM(success) AS REAL) / COUNT(*) as success_rate
      FROM strategy_telemetry
      WHERE error_type = ?
      GROUP BY strategy_name
      ORDER BY success_rate DESC
      LIMIT 1
    `).get(errorType) as { strategy_name: string; success_rate: number };

    return row?.strategy_name || 'default';
  }
}
```

**Migration:**

**File:** `src/migrations/015_create_strategy_telemetry.sql` (NEW)

```sql
CREATE TABLE IF NOT EXISTS strategy_telemetry (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  strategy_name TEXT NOT NULL,
  error_type TEXT NOT NULL,
  success INTEGER NOT NULL,  -- 0 or 1
  duration_ms INTEGER NOT NULL,
  metadata TEXT,  -- JSON
  timestamp INTEGER NOT NULL
);

CREATE INDEX idx_strategy_telemetry_strategy
  ON strategy_telemetry(strategy_name);

CREATE INDEX idx_strategy_telemetry_error
  ON strategy_telemetry(error_type);

CREATE INDEX idx_strategy_telemetry_success
  ON strategy_telemetry(success);
```

**Time:** 0.25 days (2 hours)

#### 3.3 Real-Time Progress Monitoring

**Problem:**
During long iterate loops, no visibility into progress.

**Solution:**
Add progress bars and real-time status updates.

**Implementation:**

**File:** `src/services/IterateEngine.ts` (ENHANCE)

```typescript
import ora from 'ora';
import cliProgress from 'cli-progress';

export class IterateEngine {
  private progressBar: cliProgress.SingleBar | null = null;

  async iterate(
    workflowPath: string,
    options: IterateOptions
  ): Promise<IterateResult> {
    // Initialize progress bar
    this.progressBar = new cliProgress.SingleBar({
      format: 'Iterate Progress |{bar}| {percentage}% | Iteration {value}/{total} | ETA: {eta}s',
      barCompleteChar: '\u2588',
      barIncompleteChar: '\u2591',
      hideCursor: true
    });

    this.progressBar.start(options.maxIterations, 0);

    try {
      // ... existing iterate logic

      for (let i = 1; i <= options.maxIterations; i++) {
        this.progressBar.update(i);

        // ... iteration logic
      }

      this.progressBar.stop();
    } catch (error) {
      this.progressBar?.stop();
      throw error;
    }
  }

  private async executeIteration(/*...*/): Promise<IterationResult> {
    const spinner = ora(`Iteration ${iteration}: ${strategy.description}`).start();

    try {
      // ... execution logic

      spinner.succeed(`Iteration ${iteration}: ${result.success ? 'Success' : 'Failed'}`);
    } catch (error) {
      spinner.fail(`Iteration ${iteration}: Error - ${error.message}`);
    }

    return result;
  }
}
```

**Time:** 0.25 days (2 hours)

#### 3.4 Iteration Summary Report

**Problem:**
After completion, no detailed report of what happened.

**Solution:**
Generate summary report with insights.

**Implementation:**

**File:** `src/services/IterateSummaryGenerator.ts` (NEW)

```typescript
export class IterateSummaryGenerator {
  generate(result: IterateResult): string {
    const { success, iterations, totalDuration, history, finalStrategy } = result;

    const summary = `
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë              ITERATE MODE SUMMARY REPORT                   ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Status: ${success ? chalk.green('‚úì SUCCESS') : chalk.red('‚úó FAILED')}
Total Iterations: ${iterations}
Total Duration: ${this.formatDuration(totalDuration)}
Final Strategy: ${finalStrategy.name}

ITERATION BREAKDOWN:
${this.formatIterationHistory(history)}

INSIGHTS:
${this.generateInsights(history)}

RECOMMENDATIONS:
${this.generateRecommendations(history, success)}
    `;

    return summary.trim();
  }

  private formatIterationHistory(history: IterationResult[]): string {
    return history.map((iter, i) => {
      const status = iter.success ? chalk.green('‚úì') : chalk.red('‚úó');
      const duration = this.formatDuration(iter.duration);

      return `  ${i + 1}. ${status} ${iter.strategy.name} (${duration})${
        iter.error ? chalk.red(` - ${iter.error.message}`) : ''
      }`;
    }).join('\n');
  }

  private generateInsights(history: IterationResult[]): string {
    const insights: string[] = [];

    // Most effective strategy
    const strategyCounts = new Map<string, number>();
    history.filter(h => h.success).forEach(h => {
      strategyCounts.set(h.strategy.name, (strategyCounts.get(h.strategy.name) || 0) + 1);
    });

    const mostEffective = Array.from(strategyCounts.entries())
      .sort((a, b) => b[1] - a[1])[0];

    if (mostEffective) {
      insights.push(`‚Ä¢ Most effective strategy: ${mostEffective[0]} (${mostEffective[1]} successes)`);
    }

    // Error patterns
    const errors = history.filter(h => h.error).map(h => h.error!.message);
    if (errors.length > 0) {
      const uniqueErrors = [...new Set(errors)];
      insights.push(`‚Ä¢ Encountered ${uniqueErrors.length} unique error types`);
    }

    // Time distribution
    const avgDuration = history.reduce((sum, h) => sum + h.duration, 0) / history.length;
    insights.push(`‚Ä¢ Average iteration duration: ${this.formatDuration(avgDuration)}`);

    return insights.join('\n');
  }

  private generateRecommendations(history: IterationResult[], success: boolean): string {
    const recommendations: string[] = [];

    if (!success) {
      recommendations.push('‚Ä¢ Consider increasing max iterations or timeout');
      recommendations.push('‚Ä¢ Review error logs for persistent issues');
    }

    // Check if many failures were due to same error
    const errors = history.filter(h => h.error).map(h => h.error!.message);
    const errorCounts = new Map<string, number>();
    errors.forEach(e => errorCounts.set(e, (errorCounts.get(e) || 0) + 1));

    const mostCommon = Array.from(errorCounts.entries())
      .sort((a, b) => b[1] - a[1])[0];

    if (mostCommon && mostCommon[1] > 2) {
      recommendations.push(`‚Ä¢ Address recurring error: "${mostCommon[0]}" (occurred ${mostCommon[1]} times)`);
    }

    if (recommendations.length === 0) {
      recommendations.push('‚Ä¢ Iteration strategy worked well for this workflow');
    }

    return recommendations.join('\n');
  }

  private formatDuration(ms: number): string {
    if (ms < 1000) return `${ms}ms`;
    if (ms < 60000) return `${(ms / 1000).toFixed(1)}s`;
    return `${(ms / 60000).toFixed(1)}m`;
  }
}
```

**Time:** 0.25 days (2 hours)

### Summary: Iterate Mode Refinements

**Total Time:** 1 day (post-implementation polish)

**Deliverables:**
- ‚úÖ 5 advanced strategies
- ‚úÖ Strategy effectiveness telemetry
- ‚úÖ Real-time progress monitoring
- ‚úÖ Summary report generation

---

## üìä CONSOLIDATED ACTION PLAN

### 5-Day Implementation Schedule

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  DAY 1: Interactive CLI Refinements (Part 1)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Morning:   Multiline input support                        ‚îÇ
‚îÇ  Afternoon: Syntax highlighting                            ‚îÇ
‚îÇ  Deliverable: Code blocks and JSON properly formatted      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  DAY 2: Interactive CLI Refinements (Part 2)              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Morning:   Rich table formatting                          ‚îÇ
‚îÇ  Afternoon: Ctrl+R history search                          ‚îÇ
‚îÇ  Deliverable: Interactive CLI refinements complete ‚úÖ       ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  DAY 3: Natural Language Enhancements (Part 1)            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Morning:   Context-aware intent classification            ‚îÇ
‚îÇ  Afternoon: Fuzzy matching for typos                       ‚îÇ
‚îÇ  Deliverable: Context-aware NL working                     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  DAY 4: Natural Language Enhancements (Part 2)            ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Morning:   Confidence-based clarification                 ‚îÇ
‚îÇ  Afternoon: Learning from corrections                      ‚îÇ
‚îÇ  Deliverable: NL enhancements complete ‚úÖ                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  DAY 5: Iterate Mode Refinements + Testing                ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Morning:   Advanced strategies + telemetry                ‚îÇ
‚îÇ  Afternoon: Progress monitoring + summary reports          ‚îÇ
‚îÇ  Evening:   Integration testing + documentation            ‚îÇ
‚îÇ  Deliverable: All refinements complete ‚úÖ                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Testing Strategy

**Daily Testing:**
- Unit tests for each refinement
- Manual QA before EOD
- Commit working code daily

**Integration Testing (Day 5):**
- Full E2E flow with all refinements
- Performance benchmarking
- User acceptance testing

**Success Criteria:**
- ‚úÖ All refinements implemented
- ‚úÖ Unit test coverage >80%
- ‚úÖ 0 P0 bugs, <5 P1 bugs
- ‚úÖ Performance targets met

---

## ‚úÖ SUCCESS CRITERIA

### Interactive CLI Refinements

- [ ] Multiline input works with ``` delimiters
- [ ] Syntax highlighting for code/JSON
- [ ] Rich tables for agents/workflows
- [ ] Ctrl+R history search functional

### Natural Language Enhancements

- [ ] Context-aware classification (pronouns resolved)
- [ ] Fuzzy matching (70%+ similarity tolerance)
- [ ] Clarification requested when confidence <0.7
- [ ] Learning database populated from corrections

### Iterate Mode Refinements

- [ ] 10 total strategies (5 basic + 5 advanced)
- [ ] Telemetry tracking strategy effectiveness
- [ ] Progress bar during iterations
- [ ] Summary report generated after completion

---

## üìÅ DELIVERABLES

### Code Files (NEW)

```
src/cli/interactive/
‚îú‚îÄ‚îÄ SyntaxHighlighter.ts           (NEW)
‚îú‚îÄ‚îÄ TableFormatter.ts              (NEW)
‚îú‚îÄ‚îÄ ContextAwareIntentClassifier.ts (NEW)

src/nlp/
‚îú‚îÄ‚îÄ FuzzyMatcher.ts                (NEW)
‚îú‚îÄ‚îÄ IntentLearner.ts               (NEW)

src/services/
‚îú‚îÄ‚îÄ StrategyTelemetry.ts           (NEW)
‚îú‚îÄ‚îÄ IterateSummaryGenerator.ts     (NEW)

src/migrations/
‚îú‚îÄ‚îÄ 014_create_intent_corrections.sql (NEW)
‚îî‚îÄ‚îÄ 015_create_strategy_telemetry.sql (NEW)
```

### Documentation

```
docs/
‚îú‚îÄ‚îÄ refinements/
‚îÇ   ‚îú‚îÄ‚îÄ interactive-cli-advanced.md
‚îÇ   ‚îú‚îÄ‚îÄ natural-language-learning.md
‚îÇ   ‚îî‚îÄ‚îÄ iterate-mode-telemetry.md
```

---

## üöÄ READY TO EXECUTE

**This PRD provides:**
‚úÖ Clear scope (refinements, not new features)
‚úÖ Detailed implementation specs
‚úÖ 5-day timeline with daily goals
‚úÖ Testing strategy
‚úÖ Success criteria

**Next Steps:**
1. Review this PRD
2. Approve 5-day timeline
3. Start Day 1 implementation
4. Daily progress tracking
5. Day 5 integration testing

---

**Let's refine AutomatosX to production excellence! ‚ú®**

_Document Version: 1.0
Last Updated: 2025-01-13
Status: ‚úÖ READY FOR IMPLEMENTATION_
