# AutomatosX v8.0.0 - Iterate Mode Refinements PRD

**Date:** 2025-01-13
**Version:** 8.0.0 ‚Üí 8.0.1
**Status:** Ready for Implementation
**Timeline:** 1 day
**Priority:** P1 (Polish & Enhancement)

---

## üéØ EXECUTIVE SUMMARY

### Mission

Refine Iterate Mode from "basic autonomous retry" to "intelligent, learning, self-optimizing execution engine" with advanced strategies, telemetry, real-time monitoring, and comprehensive reporting.

### Current State (Partial Implementation)

**What Works:**
- ‚úÖ Basic IterateEngine implementation
- ‚úÖ 5 core strategies (simple-retry, parallel, timeout-extension, checkpoint-resume, fallback)
- ‚úÖ StrategySelector for pattern matching
- ‚úÖ FailureAnalyzer for error classification
- ‚úÖ SafetyEvaluator for cost/time limits

**What's Missing:**
- ‚ùå Advanced strategies (incremental-retry, adaptive-parallelism, circuit-breaker, gradual-relaxation, hybrid-approach)
- ‚ùå Strategy effectiveness telemetry
- ‚ùå Real-time progress monitoring (progress bars, ETAs)
- ‚ùå Comprehensive iteration summary reports
- ‚ùå Learning from strategy successes/failures

### Success Criteria

After refinements:
- ‚úÖ 10 total strategies (5 basic + 5 advanced)
- ‚úÖ Strategy telemetry tracking effectiveness
- ‚úÖ Real-time progress visualization
- ‚úÖ Summary reports after each iteration
- ‚úÖ >70% success rate on complex workflows

---

## üìã REFINEMENT AREAS

### 1. Advanced Strategies (P0 - Must Have)

**Current State:**
5 basic strategies:
- simple-retry
- parallel
- timeout-extension
- checkpoint-resume
- fallback

**Needed:**
5 advanced strategies:
- incremental-retry
- adaptive-parallelism
- circuit-breaker
- gradual-relaxation
- hybrid-approach

**Implementation:**

File: `src/services/AdvancedStrategies.ts` (new file)

```typescript
import { Strategy } from './StrategySelector.js';

/**
 * Advanced Strategies for Iterate Mode
 *
 * These strategies go beyond basic retry logic to provide intelligent,
 * adaptive execution patterns that learn from failures and optimize
 * resource usage.
 */

export const ADVANCED_STRATEGIES: Strategy[] = [
  /**
   * INCREMENTAL RETRY
   * Retry with incrementally relaxed constraints
   *
   * Use when: Constraint violations or validation failures
   * Example: Memory limit exceeded ‚Üí retry with +20% memory
   */
  {
    name: 'incremental-retry',
    description: 'Retry with incrementally relaxed constraints (memory, timeout, etc.)',
    config: {
      timeout: 300000, // 5 minutes
      retryBackoff: 'exponential',
      maxRetries: 3,
      parallelism: 5,
      relaxConstraints: true,
      constraintSteps: [0.9, 0.7, 0.5] // Try 90%, 70%, 50% of original constraints
    },
    priority: 4,
    applicableErrors: ['constraint_violation', 'validation_failed', 'resource_exceeded']
  },

  /**
   * ADAPTIVE PARALLELISM
   * Dynamically adjust parallelism based on error patterns
   *
   * Use when: Rate limiting or resource contention
   * Example: API rate limit ‚Üí reduce parallelism from 10 to 5
   */
  {
    name: 'adaptive-parallelism',
    description: 'Dynamically adjust parallelism based on resource availability',
    config: {
      timeout: 180000, // 3 minutes
      retryBackoff: 'linear',
      maxRetries: 5,
      parallelism: 10, // Start high
      adaptiveParallelism: true,
      parallelismMin: 1,
      parallelismMax: 20,
      parallelismStep: 2 // Adjust by ¬±2 on each adaptation
    },
    priority: 3,
    applicableErrors: ['rate_limit', 'too_many_requests', 'resource_contention']
  },

  /**
   * CIRCUIT BREAKER
   * Stop retrying if error persists across multiple attempts
   *
   * Use when: Persistent failures that won't resolve with retry
   * Example: Invalid API key ‚Üí fail fast instead of retrying 100 times
   */
  {
    name: 'circuit-breaker',
    description: 'Fail fast on persistent errors to avoid wasted retries',
    config: {
      timeout: 60000, // 1 minute
      retryBackoff: 'none',
      maxRetries: 3, // Limited retries before circuit opens
      parallelism: 5,
      circuitBreaker: true,
      failureThreshold: 3, // Open circuit after 3 consecutive failures
      resetTimeout: 30000 // Try again after 30 seconds
    },
    priority: 2,
    applicableErrors: [
      'authentication_failed',
      'invalid_credentials',
      'permission_denied',
      'not_found',
      'method_not_allowed'
    ]
  },

  /**
   * GRADUAL RELAXATION
   * Progressively relax strictness of validation/constraints
   *
   * Use when: Strict validation preventing completion
   * Example: Schema validation ‚Üí retry with relaxed schema on first fail
   */
  {
    name: 'gradual-relaxation',
    description: 'Progressively relax validation strictness to allow completion',
    config: {
      timeout: 240000, // 4 minutes
      retryBackoff: 'exponential',
      maxRetries: 4,
      parallelism: 5,
      relaxValidation: true,
      validationLevels: ['strict', 'normal', 'permissive', 'minimal']
    },
    priority: 3,
    applicableErrors: ['validation_failed', 'schema_error', 'type_mismatch']
  },

  /**
   * HYBRID APPROACH
   * Combine multiple strategies for complex scenarios
   *
   * Use when: Multiple error types or complex workflows
   * Example: API rate limit + validation error ‚Üí parallel + relaxation
   */
  {
    name: 'hybrid-approach',
    description: 'Combine checkpoint-resume + adaptive-parallelism + fallback',
    config: {
      timeout: 600000, // 10 minutes
      retryBackoff: 'exponential',
      maxRetries: 10,
      parallelism: 10,
      enableCheckpoints: true,
      adaptiveParallelism: true,
      fallbackProvider: true,
      hybrid: true,
      strategies: ['checkpoint-resume', 'adaptive-parallelism', 'fallback']
    },
    priority: 5, // Highest priority for complex scenarios
    applicableErrors: ['timeout', 'network_error', 'rate_limit', 'unknown']
  }
];

/**
 * Get all strategies (basic + advanced)
 */
export function getAllStrategies(): Strategy[] {
  return [
    // Import basic strategies
    ...BASIC_STRATEGIES,
    ...ADVANCED_STRATEGIES
  ];
}

/**
 * Adaptive parallelism calculator
 */
export class AdaptiveParallelismCalculator {
  private currentParallelism: number;
  private readonly min: number;
  private readonly max: number;
  private readonly step: number;

  constructor(initial: number, min: number = 1, max: number = 20, step: number = 2) {
    this.currentParallelism = initial;
    this.min = min;
    this.max = max;
    this.step = step;
  }

  /**
   * Adjust parallelism based on error
   */
  adjust(error: string): number {
    if (error === 'rate_limit' || error === 'too_many_requests') {
      // Decrease parallelism
      this.currentParallelism = Math.max(this.min, this.currentParallelism - this.step);
    } else if (error === 'success') {
      // Increase parallelism on success
      this.currentParallelism = Math.min(this.max, this.currentParallelism + this.step);
    }

    return this.currentParallelism;
  }

  getCurrent(): number {
    return this.currentParallelism;
  }
}

/**
 * Circuit breaker state machine
 */
export class CircuitBreaker {
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  private failureCount: number = 0;
  private readonly failureThreshold: number;
  private readonly resetTimeout: number;
  private openedAt: number = 0;

  constructor(failureThreshold: number = 3, resetTimeout: number = 30000) {
    this.failureThreshold = failureThreshold;
    this.resetTimeout = resetTimeout;
  }

  /**
   * Check if circuit allows execution
   */
  canExecute(): boolean {
    if (this.state === 'closed') {
      return true;
    }

    if (this.state === 'open') {
      // Check if reset timeout has elapsed
      if (Date.now() - this.openedAt >= this.resetTimeout) {
        this.state = 'half-open';
        return true;
      }
      return false;
    }

    // half-open state - allow one attempt
    return true;
  }

  /**
   * Record execution result
   */
  recordResult(success: boolean): void {
    if (success) {
      if (this.state === 'half-open') {
        this.state = 'closed';
      }
      this.failureCount = 0;
    } else {
      this.failureCount++;

      if (this.failureCount >= this.failureThreshold) {
        this.state = 'open';
        this.openedAt = Date.now();
      }
    }
  }

  getState(): 'closed' | 'open' | 'half-open' {
    return this.state;
  }
}
```

**Integration with IterateEngine:**

File: `src/services/IterateEngine.ts`

```typescript
import { ADVANCED_STRATEGIES, AdaptiveParallelismCalculator, CircuitBreaker } from './AdvancedStrategies.js';

export class IterateEngine {
  private adaptiveParallelism?: AdaptiveParallelismCalculator;
  private circuitBreaker?: CircuitBreaker;

  async executeWithStrategy(workflow: Workflow, strategy: Strategy): Promise<ExecutionResult> {
    // Initialize adaptive parallelism if enabled
    if (strategy.config.adaptiveParallelism) {
      this.adaptiveParallelism = new AdaptiveParallelismCalculator(
        strategy.config.parallelism,
        strategy.config.parallelismMin || 1,
        strategy.config.parallelismMax || 20,
        strategy.config.parallelismStep || 2
      );
    }

    // Initialize circuit breaker if enabled
    if (strategy.config.circuitBreaker) {
      this.circuitBreaker = new CircuitBreaker(
        strategy.config.failureThreshold || 3,
        strategy.config.resetTimeout || 30000
      );
    }

    // Execute with advanced strategy features
    let attempt = 0;
    while (attempt < strategy.config.maxRetries) {
      // Check circuit breaker
      if (this.circuitBreaker && !this.circuitBreaker.canExecute()) {
        throw new Error('Circuit breaker open - failing fast');
      }

      try {
        // Adjust parallelism if adaptive
        if (this.adaptiveParallelism) {
          const currentParallelism = this.adaptiveParallelism.getCurrent();
          workflow.config.parallelism = currentParallelism;
        }

        const result = await this.workflowEngine.execute(workflow);

        // Record success
        if (this.circuitBreaker) {
          this.circuitBreaker.recordResult(true);
        }
        if (this.adaptiveParallelism) {
          this.adaptiveParallelism.adjust('success');
        }

        return result;

      } catch (error) {
        attempt++;

        // Record failure
        if (this.circuitBreaker) {
          this.circuitBreaker.recordResult(false);
        }

        // Adjust parallelism on rate limit
        if (this.adaptiveParallelism && error.type === 'rate_limit') {
          this.adaptiveParallelism.adjust('rate_limit');
        }

        // Apply backoff
        await this.applyBackoff(strategy, attempt);
      }
    }

    throw new Error('Max retries exceeded');
  }
}
```

**Testing:**
```typescript
// src/services/__tests__/AdvancedStrategies.test.ts

describe('Advanced Strategies', () => {
  describe('AdaptiveParallelismCalculator', () => {
    it('should decrease parallelism on rate limit', () => {
      const calc = new AdaptiveParallelismCalculator(10, 1, 20, 2);

      const adjusted = calc.adjust('rate_limit');

      expect(adjusted).toBe(8); // 10 - 2
    });

    it('should increase parallelism on success', () => {
      const calc = new AdaptiveParallelismCalculator(10, 1, 20, 2);

      const adjusted = calc.adjust('success');

      expect(adjusted).toBe(12); // 10 + 2
    });

    it('should respect min/max bounds', () => {
      const calc = new AdaptiveParallelismCalculator(2, 1, 20, 2);

      calc.adjust('rate_limit'); // 2 - 2 = 0, but min is 1
      expect(calc.getCurrent()).toBe(1);
    });
  });

  describe('CircuitBreaker', () => {
    it('should open circuit after threshold failures', () => {
      const breaker = new CircuitBreaker(3, 30000);

      expect(breaker.canExecute()).toBe(true);

      breaker.recordResult(false); // Failure 1
      breaker.recordResult(false); // Failure 2
      breaker.recordResult(false); // Failure 3 ‚Üí opens

      expect(breaker.getState()).toBe('open');
      expect(breaker.canExecute()).toBe(false);
    });

    it('should transition to half-open after timeout', async () => {
      const breaker = new CircuitBreaker(3, 100); // 100ms timeout

      breaker.recordResult(false);
      breaker.recordResult(false);
      breaker.recordResult(false); // Opens

      expect(breaker.canExecute()).toBe(false);

      await new Promise(resolve => setTimeout(resolve, 150));

      expect(breaker.canExecute()).toBe(true); // Half-open
    });

    it('should close circuit on success in half-open state', async () => {
      const breaker = new CircuitBreaker(3, 100);

      // Open circuit
      breaker.recordResult(false);
      breaker.recordResult(false);
      breaker.recordResult(false);

      await new Promise(resolve => setTimeout(resolve, 150));

      // Half-open, record success
      breaker.recordResult(true);

      expect(breaker.getState()).toBe('closed');
    });
  });
});
```

**Time Estimate:** 0.25 days

---

### 2. Strategy Effectiveness Telemetry (P0 - Must Have)

**Implementation:**

File: `src/services/StrategyTelemetry.ts` (new file)

```typescript
import Database from 'better-sqlite3';
import { getDatabase } from '../database/connection.js';

export interface StrategyAttempt {
  strategyName: string;
  errorType: string;
  success: boolean;
  durationMs: number;
  metadata: Record<string, unknown>;
  timestamp: number;
}

export class StrategyTelemetry {
  private db: Database.Database;

  constructor() {
    this.db = getDatabase();
    this.initializeSchema();
  }

  private initializeSchema(): void {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS strategy_telemetry (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        strategy_name TEXT NOT NULL,
        error_type TEXT NOT NULL,
        success INTEGER NOT NULL,
        duration_ms INTEGER NOT NULL,
        metadata TEXT,
        timestamp INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_telemetry_strategy
        ON strategy_telemetry(strategy_name);

      CREATE INDEX IF NOT EXISTS idx_telemetry_error_type
        ON strategy_telemetry(error_type);
    `);
  }

  /**
   * Record strategy attempt
   */
  async recordStrategyAttempt(
    strategy: string,
    errorType: string,
    success: boolean,
    duration: number,
    metadata: Record<string, unknown> = {}
  ): Promise<void> {
    this.db.prepare(`
      INSERT INTO strategy_telemetry
      (strategy_name, error_type, success, duration_ms, metadata, timestamp)
      VALUES (?, ?, ?, ?, ?, ?)
    `).run(
      strategy,
      errorType,
      success ? 1 : 0,
      duration,
      JSON.stringify(metadata),
      Date.now()
    );
  }

  /**
   * Get best strategy for error type (based on success rate)
   */
  async getBestStrategyFor(errorType: string): Promise<string | null> {
    const row = this.db.prepare(`
      SELECT
        strategy_name,
        CAST(SUM(success) AS REAL) / COUNT(*) as success_rate,
        COUNT(*) as attempts
      FROM strategy_telemetry
      WHERE error_type = ?
      GROUP BY strategy_name
      HAVING attempts >= 3
      ORDER BY success_rate DESC, attempts DESC
      LIMIT 1
    `).get(errorType) as { strategy_name: string; success_rate: number } | undefined;

    return row?.strategy_name || null;
  }

  /**
   * Get strategy statistics
   */
  async getStrategyStats(strategy: string): Promise<{
    totalAttempts: number;
    successCount: number;
    successRate: number;
    avgDuration: number;
  }> {
    const row = this.db.prepare(`
      SELECT
        COUNT(*) as total_attempts,
        SUM(success) as success_count,
        CAST(SUM(success) AS REAL) / COUNT(*) as success_rate,
        AVG(duration_ms) as avg_duration
      FROM strategy_telemetry
      WHERE strategy_name = ?
    `).get(strategy) as {
      total_attempts: number;
      success_count: number;
      success_rate: number;
      avg_duration: number;
    };

    return {
      totalAttempts: row.total_attempts || 0,
      successCount: row.success_count || 0,
      successRate: row.success_rate || 0,
      avgDuration: row.avg_duration || 0
    };
  }

  /**
   * Get error type distribution for strategy
   */
  async getErrorDistribution(strategy: string): Promise<Map<string, number>> {
    const rows = this.db.prepare(`
      SELECT error_type, COUNT(*) as count
      FROM strategy_telemetry
      WHERE strategy_name = ?
      GROUP BY error_type
      ORDER BY count DESC
    `).all(strategy) as { error_type: string; count: number }[];

    const distribution = new Map<string, number>();
    rows.forEach(row => distribution.set(row.error_type, row.count));

    return distribution;
  }
}
```

**Integration with IterateEngine:**

```typescript
export class IterateEngine {
  private telemetry: StrategyTelemetry;

  async executeWithStrategy(workflow: Workflow, strategy: Strategy): Promise<ExecutionResult> {
    const startTime = Date.now();

    try {
      const result = await this.executeWorkflow(workflow, strategy);

      // Record successful strategy
      await this.telemetry.recordStrategyAttempt(
        strategy.name,
        result.errorType || 'none',
        true,
        Date.now() - startTime,
        { workflow: workflow.name, attempt: result.attempts }
      );

      return result;

    } catch (error) {
      // Record failed strategy
      await this.telemetry.recordStrategyAttempt(
        strategy.name,
        error.type || 'unknown',
        false,
        Date.now() - startTime,
        { workflow: workflow.name, error: error.message }
      );

      throw error;
    }
  }

  /**
   * Select strategy using telemetry data
   */
  async selectStrategyWithTelemetry(errorType: string): Promise<Strategy> {
    // Check telemetry for best strategy
    const bestStrategy = await this.telemetry.getBestStrategyFor(errorType);

    if (bestStrategy) {
      console.log(chalk.cyan(`üìä Using learned strategy: ${bestStrategy}`));
      return this.strategySelector.getStrategy(bestStrategy);
    }

    // Fallback to pattern-based selection
    return this.strategySelector.selectStrategy(errorType);
  }
}
```

**Database Migration:**

File: `src/migrations/015_create_strategy_telemetry.sql`

```sql
CREATE TABLE IF NOT EXISTS strategy_telemetry (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  strategy_name TEXT NOT NULL,
  error_type TEXT NOT NULL,
  success INTEGER NOT NULL,
  duration_ms INTEGER NOT NULL,
  metadata TEXT,
  timestamp INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_telemetry_strategy
  ON strategy_telemetry(strategy_name);

CREATE INDEX IF NOT EXISTS idx_telemetry_error_type
  ON strategy_telemetry(error_type);
```

**Time Estimate:** 0.25 days

---

### 3. Real-Time Progress Monitoring (P0 - Must Have)

**Implementation:**

File: `src/services/IterateProgressMonitor.ts` (new file)

```typescript
import ora, { Ora } from 'ora';
import cliProgress from 'cli-progress';
import chalk from 'chalk';

export class IterateProgressMonitor {
  private spinner?: Ora;
  private progressBar?: cliProgress.SingleBar;

  /**
   * Start iteration monitoring
   */
  startIteration(totalSteps: number, currentAttempt: number, maxAttempts: number): void {
    console.log(chalk.bold.white(`\nüîÑ Iteration ${currentAttempt}/${maxAttempts}\n`));

    this.progressBar = new cliProgress.SingleBar({
      format: `Progress |${chalk.cyan('{bar}')}| {percentage}% | {value}/{total} steps | ETA: {eta}s`,
      barCompleteChar: '\u2588',
      barIncompleteChar: '\u2591',
      hideCursor: true
    });

    this.progressBar.start(totalSteps, 0);
  }

  /**
   * Update progress
   */
  updateProgress(currentStep: number, stepName?: string): void {
    if (this.progressBar) {
      this.progressBar.update(currentStep);
    }

    if (stepName) {
      console.log(chalk.gray(`  ‚Üí ${stepName}`));
    }
  }

  /**
   * Complete iteration (success)
   */
  completeIteration(success: boolean, message?: string): void {
    if (this.progressBar) {
      this.progressBar.stop();
    }

    if (success) {
      console.log(chalk.green(`‚úÖ Iteration succeeded${message ? ': ' + message : ''}\n`));
    } else {
      console.log(chalk.red(`‚ùå Iteration failed${message ? ': ' + message : ''}\n`));
    }
  }

  /**
   * Show strategy change
   */
  showStrategyChange(from: string, to: string, reason: string): void {
    console.log(chalk.yellow(`\nüîÄ Strategy change: ${from} ‚Üí ${to}`));
    console.log(chalk.gray(`   Reason: ${reason}\n`));
  }

  /**
   * Show checkpoint saved
   */
  showCheckpoint(checkpointId: string): void {
    console.log(chalk.cyan(`üíæ Checkpoint saved: ${checkpointId}`));
  }

  /**
   * Show error analysis
   */
  showErrorAnalysis(errorType: string, pattern: string, confidence: number): void {
    console.log(chalk.yellow(`\n‚ö†Ô∏è  Error detected: ${errorType}`));
    console.log(chalk.gray(`   Pattern: ${pattern} (${(confidence * 100).toFixed(0)}% confidence)\n`));
  }

  /**
   * Start spinner for long operation
   */
  startSpinner(message: string): void {
    this.spinner = ora(message).start();
  }

  /**
   * Stop spinner
   */
  stopSpinner(success: boolean, message?: string): void {
    if (this.spinner) {
      if (success) {
        this.spinner.succeed(message);
      } else {
        this.spinner.fail(message);
      }
    }
  }
}
```

**Integration:**

```typescript
export class IterateEngine {
  private monitor: IterateProgressMonitor;

  async iterate(workflow: Workflow): Promise<ExecutionResult> {
    const monitor = new IterateProgressMonitor();

    for (let attempt = 1; attempt <= this.maxIterations; attempt++) {
      monitor.startIteration(workflow.steps.length, attempt, this.maxIterations);

      try {
        for (let i = 0; i < workflow.steps.length; i++) {
          const step = workflow.steps[i];

          monitor.updateProgress(i + 1, step.name);

          await this.executeStep(step);
        }

        monitor.completeIteration(true, 'All steps completed');
        return { success: true, attempts: attempt };

      } catch (error) {
        monitor.showErrorAnalysis(error.type, error.pattern, error.confidence);

        const nextStrategy = await this.selectNextStrategy(error);

        if (nextStrategy.name !== this.currentStrategy.name) {
          monitor.showStrategyChange(
            this.currentStrategy.name,
            nextStrategy.name,
            `Better success rate for ${error.type}`
          );
        }

        monitor.completeIteration(false, error.message);
      }
    }

    throw new Error('Max iterations exceeded');
  }
}
```

**Dependencies:**
```bash
npm install cli-progress ora
```

**Time Estimate:** 0.25 days

---

### 4. Iteration Summary Reports (P1 - Nice to Have)

**Implementation:**

File: `src/services/IterationReporter.ts` (new file)

```typescript
import chalk from 'chalk';
import Table from 'cli-table3';

export interface IterationSummary {
  workflowName: string;
  totalAttempts: number;
  successfulAttempt?: number;
  strategiesUsed: string[];
  errorsEncountered: string[];
  totalDuration: number;
  checkpointsCreated: number;
  fallbacksTriggered: number;
}

export class IterationReporter {
  /**
   * Generate iteration summary report
   */
  generateReport(summary: IterationSummary): string {
    let report = '';

    report += chalk.bold.white('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n');
    report += chalk.bold.white('‚ïë     ITERATION SUMMARY REPORT               ‚ïë\n');
    report += chalk.bold.white('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n\n');

    // Basic info
    report += chalk.cyan('Workflow: ') + summary.workflowName + '\n';
    report += chalk.cyan('Total Attempts: ') + summary.totalAttempts + '\n';
    report += chalk.cyan('Duration: ') + this.formatDuration(summary.totalDuration) + '\n';

    if (summary.successfulAttempt) {
      report += chalk.green('‚úÖ Success on attempt #' + summary.successfulAttempt) + '\n';
    } else {
      report += chalk.red('‚ùå Failed after ' + summary.totalAttempts + ' attempts') + '\n';
    }

    // Strategies table
    report += chalk.bold('\nüìä Strategies Used:\n');
    const strategyTable = new Table({
      head: ['Strategy', 'Attempts'],
      colWidths: [30, 12]
    });

    const strategyCounts = this.countOccurrences(summary.strategiesUsed);
    Object.entries(strategyCounts).forEach(([strategy, count]) => {
      strategyTable.push([strategy, count.toString()]);
    });

    report += strategyTable.toString() + '\n';

    // Errors table
    if (summary.errorsEncountered.length > 0) {
      report += chalk.bold('\n‚ö†Ô∏è  Errors Encountered:\n');
      const errorTable = new Table({
        head: ['Error Type', 'Occurrences'],
        colWidths: [30, 12]
      });

      const errorCounts = this.countOccurrences(summary.errorsEncountered);
      Object.entries(errorCounts).forEach(([error, count]) => {
        errorTable.push([error, count.toString()]);
      });

      report += errorTable.toString() + '\n';
    }

    // Additional metrics
    report += chalk.bold('\nüìà Additional Metrics:\n');
    report += `  Checkpoints Created: ${summary.checkpointsCreated}\n`;
    report += `  Fallbacks Triggered: ${summary.fallbacksTriggered}\n`;

    return report;
  }

  private formatDuration(ms: number): string {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);

    if (hours > 0) {
      return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    } else if (minutes > 0) {
      return `${minutes}m ${seconds % 60}s`;
    } else {
      return `${seconds}s`;
    }
  }

  private countOccurrences(items: string[]): Record<string, number> {
    const counts: Record<string, number> = {};
    items.forEach(item => {
      counts[item] = (counts[item] || 0) + 1;
    });
    return counts;
  }
}
```

**Integration:**

```typescript
export class IterateEngine {
  private reporter: IterationReporter;

  async iterate(workflow: Workflow): Promise<ExecutionResult> {
    const summary: IterationSummary = {
      workflowName: workflow.name,
      totalAttempts: 0,
      strategiesUsed: [],
      errorsEncountered: [],
      totalDuration: 0,
      checkpointsCreated: 0,
      fallbacksTriggered: 0
    };

    const startTime = Date.now();

    try {
      for (let attempt = 1; attempt <= this.maxIterations; attempt++) {
        summary.totalAttempts = attempt;
        summary.strategiesUsed.push(this.currentStrategy.name);

        try {
          await this.executeWithStrategy(workflow, this.currentStrategy);

          summary.successfulAttempt = attempt;
          break;

        } catch (error) {
          summary.errorsEncountered.push(error.type);
          // Continue to next iteration
        }
      }

    } finally {
      summary.totalDuration = Date.now() - startTime;

      // Generate and display report
      const report = this.reporter.generateReport(summary);
      console.log(report);
    }
  }
}
```

**Time Estimate:** 0.25 days

---

## üìä CONSOLIDATED TIMELINE

### Day 1: All Refinements
**Morning (4 hours):**
- Implement 5 advanced strategies
- Add AdaptiveParallelismCalculator and CircuitBreaker
- Unit tests

**Afternoon (4 hours):**
- Implement StrategyTelemetry
- Implement IterateProgressMonitor
- Implement IterationReporter
- Integration testing
- Manual QA

---

## ‚úÖ SUCCESS CRITERIA

### Functional
- [ ] 10 total strategies available (5 basic + 5 advanced)
- [ ] Strategy telemetry tracks effectiveness
- [ ] Real-time progress bars during iteration
- [ ] Summary report generated after each iteration
- [ ] Circuit breaker fails fast on persistent errors
- [ ] Adaptive parallelism adjusts dynamically

### Quality
- [ ] Unit test coverage >80%
- [ ] All tests passing
- [ ] 0 P0 bugs
- [ ] <5 P1 bugs
- [ ] >70% success rate on complex workflows

### Performance
- [ ] Strategy selection <50ms
- [ ] Telemetry lookup <10ms
- [ ] Progress updates <5ms

---

## üìÅ DELIVERABLES

### New Files
- `src/services/AdvancedStrategies.ts`
- `src/services/StrategyTelemetry.ts`
- `src/services/IterateProgressMonitor.ts`
- `src/services/IterationReporter.ts`
- `src/services/__tests__/AdvancedStrategies.test.ts`
- `src/services/__tests__/StrategyTelemetry.test.ts`
- `src/services/__tests__/IterateProgressMonitor.test.ts`
- `src/migrations/015_create_strategy_telemetry.sql`

### Modified Files
- `src/services/IterateEngine.ts` (integrate all refinements)
- `src/services/StrategySelector.ts` (add advanced strategies)

### Dependencies
- `cli-progress` (progress bars)
- `ora` (spinners - already installed)

### Documentation
- Update `docs/iterate-mode.md` with advanced strategies
- Add telemetry usage guide
- Add progress monitoring examples
- Add summary report samples

---

## üöÄ READY TO EXECUTE

This refinement plan transforms Iterate Mode into an intelligent, self-optimizing execution engine with advanced strategies, learning, and comprehensive monitoring.

**Next steps:**
1. Create feature branch: `git checkout -b feature/iterate-mode-refinements`
2. Install dependencies: `npm install cli-progress`
3. Start with morning task (advanced strategies)
4. Follow test-driven development
5. Create PR at end of Day 1

**Let's make Iterate Mode exceptional! üéâ**
