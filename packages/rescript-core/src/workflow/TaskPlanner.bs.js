// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Caml from "rescript/lib/es6/caml.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_MapInt from "rescript/lib/es6/belt_MapInt.js";
import * as Core__Array from "@rescript/core/src/Core__Array.bs.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";

function createTask(id, name, estimatedDuration, dependencies, requiredResources, priority) {
  return {
          id: id,
          name: name,
          estimatedDuration: estimatedDuration,
          dependencies: dependencies,
          requiredResources: requiredResources,
          priority: Caml.int_max(1, 10 < priority ? 10 : priority)
        };
}

function createTaskNodeMap(tasks) {
  return Core__Array.reduce(tasks, undefined, (function (acc, task) {
                var node = {
                  task: task,
                  visitState: "Unvisited",
                  level: 0,
                  earliestStart: 0,
                  latestStart: 0
                };
                return Belt_MapString.set(acc, task.id, node);
              }));
}

function detectCycle(nodeId, nodeMap, path) {
  var node = Belt_MapString.get(nodeMap, nodeId);
  if (node === undefined) {
    return ;
  }
  var match = node.visitState;
  switch (match) {
    case "Unvisited" :
        node.visitState = "Visiting";
        var newPath = path.concat([nodeId]);
        var cycleFound = Core__Array.reduce(node.task.dependencies, undefined, (function (acc, depId) {
                if (acc !== undefined) {
                  return acc;
                } else {
                  return detectCycle(depId, nodeMap, newPath);
                }
              }));
        node.visitState = "Visited";
        return cycleFound;
    case "Visiting" :
        return path.concat([nodeId]);
    case "Visited" :
        return ;
    
  }
}

function topologicalSortVisit(nodeId, nodeMap, result) {
  var node = Belt_MapString.get(nodeMap, nodeId);
  if (node === undefined) {
    return result;
  }
  if (node.visitState === "Visited") {
    return result;
  }
  node.visitState = "Visiting";
  var afterDeps = Core__Array.reduce(node.task.dependencies, result, (function (acc, depId) {
          return topologicalSortVisit(depId, nodeMap, acc);
        }));
  node.visitState = "Visited";
  return afterDeps.concat([nodeId]);
}

function resolveDependencies(tasks) {
  if (tasks.length === 0) {
    return {
            TAG: "Ok",
            _0: []
          };
  }
  var nodeMap = createTaskNodeMap(tasks);
  var checkCycles = function (_idx) {
    while(true) {
      var idx = _idx;
      if (idx >= tasks.length) {
        return ;
      }
      var task = tasks[idx];
      var node = Belt_MapString.get(nodeMap, task.id);
      if (node !== undefined) {
        if (node.visitState === "Unvisited") {
          var cycle = detectCycle(task.id, nodeMap, []);
          if (cycle !== undefined) {
            var cycleStr = cycle.join(" -> ");
            return "Cycle detected: " + cycleStr;
          }
          _idx = idx + 1 | 0;
          continue ;
        }
        _idx = idx + 1 | 0;
        continue ;
      }
      _idx = idx + 1 | 0;
      continue ;
    };
  };
  var errorMsg = checkCycles(0);
  if (errorMsg !== undefined) {
    return {
            TAG: "Error",
            _0: errorMsg
          };
  }
  Belt_MapString.forEach(nodeMap, (function (param, node) {
          node.visitState = "Unvisited";
        }));
  var sorted = Core__Array.reduce(tasks, [], (function (acc, task) {
          return topologicalSortVisit(task.id, nodeMap, acc);
        }));
  var missingDeps = Core__Array.reduce(tasks, [], (function (acc, task) {
          var missing = Belt_Array.keep(task.dependencies, (function (depId) {
                  return Core__Option.isNone(Belt_MapString.get(nodeMap, depId));
                }));
          return acc.concat(missing);
        }));
  if (missingDeps.length <= 0) {
    return {
            TAG: "Ok",
            _0: sorted
          };
  }
  var missingStr = missingDeps.join(", ");
  return {
          TAG: "Error",
          _0: "Missing dependencies: " + missingStr
        };
}

function calculateExecutionLevels(tasks, executionOrder) {
  var taskMap = Belt_MapString.fromArray(Belt_Array.map(tasks, (function (t) {
              return [
                      t.id,
                      t
                    ];
            })));
  return Core__Array.reduce(executionOrder, undefined, (function (acc, taskId) {
                var task = Belt_MapString.get(taskMap, taskId);
                if (task === undefined) {
                  return acc;
                }
                var depLevels = task.dependencies.map(function (depId) {
                      return Core__Option.getWithDefault(Belt_MapString.get(acc, depId), 0);
                    });
                var maxDepLevel = Core__Array.reduce(depLevels, 0, (function (a, b) {
                        if (a > b) {
                          return a;
                        } else {
                          return b;
                        }
                      }));
                return Belt_MapString.set(acc, taskId, maxDepLevel + 1 | 0);
              }));
}

function groupByResourceConflicts(tasksAtLevel) {
  if (tasksAtLevel.length <= 1) {
    return [tasksAtLevel];
  }
  var _remaining = tasksAtLevel;
  var _groups = [];
  while(true) {
    var groups = _groups;
    var remaining = _remaining;
    if (remaining.length === 0) {
      return groups;
    }
    var match = Core__Array.reduce(remaining, [
          [],
          [],
          undefined
        ], (function (param, task) {
            var used = param[2];
            var next = param[1];
            var group = param[0];
            var taskResources = Belt_SetString.fromArray(task.requiredResources);
            var hasConflict = Belt_SetString.size(Belt_SetString.intersect(taskResources, used)) > 0;
            if (hasConflict) {
              return [
                      group,
                      next.concat([task]),
                      used
                    ];
            } else {
              return [
                      group.concat([task]),
                      next,
                      Belt_SetString.union(used, taskResources)
                    ];
            }
          }));
    _groups = groups.concat([match[0]]);
    _remaining = match[1];
    continue ;
  };
}

function findParallelGroups(tasks, executionOrder) {
  var levelMap = calculateExecutionLevels(tasks, executionOrder);
  var taskMap = Belt_MapString.fromArray(Belt_Array.map(tasks, (function (t) {
              return [
                      t.id,
                      t
                    ];
            })));
  var levelGroups = Core__Array.reduce(executionOrder, undefined, (function (acc, taskId) {
          var level = Belt_MapString.get(levelMap, taskId);
          if (level === undefined) {
            return acc;
          }
          var existing = Core__Option.getWithDefault(Belt_MapInt.get(acc, level), []);
          return Belt_MapInt.set(acc, level, existing.concat([taskId]));
        }));
  var allGroups = [];
  Belt_MapInt.forEach(levelGroups, (function (param, taskIds) {
          var tasksAtLevel = Belt_Array.keepMap(taskIds, (function (id) {
                  return Belt_MapString.get(taskMap, id);
                }));
          var subGroups = groupByResourceConflicts(tasksAtLevel);
          subGroups.forEach(function (group) {
                var ids = group.map(function (t) {
                      return t.id;
                    });
                allGroups.push(ids);
              });
        }));
  return allGroups;
}

function calculateEarliestStarts(tasks, executionOrder) {
  var taskMap = Belt_MapString.fromArray(Belt_Array.map(tasks, (function (t) {
              return [
                      t.id,
                      t
                    ];
            })));
  return Core__Array.reduce(executionOrder, undefined, (function (acc, taskId) {
                var task = Belt_MapString.get(taskMap, taskId);
                if (task === undefined) {
                  return acc;
                }
                var depFinishes = task.dependencies.map(function (depId) {
                      var depStart = Core__Option.getWithDefault(Belt_MapString.get(acc, depId), 0);
                      var depTask = Belt_MapString.get(taskMap, depId);
                      var depDuration = Core__Option.getWithDefault(Core__Option.map(depTask, (function (t) {
                                  return t.estimatedDuration;
                                })), 0);
                      return depStart + depDuration | 0;
                    });
                var earliestStart = Core__Array.reduce(depFinishes, 0, (function (a, b) {
                        if (a > b) {
                          return a;
                        } else {
                          return b;
                        }
                      }));
                return Belt_MapString.set(acc, taskId, earliestStart);
              }));
}

function calculateLatestStarts(tasks, executionOrder, projectEndTime) {
  var taskMap = Belt_MapString.fromArray(Belt_Array.map(tasks, (function (t) {
              return [
                      t.id,
                      t
                    ];
            })));
  var reversed = Belt_Array.reverse(executionOrder);
  return Belt_Array.reduce(reversed, undefined, (function (acc, taskId) {
                var task = Belt_MapString.get(taskMap, taskId);
                if (task === undefined) {
                  return acc;
                }
                var dependents = Belt_Array.keep(tasks, (function (t) {
                        return Belt_Array.some(t.dependencies, (function (depId) {
                                      return depId === taskId;
                                    }));
                      }));
                var latestStart;
                if (dependents.length === 0) {
                  latestStart = projectEndTime - task.estimatedDuration | 0;
                } else {
                  var depStarts = Belt_Array.map(dependents, (function (dep) {
                          return Core__Option.getWithDefault(Belt_MapString.get(acc, dep.id), projectEndTime);
                        }));
                  var minDepStart = Belt_Array.reduce(depStarts, projectEndTime, (function (a, b) {
                          if (a < b) {
                            return a;
                          } else {
                            return b;
                          }
                        }));
                  latestStart = minDepStart - task.estimatedDuration | 0;
                }
                return Belt_MapString.set(acc, taskId, latestStart);
              }));
}

function findCriticalPath(tasks, executionOrder) {
  if (tasks.length === 0 || executionOrder.length === 0) {
    return [];
  }
  var taskMap = Belt_MapString.fromArray(Belt_Array.map(tasks, (function (t) {
              return [
                      t.id,
                      t
                    ];
            })));
  var earliestStarts = calculateEarliestStarts(tasks, executionOrder);
  var projectEndTime = Belt_Array.reduce(executionOrder, 0, (function (acc, taskId) {
          var start = Core__Option.getWithDefault(Belt_MapString.get(earliestStarts, taskId), 0);
          var duration = Core__Option.getWithDefault(Core__Option.map(Belt_MapString.get(taskMap, taskId), (function (t) {
                      return t.estimatedDuration;
                    })), 0);
          return Caml.int_max(acc, start + duration | 0);
        }));
  var latestStarts = calculateLatestStarts(tasks, executionOrder, projectEndTime);
  return Belt_Array.keep(executionOrder, (function (taskId) {
                var earliest = Core__Option.getWithDefault(Belt_MapString.get(earliestStarts, taskId), 0);
                var latest = Core__Option.getWithDefault(Belt_MapString.get(latestStarts, taskId), 0);
                return earliest === latest;
              }));
}

function validatePlan(plan) {
  var errors = [];
  if (plan.executionOrder.length !== plan.tasks.length) {
    errors.push("Execution order length mismatch");
  }
  var taskIds = Belt_SetString.fromArray(plan.tasks.map(function (t) {
            return t.id;
          }));
  plan.executionOrder.forEach(function (id) {
        if (!Belt_SetString.has(taskIds, id)) {
          errors.push("Task " + id + " in execution order but not in tasks");
          return ;
        }
        
      });
  var taskMap = Belt_MapString.fromArray(plan.tasks.map(function (t) {
            return [
                    t.id,
                    t
                  ];
          }));
  var match = Core__Array.reduce(plan.executionOrder, [
        [],
        undefined
      ], (function (param, taskId) {
          var seenTasks = param[1];
          var errs = param[0];
          var task = Belt_MapString.get(taskMap, taskId);
          if (task === undefined) {
            return [
                    errs,
                    seenTasks
                  ];
          }
          var newErrors = Core__Array.reduce(task.dependencies, errs, (function (acc, depId) {
                  if (Belt_SetString.has(seenTasks, depId)) {
                    return acc;
                  } else {
                    return acc.concat(["Task " + taskId + " scheduled before dependency " + depId]);
                  }
                }));
          return [
                  newErrors,
                  Belt_SetString.add(seenTasks, taskId)
                ];
        }));
  match[0].forEach(function (err) {
        errors.push(err);
      });
  plan.parallelGroups.forEach(function (group) {
        for(var i = 0 ,i_finish = group.length; i < i_finish; ++i){
          var taskId = group[i];
          var task = Belt_MapString.get(taskMap, taskId);
          if (task !== undefined) {
            var groupSet = Belt_SetString.fromArray(group);
            task.dependencies.forEach((function(taskId,groupSet){
                return function (depId) {
                  if (Belt_SetString.has(groupSet, depId)) {
                    errors.push("Task " + taskId + " depends on " + depId + " in same parallel group");
                    return ;
                  }
                  
                }
                }(taskId,groupSet)));
          }
          
        }
      });
  if (errors.length === 0) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: errors
          };
  }
}

function optimizePlan(plan) {
  var levelMap = calculateExecutionLevels(plan.tasks, plan.executionOrder);
  var taskMap = Belt_MapString.fromArray(plan.tasks.map(function (t) {
            return [
                    t.id,
                    t
                  ];
          }));
  var levels = Core__Array.reduce(plan.executionOrder, undefined, (function (acc, taskId) {
          var level = Core__Option.getWithDefault(Belt_MapString.get(levelMap, taskId), 0);
          var existing = Core__Option.getWithDefault(Belt_MapInt.get(acc, level), []);
          return Belt_MapInt.set(acc, level, existing.concat([taskId]));
        }));
  var maxLevel = Core__Array.reduce(Belt_MapInt.keysToArray(levels), 0, (function (a, b) {
          if (a > b) {
            return a;
          } else {
            return b;
          }
        }));
  var optimizedOrder = Core__Array.reduce(Core__Array.fromInitializer(maxLevel, (function (i) {
              return i + 1 | 0;
            })), [], (function (acc, level) {
          var taskIds = Belt_MapInt.get(levels, level);
          if (taskIds === undefined) {
            return acc;
          }
          var sorted = taskIds.toSorted(function (a, b) {
                var taskA = Belt_MapString.get(taskMap, a);
                var taskB = Belt_MapString.get(taskMap, b);
                if (taskA !== undefined) {
                  if (taskB !== undefined) {
                    return taskB.priority - taskA.priority | 0;
                  } else {
                    return 0;
                  }
                } else {
                  return 0;
                }
              });
          return acc.concat(sorted);
        }));
  var parallelGroups = findParallelGroups(plan.tasks, optimizedOrder);
  var criticalPath = findCriticalPath(plan.tasks, optimizedOrder);
  return {
          tasks: plan.tasks,
          executionOrder: optimizedOrder,
          parallelGroups: parallelGroups,
          criticalPath: criticalPath,
          estimatedTotalTime: plan.estimatedTotalTime
        };
}

function plan(tasks) {
  var msg = resolveDependencies(tasks);
  if (msg.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: msg._0
          };
  }
  var executionOrder = msg._0;
  var parallelGroups = findParallelGroups(tasks, executionOrder);
  var criticalPath = findCriticalPath(tasks, executionOrder);
  var taskMap = Belt_MapString.fromArray(Belt_Array.map(tasks, (function (t) {
              return [
                      t.id,
                      t
                    ];
            })));
  var earliestStarts = calculateEarliestStarts(tasks, executionOrder);
  var estimatedTotalTime = Belt_Array.reduce(executionOrder, 0, (function (acc, taskId) {
          var start = Core__Option.getWithDefault(Belt_MapString.get(earliestStarts, taskId), 0);
          var duration = Core__Option.getWithDefault(Core__Option.map(Belt_MapString.get(taskMap, taskId), (function (t) {
                      return t.estimatedDuration;
                    })), 0);
          return Caml.int_max(acc, start + duration | 0);
        }));
  var taskPlan = {
    tasks: tasks,
    executionOrder: executionOrder,
    parallelGroups: parallelGroups,
    criticalPath: criticalPath,
    estimatedTotalTime: estimatedTotalTime
  };
  var errors = validatePlan(taskPlan);
  if (errors.TAG === "Ok") {
    var optimized = optimizePlan(taskPlan);
    return {
            TAG: "Ok",
            _0: optimized
          };
  }
  var errorStr = errors._0.join("; ");
  return {
          TAG: "Error",
          _0: "Plan validation failed: " + errorStr
        };
}

function getTaskById(plan, taskId) {
  return Belt_Array.getBy(plan.tasks, (function (t) {
                return t.id === taskId;
              }));
}

function getTotalSlack(plan) {
  var criticalSet = Belt_SetString.fromArray(plan.criticalPath);
  return Belt_Array.keep(plan.tasks, (function (t) {
                return !Belt_SetString.has(criticalSet, t.id);
              })).length;
}

function getMaxParallelism(plan) {
  return Core__Array.reduce(plan.parallelGroups, 0, (function (acc, group) {
                if (acc > group.length) {
                  return acc;
                } else {
                  return group.length;
                }
              }));
}

function getPlanStatistics(plan) {
  return {
          totalTasks: plan.tasks.length,
          criticalPathLength: plan.criticalPath.length,
          maxParallelism: getMaxParallelism(plan),
          estimatedTime: plan.estimatedTotalTime,
          totalSlack: getTotalSlack(plan)
        };
}

export {
  createTask ,
  createTaskNodeMap ,
  detectCycle ,
  topologicalSortVisit ,
  resolveDependencies ,
  calculateExecutionLevels ,
  groupByResourceConflicts ,
  findParallelGroups ,
  calculateEarliestStarts ,
  calculateLatestStarts ,
  findCriticalPath ,
  validatePlan ,
  optimizePlan ,
  plan ,
  getTaskById ,
  getTotalSlack ,
  getMaxParallelism ,
  getPlanStatistics ,
}
/* No side effect */
