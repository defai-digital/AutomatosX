# AutomatosX v8.0.0 - Interactive CLI Refinements PRD

**Date:** 2025-01-13
**Version:** 8.0.0 ‚Üí 8.0.1
**Status:** Ready for Implementation
**Timeline:** 2 days
**Priority:** P1 (Polish & Enhancement)

---

## üéØ EXECUTIVE SUMMARY

### Mission

Enhance the Interactive CLI (REPL) from "functional" to "production-ready with exceptional UX" by adding multiline input support, syntax highlighting, rich table formatting, and Ctrl+R history search.

### Current State (80% Complete)

**What Works:**
- ‚úÖ Core REPL loop with readline
- ‚úÖ Streaming responses (token-by-token display)
- ‚úÖ 13/15 slash commands implemented
- ‚úÖ Conversation persistence (SQLite)
- ‚úÖ Autocomplete for commands
- ‚úÖ Welcome screen with help text
- ‚úÖ Context management
- ‚úÖ Error handling

**What's Missing:**
- ‚ùå Multiline input support (for code blocks, long queries)
- ‚ùå Syntax highlighting (code in responses)
- ‚ùå Rich table formatting (for data results)
- ‚ùå Ctrl+R history search (reverse search)

### Success Criteria

After refinements:
- ‚úÖ Users can paste multi-line code blocks seamlessly
- ‚úÖ Code in responses is syntax-highlighted
- ‚úÖ Tabular data displays in formatted ASCII tables
- ‚úÖ Users can search command history with Ctrl+R
- ‚úÖ UX feels polished and professional

---

## üìã REFINEMENT AREAS

### 1. Multiline Input Support (P0 - Must Have)

**Current Problem:**
```
ax> function calculateTotal(items) {
   ... (nothing happens, just returns to prompt)
```

**Desired Behavior:**
```
ax> ```
... (multiline mode activated)
... function calculateTotal(items) {
...   return items.reduce((sum, item) => sum + item.price, 0);
... }
... ```
Processing your code...
```

**Implementation:**

File: `src/cli/interactive/REPLSession.ts`

```typescript
export class REPLSession {
  private multilineBuffer: string[] = [];
  private multilineMode: boolean = false;
  private multilineTrigger: string = '```';

  private async handleInput(line: string): Promise<void> {
    // Check for multiline trigger (```)
    if (line.trim() === this.multilineTrigger) {
      if (!this.multilineMode) {
        // Start multiline mode
        this.multilineMode = true;
        this.multilineBuffer = [];
        this.rl.setPrompt(chalk.gray('... '));
        console.log(chalk.gray('(Multiline mode - type ``` again to finish)'));
        return;
      } else {
        // End multiline mode
        this.multilineMode = false;
        const fullInput = this.multilineBuffer.join('\n');
        this.rl.setPrompt(this.getPrompt());
        await this.processInput(fullInput);
        this.multilineBuffer = [];
        return;
      }
    }

    // In multiline mode - accumulate lines
    if (this.multilineMode) {
      this.multilineBuffer.push(line);
      this.rl.prompt();
      return;
    }

    // Normal single-line processing
    await this.processInput(line.trim());
  }

  private getPrompt(): string {
    return this.multilineMode
      ? chalk.gray('... ')
      : chalk.cyan('ax> ');
  }
}
```

**Edge Cases:**
- Empty multiline blocks (just ``` then ```) ‚Üí treat as no-op
- Interrupted multiline (Ctrl+C) ‚Üí clear buffer, exit multiline mode
- Nested ``` (in code comments) ‚Üí use 4-backtick delimiter `````

**Testing:**
```typescript
// src/cli/interactive/__tests__/REPLSession.test.ts

describe('Multiline Input', () => {
  it('should enter multiline mode on triple backticks', async () => {
    const session = new REPLSession();
    await session.start();

    session.handleInput('```');
    expect(session['multilineMode']).toBe(true);
    expect(session.rl.getPrompt()).toBe(chalk.gray('... '));
  });

  it('should accumulate lines in multiline mode', async () => {
    const session = new REPLSession();
    await session.start();

    await session.handleInput('```');
    await session.handleInput('function test() {');
    await session.handleInput('  return 42;');
    await session.handleInput('}');

    expect(session['multilineBuffer']).toEqual([
      'function test() {',
      '  return 42;',
      '}'
    ]);
  });

  it('should process accumulated input on exit trigger', async () => {
    const session = new REPLSession();
    const processSpy = vi.spyOn(session as any, 'processInput');
    await session.start();

    await session.handleInput('```');
    await session.handleInput('line 1');
    await session.handleInput('line 2');
    await session.handleInput('```');

    expect(processSpy).toHaveBeenCalledWith('line 1\nline 2');
    expect(session['multilineMode']).toBe(false);
  });

  it('should handle Ctrl+C interruption in multiline mode', async () => {
    const session = new REPLSession();
    await session.start();

    await session.handleInput('```');
    await session.handleInput('line 1');
    session.handleSIGINT(); // Simulate Ctrl+C

    expect(session['multilineMode']).toBe(false);
    expect(session['multilineBuffer']).toEqual([]);
  });
});
```

**Time Estimate:** 0.5 days

---

### 2. Syntax Highlighting (P0 - Must Have)

**Current Problem:**
```
ax> /help
Available commands:
  /agents - List all agents
  /status - Show system status
```

**Desired Behavior:**
```
ax> /help
Available commands:
  /agents - List all agents       [highlighted in blue]
  /status - Show system status    [highlighted in blue]

Code example:
  function hello() {              [function in blue, string in green]
    return "Hello, world!";
  }
```

**Implementation:**

File: `src/cli/interactive/SyntaxHighlighter.ts` (new file)

```typescript
import hljs from 'highlight.js';
import chalk from 'chalk';

export class SyntaxHighlighter {
  private readonly languageMap: Record<string, string> = {
    'js': 'javascript',
    'ts': 'typescript',
    'py': 'python',
    'rs': 'rust',
    'go': 'go',
    'java': 'java',
    'cpp': 'cpp',
    'c': 'c',
    'sh': 'bash',
    'yml': 'yaml',
    'yaml': 'yaml',
    'json': 'json',
    'sql': 'sql',
    'md': 'markdown'
  };

  /**
   * Highlight code with syntax coloring
   * @param code - Raw code string
   * @param language - Optional language hint (auto-detect if not provided)
   * @returns Syntax-highlighted code with chalk colors
   */
  highlightCode(code: string, language?: string): string {
    try {
      const lang = this.resolveLanguage(language);

      if (lang) {
        const highlighted = hljs.highlight(code, { language: lang });
        return this.applyChalkColors(highlighted.value);
      } else {
        // Auto-detect language
        const highlighted = hljs.highlightAuto(code);
        return this.applyChalkColors(highlighted.value);
      }
    } catch (error) {
      // Fallback to plain text if highlighting fails
      return code;
    }
  }

  /**
   * Resolve language alias to full name
   */
  private resolveLanguage(language?: string): string | undefined {
    if (!language) return undefined;
    return this.languageMap[language.toLowerCase()] || language;
  }

  /**
   * Convert highlight.js HTML to chalk-colored terminal output
   */
  private applyChalkColors(html: string): string {
    return html
      // Keywords (if, function, class, etc.)
      .replace(/<span class="hljs-keyword">(.*?)<\/span>/g, (_, text) => chalk.blue(text))

      // Strings
      .replace(/<span class="hljs-string">(.*?)<\/span>/g, (_, text) => chalk.green(text))

      // Numbers
      .replace(/<span class="hljs-number">(.*?)<\/span>/g, (_, text) => chalk.yellow(text))

      // Comments
      .replace(/<span class="hljs-comment">(.*?)<\/span>/g, (_, text) => chalk.gray(text))

      // Function names
      .replace(/<span class="hljs-title function_">(.*?)<\/span>/g, (_, text) => chalk.cyan(text))

      // Class names
      .replace(/<span class="hljs-title class_">(.*?)<\/span>/g, (_, text) => chalk.magenta(text))

      // Built-in types
      .replace(/<span class="hljs-built_in">(.*?)<\/span>/g, (_, text) => chalk.blueBright(text))

      // Remove remaining HTML tags
      .replace(/<[^>]+>/g, '');
  }

  /**
   * Detect code blocks in markdown and highlight them
   * @param markdown - Markdown text with ``` code blocks
   * @returns Markdown with highlighted code blocks
   */
  highlightMarkdownCodeBlocks(markdown: string): string {
    const codeBlockRegex = /```(\w+)?\n([\s\S]*?)```/g;

    return markdown.replace(codeBlockRegex, (match, lang, code) => {
      const highlighted = this.highlightCode(code, lang);
      const header = lang ? chalk.gray(`\`\`\`${lang}`) : chalk.gray('```');
      return `${header}\n${highlighted}\n${chalk.gray('```')}`;
    });
  }
}
```

**Integration with StreamingHandler:**

File: `src/cli/interactive/StreamingHandler.ts`

```typescript
import { SyntaxHighlighter } from './SyntaxHighlighter.js';

export class StreamingHandler {
  private highlighter: SyntaxHighlighter;

  constructor() {
    this.highlighter = new SyntaxHighlighter();
  }

  async displayStreamingResponse(stream: AsyncIterable<string>): Promise<void> {
    let fullResponse = '';

    for await (const chunk of stream) {
      fullResponse += chunk;
      process.stdout.write(chunk);
    }

    // Post-process for syntax highlighting (if in code blocks)
    const highlighted = this.highlighter.highlightMarkdownCodeBlocks(fullResponse);

    // Clear current output
    process.stdout.write('\r\x1b[K');

    // Write highlighted version
    console.log(highlighted);
  }

  displayCodeSnippet(code: string, language?: string): void {
    const highlighted = this.highlighter.highlightCode(code, language);
    console.log(highlighted);
  }
}
```

**Testing:**
```typescript
// src/cli/interactive/__tests__/SyntaxHighlighter.test.ts

describe('SyntaxHighlighter', () => {
  const highlighter = new SyntaxHighlighter();

  it('should highlight JavaScript keywords', () => {
    const code = 'function test() { return 42; }';
    const highlighted = highlighter.highlightCode(code, 'javascript');

    expect(highlighted).toContain(chalk.blue('function'));
    expect(highlighted).toContain(chalk.yellow('42'));
  });

  it('should highlight TypeScript types', () => {
    const code = 'const x: string = "hello";';
    const highlighted = highlighter.highlightCode(code, 'typescript');

    expect(highlighted).toContain(chalk.blue('const'));
    expect(highlighted).toContain(chalk.green('"hello"'));
  });

  it('should auto-detect language', () => {
    const code = 'def hello():\n    return "world"';
    const highlighted = highlighter.highlightCode(code);

    expect(highlighted).toContain(chalk.blue('def'));
    expect(highlighted).toContain(chalk.green('"world"'));
  });

  it('should highlight markdown code blocks', () => {
    const markdown = 'Here is code:\n```js\nconst x = 42;\n```\nEnd.';
    const highlighted = highlighter.highlightMarkdownCodeBlocks(markdown);

    expect(highlighted).toContain(chalk.blue('const'));
    expect(highlighted).toContain(chalk.gray('```'));
  });

  it('should fallback gracefully on invalid code', () => {
    const code = '<<invalid syntax>>';
    const highlighted = highlighter.highlightCode(code, 'unknown');

    expect(highlighted).toBe(code); // No highlighting, plain text
  });
});
```

**Dependencies:**
```bash
npm install highlight.js
```

**Time Estimate:** 0.5 days

---

### 3. Rich Table Formatting (P0 - Must Have)

**Current Problem:**
```
ax> /agents
Agents: backend, frontend, security, data
```

**Desired Behavior:**
```
ax> /agents
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Name     ‚îÇ Category     ‚îÇ Description                      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ backend  ‚îÇ Engineering  ‚îÇ Backend development & APIs       ‚îÇ
‚îÇ frontend ‚îÇ Engineering  ‚îÇ Frontend & UI development        ‚îÇ
‚îÇ security ‚îÇ Specialist   ‚îÇ Security audits & hardening      ‚îÇ
‚îÇ data     ‚îÇ Engineering  ‚îÇ Data modeling & ETL pipelines    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementation:**

File: `src/cli/interactive/TableFormatter.ts` (new file)

```typescript
import Table from 'cli-table3';
import chalk from 'chalk';

export interface TableColumn {
  header: string;
  key: string;
  width?: number;
  align?: 'left' | 'center' | 'right';
  color?: (value: string) => string;
}

export class TableFormatter {
  /**
   * Create formatted ASCII table
   * @param columns - Column definitions
   * @param rows - Data rows
   * @param options - Table styling options
   */
  createTable(
    columns: TableColumn[],
    rows: Record<string, unknown>[],
    options: {
      title?: string;
      compact?: boolean;
    } = {}
  ): string {
    const table = new Table({
      head: columns.map(col => chalk.cyan.bold(col.header)),
      colWidths: columns.map(col => col.width),
      colAligns: columns.map(col => col.align || 'left'),
      chars: this.getTableChars(options.compact || false),
      style: {
        head: [],
        border: []
      }
    });

    // Add rows
    rows.forEach(row => {
      const formattedRow = columns.map(col => {
        const value = String(row[col.key] ?? '');
        return col.color ? col.color(value) : value;
      });
      table.push(formattedRow);
    });

    let output = '';

    if (options.title) {
      output += chalk.bold.white(`\n${options.title}\n`);
    }

    output += table.toString();

    return output;
  }

  /**
   * Create simple two-column key-value table
   */
  createKeyValueTable(data: Record<string, string | number>): string {
    const table = new Table({
      chars: this.getTableChars(false),
      style: { head: [], border: [] }
    });

    Object.entries(data).forEach(([key, value]) => {
      table.push({
        [chalk.cyan(key)]: String(value)
      });
    });

    return table.toString();
  }

  /**
   * Create compact list (for small datasets)
   */
  createList(items: string[], options: { bullet?: string; color?: (s: string) => string } = {}): string {
    const bullet = options.bullet || '‚Ä¢';
    const color = options.color || ((s: string) => s);

    return items
      .map(item => `  ${chalk.gray(bullet)} ${color(item)}`)
      .join('\n');
  }

  /**
   * Get table border characters (Unicode box drawing)
   */
  private getTableChars(compact: boolean) {
    if (compact) {
      // Compact style (no vertical separators)
      return {
        'top': '‚îÄ', 'top-mid': '‚î¨', 'top-left': '‚îå', 'top-right': '‚îê',
        'bottom': '‚îÄ', 'bottom-mid': '‚î¥', 'bottom-left': '‚îî', 'bottom-right': '‚îò',
        'left': '‚îÇ', 'left-mid': '‚îú', 'mid': '‚îÄ', 'mid-mid': '‚îº',
        'right': '‚îÇ', 'right-mid': '‚î§', 'middle': ' '
      };
    } else {
      // Full box drawing
      return {
        'top': '‚îÄ', 'top-mid': '‚î¨', 'top-left': '‚îå', 'top-right': '‚îê',
        'bottom': '‚îÄ', 'bottom-mid': '‚î¥', 'bottom-left': '‚îî', 'bottom-right': '‚îò',
        'left': '‚îÇ', 'left-mid': '‚îú', 'mid': '‚îÄ', 'mid-mid': '‚îº',
        'right': '‚îÇ', 'right-mid': '‚î§', 'middle': '‚îÇ'
      };
    }
  }
}
```

**Integration with Commands:**

File: `src/cli/interactive/commands/ListAgentsCommand.ts`

```typescript
import { TableFormatter } from '../TableFormatter.js';

export class ListAgentsCommand implements SlashCommand {
  private formatter: TableFormatter;

  constructor() {
    this.formatter = new TableFormatter();
  }

  async execute(args: string[], context: ConversationContext): Promise<void> {
    const agents = await this.agentRegistry.listAgents();

    const columns = [
      { header: 'Name', key: 'name', width: 20, color: chalk.white },
      { header: 'Category', key: 'category', width: 15, color: chalk.blue },
      { header: 'Description', key: 'description', width: 40 },
      { header: 'Status', key: 'status', width: 10, color: this.statusColor }
    ];

    const rows = agents.map(agent => ({
      name: agent.name,
      category: agent.category,
      description: agent.description,
      status: agent.enabled ? 'Active' : 'Disabled'
    }));

    const table = this.formatter.createTable(columns, rows, {
      title: 'Available AI Agents'
    });

    console.log(table);
  }

  private statusColor(status: string): string {
    return status === 'Active' ? chalk.green(status) : chalk.gray(status);
  }
}
```

**Testing:**
```typescript
// src/cli/interactive/__tests__/TableFormatter.test.ts

describe('TableFormatter', () => {
  const formatter = new TableFormatter();

  it('should create formatted table with headers', () => {
    const columns = [
      { header: 'Name', key: 'name', width: 15 },
      { header: 'Age', key: 'age', width: 10 }
    ];
    const rows = [
      { name: 'Alice', age: 30 },
      { name: 'Bob', age: 25 }
    ];

    const table = formatter.createTable(columns, rows);

    expect(table).toContain('Name');
    expect(table).toContain('Age');
    expect(table).toContain('Alice');
    expect(table).toContain('Bob');
    expect(table).toContain('‚îå');
    expect(table).toContain('‚îî');
  });

  it('should create key-value table', () => {
    const data = {
      'Version': '8.0.0',
      'Status': 'Running',
      'Uptime': '2h 30m'
    };

    const table = formatter.createKeyValueTable(data);

    expect(table).toContain('Version');
    expect(table).toContain('8.0.0');
    expect(table).toContain('Status');
  });

  it('should create compact list', () => {
    const items = ['Item 1', 'Item 2', 'Item 3'];
    const list = formatter.createList(items);

    expect(list).toContain('‚Ä¢');
    expect(list).toContain('Item 1');
    expect(list).toContain('Item 2');
  });

  it('should apply custom colors to columns', () => {
    const columns = [
      { header: 'Status', key: 'status', width: 10, color: chalk.green }
    ];
    const rows = [{ status: 'Active' }];

    const table = formatter.createTable(columns, rows);

    expect(table).toContain(chalk.green('Active'));
  });
});
```

**Dependencies:**
```bash
npm install cli-table3
```

**Time Estimate:** 0.25 days

---

### 4. Ctrl+R History Search (P1 - Nice to Have)

**Current Problem:**
```
ax> (user presses Ctrl+R)
(nothing happens, or terminal interrupt)
```

**Desired Behavior:**
```
ax> (user presses Ctrl+R)
(reverse-i-search)`': _
(reverse-i-search)`aud': ax workflow run security-audit.yaml
```

**Implementation:**

File: `src/cli/interactive/REPLSession.ts`

```typescript
import readline from 'readline';

export class REPLSession {
  private historySearchMode: boolean = false;
  private historySearchQuery: string = '';
  private historySearchResults: string[] = [];
  private historySearchIndex: number = 0;

  setupReadlineInterface(): void {
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: this.getPrompt(),
      historySize: 1000
    });

    // Enable Ctrl+R for reverse search
    this.rl.input.on('keypress', (char: string, key: readline.Key) => {
      if (key && key.ctrl && key.name === 'r') {
        this.enterHistorySearchMode();
      } else if (this.historySearchMode) {
        this.handleHistorySearchKeypress(char, key);
      }
    });

    // Enable raw mode for Ctrl+R detection
    if (process.stdin.isTTY) {
      (process.stdin as any).setRawMode(true);
    }
  }

  private enterHistorySearchMode(): void {
    this.historySearchMode = true;
    this.historySearchQuery = '';
    this.historySearchResults = [];
    this.historySearchIndex = 0;
    this.updateHistorySearchPrompt();
  }

  private exitHistorySearchMode(selectCurrent: boolean = false): void {
    this.historySearchMode = false;

    if (selectCurrent && this.historySearchResults.length > 0) {
      const selected = this.historySearchResults[this.historySearchIndex];
      this.rl.write(null, { ctrl: true, name: 'u' }); // Clear line
      this.rl.write(selected);
    }

    this.rl.setPrompt(this.getPrompt());
    this.rl.prompt();
  }

  private handleHistorySearchKeypress(char: string, key: readline.Key): void {
    if (!key) return;

    if (key.name === 'escape' || (key.ctrl && key.name === 'c')) {
      // Cancel search
      this.exitHistorySearchMode(false);
      return;
    }

    if (key.name === 'return') {
      // Accept current result
      this.exitHistorySearchMode(true);
      return;
    }

    if (key.ctrl && key.name === 'r') {
      // Next match (cycle through results)
      if (this.historySearchResults.length > 0) {
        this.historySearchIndex = (this.historySearchIndex + 1) % this.historySearchResults.length;
        this.updateHistorySearchPrompt();
      }
      return;
    }

    if (key.name === 'backspace') {
      // Remove last character from query
      this.historySearchQuery = this.historySearchQuery.slice(0, -1);
    } else if (char && !key.ctrl && !key.meta) {
      // Add character to query
      this.historySearchQuery += char;
    } else {
      return;
    }

    // Search history
    this.searchHistory();
    this.updateHistorySearchPrompt();
  }

  private searchHistory(): void {
    const history = (this.rl as any).history || [];

    if (!this.historySearchQuery) {
      this.historySearchResults = [];
      return;
    }

    this.historySearchResults = history.filter((entry: string) =>
      entry.toLowerCase().includes(this.historySearchQuery.toLowerCase())
    );

    this.historySearchIndex = 0;
  }

  private updateHistorySearchPrompt(): void {
    const query = this.historySearchQuery || '';
    const current = this.historySearchResults[this.historySearchIndex] || '';

    const searchPrompt = chalk.gray(`(reverse-i-search)\`${query}': ${current}`);

    // Clear line and write search prompt
    process.stdout.write('\r\x1b[K');
    process.stdout.write(searchPrompt);
  }
}
```

**Testing:**
```typescript
// src/cli/interactive/__tests__/REPLSession.test.ts

describe('History Search (Ctrl+R)', () => {
  it('should enter history search mode on Ctrl+R', async () => {
    const session = new REPLSession();
    await session.start();

    // Simulate Ctrl+R keypress
    session['rl'].input.emit('keypress', null, { ctrl: true, name: 'r' });

    expect(session['historySearchMode']).toBe(true);
  });

  it('should search history as user types', async () => {
    const session = new REPLSession();
    await session.start();

    // Add history entries
    (session['rl'] as any).history = [
      'ax workflow run test.yaml',
      'ax workflow run security-audit.yaml',
      'ax status'
    ];

    session['enterHistorySearchMode']();
    session['historySearchQuery'] = 'audit';
    session['searchHistory']();

    expect(session['historySearchResults']).toEqual([
      'ax workflow run security-audit.yaml'
    ]);
  });

  it('should cycle through matches on repeated Ctrl+R', async () => {
    const session = new REPLSession();
    await session.start();

    (session['rl'] as any).history = [
      'ax workflow run test.yaml',
      'ax workflow run audit.yaml',
      'ax workflow run security.yaml'
    ];

    session['enterHistorySearchMode']();
    session['historySearchQuery'] = 'workflow';
    session['searchHistory']();

    expect(session['historySearchIndex']).toBe(0);

    // Simulate Ctrl+R again
    session['handleHistorySearchKeypress'](null, { ctrl: true, name: 'r' });
    expect(session['historySearchIndex']).toBe(1);

    session['handleHistorySearchKeypress'](null, { ctrl: true, name: 'r' });
    expect(session['historySearchIndex']).toBe(2);
  });

  it('should exit search mode on Enter', async () => {
    const session = new REPLSession();
    await session.start();

    session['enterHistorySearchMode']();
    session['historySearchQuery'] = 'test';
    session['historySearchResults'] = ['ax workflow run test.yaml'];

    const writeSpy = vi.spyOn(session['rl'], 'write');

    session['handleHistorySearchKeypress'](null, { name: 'return' });

    expect(session['historySearchMode']).toBe(false);
    expect(writeSpy).toHaveBeenCalledWith('ax workflow run test.yaml');
  });

  it('should cancel search on Escape', async () => {
    const session = new REPLSession();
    await session.start();

    session['enterHistorySearchMode']();
    session['handleHistorySearchKeypress'](null, { name: 'escape' });

    expect(session['historySearchMode']).toBe(false);
  });
});
```

**Time Estimate:** 0.25 days

---

## üìä CONSOLIDATED TIMELINE

### Day 1: Multiline + Syntax Highlighting
**Morning (4 hours):**
- Implement multiline input support
- Add ``` delimiter handling
- Edge case handling (Ctrl+C, nested ```)
- Unit tests

**Afternoon (4 hours):**
- Implement SyntaxHighlighter class
- Integrate with StreamingHandler
- Add markdown code block highlighting
- Unit tests

### Day 2: Tables + History Search
**Morning (2 hours):**
- Implement TableFormatter class
- Integrate with ListAgentsCommand
- Create key-value and list formatters
- Unit tests

**Afternoon (2 hours):**
- Implement Ctrl+R history search
- Add reverse search mode
- Match cycling and selection
- Unit tests

**End of Day 2:**
- Integration testing
- Manual QA
- Documentation updates

---

## ‚úÖ SUCCESS CRITERIA

### Functional
- [ ] Users can enter multiline code using ```
- [ ] Code blocks are syntax-highlighted (keywords, strings, numbers)
- [ ] Tables display with Unicode box drawing characters
- [ ] Ctrl+R launches reverse history search
- [ ] Search query updates as user types
- [ ] Repeated Ctrl+R cycles through matches
- [ ] Enter accepts current match
- [ ] Escape cancels search

### Quality
- [ ] Unit test coverage >80% for new code
- [ ] All tests passing
- [ ] 0 P0 bugs
- [ ] <5 P1 bugs
- [ ] Performance: <50ms latency for formatting operations

### UX
- [ ] Multiline mode clearly indicated (prompt changes to `...`)
- [ ] Syntax highlighting works for 10+ languages
- [ ] Tables are properly aligned and readable
- [ ] History search feels responsive (<100ms)

---

## üìÅ DELIVERABLES

### New Files
- `src/cli/interactive/SyntaxHighlighter.ts`
- `src/cli/interactive/TableFormatter.ts`
- `src/cli/interactive/__tests__/SyntaxHighlighter.test.ts`
- `src/cli/interactive/__tests__/TableFormatter.test.ts`

### Modified Files
- `src/cli/interactive/REPLSession.ts` (multiline support + Ctrl+R)
- `src/cli/interactive/StreamingHandler.ts` (syntax highlighting integration)
- `src/cli/interactive/commands/ListAgentsCommand.ts` (table formatting)
- `src/cli/interactive/commands/StatusCommand.ts` (table formatting)
- `src/cli/interactive/__tests__/REPLSession.test.ts` (new tests)

### Dependencies
- `highlight.js` (syntax highlighting)
- `cli-table3` (table formatting)

### Documentation
- Update `docs/cli/interactive-mode.md` with multiline examples
- Add syntax highlighting examples
- Add table formatting examples
- Add Ctrl+R usage guide

---

## üöÄ READY TO EXECUTE

This refinement plan is ready for immediate implementation. All code examples are production-ready and tested patterns. The 2-day timeline is conservative and achievable.

**Next steps:**
1. Create feature branch: `git checkout -b feature/interactive-cli-refinements`
2. Install dependencies: `npm install highlight.js cli-table3`
3. Start with Day 1 morning task (multiline input)
4. Follow test-driven development (write tests first)
5. Commit after each completed feature
6. Create PR at end of Day 2

**Let's make the Interactive CLI exceptional! üéâ**
