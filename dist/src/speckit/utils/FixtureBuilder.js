/**
 * Fixture Builder
 *
 * Week 3-4 Implementation - Day 5
 * Generates test fixtures and sample data
 */
/**
 * Fixture Builder
 *
 * Generates test data fixtures for workflows, steps, errors, and edge cases.
 */
export class FixtureBuilder {
    /**
     * Generate all fixtures for a workflow
     */
    generateFixtures(workflow, steps) {
        const fixtures = [];
        fixtures.push(this.buildWorkflowFixture(workflow));
        fixtures.push(this.buildStepsFixture(steps));
        fixtures.push(this.buildErrorFixtures());
        fixtures.push(this.buildEdgeCaseFixtures());
        return fixtures;
    }
    /**
     * Build workflow fixture
     */
    buildWorkflowFixture(workflow) {
        const content = `/**
 * Workflow Fixture
 * Generated by AutomatosX v8.0.0
 */

export const workflowFixture = ${JSON.stringify({
            name: workflow.name,
            version: workflow.version,
            description: workflow.description,
            steps: workflow.steps,
            config: workflow.config || {},
        }, null, 2)};

export const expectedWorkflowOutput = {
  success: true,
  completedSteps: ${workflow.steps.length},
  failedSteps: 0,
  duration: 0, // Will be set by actual execution
  cost: 0, // Will be calculated
  output: {},
};

export const workflowMetadata = {
  totalSteps: ${workflow.steps.length},
  estimatedDuration: ${this.estimateTotalDuration(workflow.steps)},
  estimatedCost: ${this.estimateTotalCost(workflow.steps)},
  hasRetryConfig: ${workflow.steps.some(s => s.retryConfig)},
  hasDependencies: ${workflow.steps.some(s => s.dependsOn && s.dependsOn.length > 0)},
};
`;
        return {
            path: `tests/${this.kebabCase(workflow.name)}/fixtures/workflow.fixture.ts`,
            content,
            fixtureType: 'workflow',
        };
    }
    /**
     * Build steps fixture
     */
    buildStepsFixture(steps) {
        const content = `/**
 * Steps Fixtures
 * Generated by AutomatosX v8.0.0
 */

export const stepsFixtures = ${JSON.stringify(steps.map(step => ({
            id: step.id,
            name: step.name,
            agent: step.agent,
            action: step.action,
            config: step.config,
            expectedOutput: {
                success: true,
                output: {},
                duration: step.estimatedDuration,
            },
        })), null, 2)};

export const stepConfigs = {
${steps.map(step => `  '${step.id}': ${JSON.stringify(step.config, null, 2)}`).join(',\n')}
};

export const stepExpectations = {
${steps.map(step => `  '${step.id}': {
    success: true,
    duration: ${step.estimatedDuration},
    hasSideEffects: ${step.hasSideEffects},
  }`).join(',\n')}
};
`;
        return {
            path: `tests/${this.kebabCase(steps[0]?.name || 'workflow')}/fixtures/steps.fixture.ts`,
            content,
            fixtureType: 'step',
        };
    }
    /**
     * Build error fixtures
     */
    buildErrorFixtures() {
        const content = `/**
 * Error Fixtures
 * Generated by AutomatosX v8.0.0
 */

export const errorFixtures = {
  timeout: new Error('Step execution timeout'),
  validation: new Error('Validation failed: invalid configuration'),
  dependency: new Error('Dependency not satisfied'),
  provider: new Error('Provider request failed'),
  filesystem: new Error('File not found'),
  database: new Error('Database connection failed'),
  network: new Error('Network request failed'),
};

export const expectedErrorBehaviors = {
  timeout: {
    shouldRetry: true,
    maxRetries: 3,
    backoff: 'exponential',
  },
  validation: {
    shouldRetry: false,
    failFast: true,
  },
  dependency: {
    shouldRetry: false,
    failFast: true,
  },
  provider: {
    shouldRetry: true,
    maxRetries: 3,
    backoff: 'linear',
  },
  filesystem: {
    shouldRetry: true,
    maxRetries: 2,
  },
  database: {
    shouldRetry: true,
    maxRetries: 3,
    backoff: 'exponential',
  },
  network: {
    shouldRetry: true,
    maxRetries: 5,
    backoff: 'exponential',
  },
};
`;
        return {
            path: `tests/fixtures/errors.fixture.ts`,
            content,
            fixtureType: 'error',
        };
    }
    /**
     * Build edge case fixtures
     */
    buildEdgeCaseFixtures() {
        const content = `/**
 * Edge Case Fixtures
 * Generated by AutomatosX v8.0.0
 */

export const edgeCaseFixtures = {
  emptyWorkflow: {
    name: 'Empty Workflow',
    version: '1.0.0',
    description: 'Workflow with no steps',
    steps: [],
  },
  singleStep: {
    name: 'Single Step Workflow',
    version: '1.0.0',
    description: 'Workflow with one step',
    steps: [
      {
        id: 'only-step',
        name: 'Only Step',
        agent: 'backend',
        action: 'test',
        config: {},
      },
    ],
  },
  circularDependency: {
    name: 'Circular Dependency',
    version: '1.0.0',
    description: 'Invalid workflow with circular dependencies',
    steps: [
      {
        id: 'step-1',
        name: 'Step 1',
        agent: 'backend',
        action: 'test',
        config: {},
        dependsOn: ['step-2'],
      },
      {
        id: 'step-2',
        name: 'Step 2',
        agent: 'backend',
        action: 'test',
        config: {},
        dependsOn: ['step-1'],
      },
    ],
  },
  veryLongWorkflow: {
    name: 'Very Long Workflow',
    version: '1.0.0',
    description: 'Workflow with many steps',
    steps: Array.from({ length: 100 }, (_, i) => ({
      id: \`step-\${i + 1}\`,
      name: \`Step \${i + 1}\`,
      agent: 'backend',
      action: 'test',
      config: {},
      dependsOn: i > 0 ? [\`step-\${i}\`] : [],
    })),
  },
  parallelSteps: {
    name: 'Parallel Steps',
    version: '1.0.0',
    description: 'Workflow with all parallel steps',
    steps: Array.from({ length: 10 }, (_, i) => ({
      id: \`parallel-\${i + 1}\`,
      name: \`Parallel Step \${i + 1}\`,
      agent: 'backend',
      action: 'test',
      config: {},
      dependsOn: [],
    })),
  },
};
`;
        return {
            path: `tests/fixtures/edge-cases.fixture.ts`,
            content,
            fixtureType: 'edge-case',
        };
    }
    /**
     * Estimate total duration
     */
    estimateTotalDuration(steps) {
        return steps.reduce((sum, step) => sum + (step.timeout || 5000), 0);
    }
    /**
     * Estimate total cost
     */
    estimateTotalCost(steps) {
        // Simple estimation: $0.01 per step
        return steps.length * 0.01;
    }
    /**
     * Convert string to kebab-case
     */
    kebabCase(str) {
        return str
            .replace(/([a-z])([A-Z])/g, '$1-$2')
            .replace(/[\s_]+/g, '-')
            .toLowerCase();
    }
}
//# sourceMappingURL=FixtureBuilder.js.map