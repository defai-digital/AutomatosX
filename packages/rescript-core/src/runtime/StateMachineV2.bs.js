// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";

function toString(state) {
  switch (state) {
    case "Idle" :
        return "idle";
    case "Planning" :
        return "planning";
    case "Executing" :
        return "executing";
    case "Paused" :
        return "paused";
    case "Completed" :
        return "completed";
    case "Failed" :
        return "failed";
    
  }
}

function fromString(str) {
  switch (str) {
    case "completed" :
        return "Completed";
    case "executing" :
        return "Executing";
    case "failed" :
        return "Failed";
    case "idle" :
        return "Idle";
    case "paused" :
        return "Paused";
    case "planning" :
        return "Planning";
    default:
      return ;
  }
}

var State = {
  toString: toString,
  fromString: fromString
};

function toString$1($$event) {
  if (typeof $$event === "object") {
    return "fail";
  }
  switch ($$event) {
    case "Start" :
        return "start";
    case "Plan" :
        return "plan";
    case "Execute" :
        return "execute";
    case "Pause" :
        return "pause";
    case "Resume" :
        return "resume";
    case "Complete" :
        return "complete";
    
  }
}

var $$Event = {
  toString: toString$1
};

function isValid(transition) {
  var match = transition.from;
  var match$1 = transition.event;
  var match$2 = transition.to;
  switch (match) {
    case "Idle" :
        if (typeof match$1 !== "object") {
          if (match$1 === "Start" && match$2 === "Planning") {
            return true;
          } else {
            return false;
          }
        }
        break;
    case "Planning" :
        if (typeof match$1 !== "object") {
          if (match$1 === "Plan" && match$2 === "Executing") {
            return true;
          } else {
            return false;
          }
        }
        break;
    case "Executing" :
        if (typeof match$1 !== "object") {
          switch (match$1) {
            case "Pause" :
                if (match$2 === "Paused") {
                  return true;
                } else {
                  return false;
                }
            case "Complete" :
                if (match$2 === "Completed") {
                  return true;
                } else {
                  return false;
                }
            default:
              return false;
          }
        }
        break;
    case "Paused" :
        if (typeof match$1 !== "object") {
          if (match$1 === "Resume" && match$2 === "Executing") {
            return true;
          } else {
            return false;
          }
        }
        break;
    case "Completed" :
    case "Failed" :
        break;
    
  }
  if (typeof match$1 !== "object" || match$2 !== "Failed") {
    return false;
  } else {
    return true;
  }
}

function make(from, $$event, to) {
  var transition = {
    from: from,
    event: $$event,
    to: to
  };
  if (isValid(transition)) {
    return transition;
  }
  
}

var Transition = {
  isValid: isValid,
  make: make
};

function make$1(taskId, agentName) {
  return {
          taskId: taskId,
          agentName: agentName,
          data: {},
          history: []
        };
}

function set(context, key, value) {
  var newData = Js_dict.fromArray(Js_dict.entries(context.data));
  newData[key] = value;
  return {
          taskId: context.taskId,
          agentName: context.agentName,
          data: newData,
          history: context.history
        };
}

function get(context, key) {
  return Js_dict.get(context.data, key);
}

function addToHistory(context, state) {
  return {
          taskId: context.taskId,
          agentName: context.agentName,
          data: context.data,
          history: context.history.concat([state])
        };
}

var Context = {
  make: make$1,
  set: set,
  get: get,
  addToHistory: addToHistory
};

function make$2(taskId, agentName) {
  var now = Date.now();
  return {
          currentState: "Idle",
          context: make$1(taskId, agentName),
          createdAt: now,
          updatedAt: now
        };
}

function transition(machine, $$event, targetState) {
  var transition$1 = make(machine.currentState, $$event, targetState);
  if (transition$1 !== undefined) {
    var newContext = addToHistory(machine.context, machine.currentState);
    return {
            TAG: "Ok",
            _0: {
              currentState: targetState,
              context: newContext,
              createdAt: machine.createdAt,
              updatedAt: Date.now()
            }
          };
  }
  var from = toString(machine.currentState);
  var to = toString(targetState);
  var evt = toString$1($$event);
  return {
          TAG: "Error",
          _0: "Invalid transition: " + from + " -[" + evt + "]-> " + to
        };
}

function canTransition(machine, $$event, targetState) {
  var transition = make(machine.currentState, $$event, targetState);
  return Core__Option.isSome(transition);
}

function getCurrentState(machine) {
  return machine.currentState;
}

function getContext(machine) {
  return machine.context;
}

function updateContext(machine, updater) {
  return {
          currentState: machine.currentState,
          context: updater(machine.context),
          createdAt: machine.createdAt,
          updatedAt: Date.now()
        };
}

function createCheckpoint(machine) {
  return {
          state: machine.currentState,
          context: machine.context,
          timestamp: Date.now()
        };
}

function restoreFromCheckpoint(machine, checkpoint) {
  return {
          currentState: checkpoint.state,
          context: checkpoint.context,
          createdAt: machine.createdAt,
          updatedAt: Date.now()
        };
}

var Machine = {
  make: make$2,
  transition: transition,
  canTransition: canTransition,
  getCurrentState: getCurrentState,
  getContext: getContext,
  updateContext: updateContext,
  createCheckpoint: createCheckpoint,
  restoreFromCheckpoint: restoreFromCheckpoint
};

function make$3(taskId, agentName) {
  return make$2(taskId, agentName);
}

function transition$1(machine, $$event, targetState) {
  var eventObj;
  switch ($$event) {
    case "complete" :
        eventObj = "Complete";
        break;
    case "execute" :
        eventObj = "Execute";
        break;
    case "pause" :
        eventObj = "Pause";
        break;
    case "plan" :
        eventObj = "Plan";
        break;
    case "resume" :
        eventObj = "Resume";
        break;
    case "start" :
        eventObj = "Start";
        break;
    default:
      eventObj = {
        TAG: "Fail",
        error: "Unknown event"
      };
  }
  var stateObj = fromString(targetState);
  if (stateObj !== undefined) {
    return transition(machine, eventObj, stateObj);
  } else {
    return {
            TAG: "Error",
            _0: "Invalid target state: " + targetState
          };
  }
}

function getCurrentState$1(machine) {
  return toString(machine.currentState);
}

function canTransition$1(machine, $$event, targetState) {
  var eventObj;
  switch ($$event) {
    case "complete" :
        eventObj = "Complete";
        break;
    case "execute" :
        eventObj = "Execute";
        break;
    case "pause" :
        eventObj = "Pause";
        break;
    case "plan" :
        eventObj = "Plan";
        break;
    case "resume" :
        eventObj = "Resume";
        break;
    case "start" :
        eventObj = "Start";
        break;
    default:
      eventObj = {
        TAG: "Fail",
        error: "Unknown event"
      };
  }
  var stateObj = fromString(targetState);
  if (stateObj !== undefined) {
    return canTransition(machine, eventObj, stateObj);
  } else {
    return false;
  }
}

function setContextData(machine, key, value) {
  return updateContext(machine, (function (context) {
                return set(context, key, value);
              }));
}

function getContextData(machine, key) {
  return Js_dict.get(machine.context.data, key);
}

function createCheckpoint$1(machine) {
  return createCheckpoint(machine);
}

function restoreFromCheckpoint$1(machine, checkpoint) {
  return restoreFromCheckpoint(machine, checkpoint);
}

export {
  State ,
  $$Event ,
  Transition ,
  Context ,
  Machine ,
  make$3 as make,
  transition$1 as transition,
  getCurrentState$1 as getCurrentState,
  canTransition$1 as canTransition,
  setContextData ,
  getContextData ,
  createCheckpoint$1 as createCheckpoint,
  restoreFromCheckpoint$1 as restoreFromCheckpoint,
}
/* No side effect */
