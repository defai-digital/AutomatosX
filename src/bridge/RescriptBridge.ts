/**
 * ReScript-TypeScript Bridge
 *
 * Provides TypeScript-friendly utilities for working with ReScript types
 * generated by GenType, including Result, Option, and other common patterns.
 */

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

/**
 * ReScript Result type (generated by GenType)
 */
export type Result<T, E> =
  | { TAG: 'Ok'; _0: T }
  | { TAG: 'Error'; _0: E };

/**
 * ReScript Option type representation
 */
export type Option<T> = T | undefined;

/**
 * Type guard for Result.Ok
 */
export function isOk<T, E>(result: Result<T, E>): result is { TAG: 'Ok'; _0: T } {
  return result.TAG === 'Ok';
}

/**
 * Type guard for Result.Error
 */
export function isError<T, E>(result: Result<T, E>): result is { TAG: 'Error'; _0: E } {
  return result.TAG === 'Error';
}

// ============================================================================
// RESULT UTILITIES
// ============================================================================

/**
 * Unwrap a Result, throwing if it's an Error
 */
export function unwrap<T, E>(result: Result<T, E>): T {
  if (isOk(result)) {
    return result._0;
  }
  throw new Error(`Unwrap failed: ${String(result._0)}`);
}

/**
 * Unwrap a Result with a default value
 */
export function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T {
  return isOk(result) ? result._0 : defaultValue;
}

/**
 * Get the Ok value or undefined
 */
export function getOk<T, E>(result: Result<T, E>): T | undefined {
  return isOk(result) ? result._0 : undefined;
}

/**
 * Get the Error value or undefined
 */
export function getError<T, E>(result: Result<T, E>): E | undefined {
  return isError(result) ? result._0 : undefined;
}

/**
 * Map over a Result's Ok value
 */
export function mapResult<T, U, E>(
  result: Result<T, E>,
  fn: (value: T) => U
): Result<U, E> {
  if (isOk(result)) {
    return { TAG: 'Ok', _0: fn(result._0) };
  }
  return result as Result<U, E>;
}

/**
 * Map over a Result's Error value
 */
export function mapError<T, E, F>(
  result: Result<T, E>,
  fn: (error: E) => F
): Result<T, F> {
  if (isError(result)) {
    return { TAG: 'Error', _0: fn(result._0) };
  }
  return result as Result<T, F>;
}

/**
 * Chain Result operations (flatMap)
 */
export function andThen<T, U, E>(
  result: Result<T, E>,
  fn: (value: T) => Result<U, E>
): Result<U, E> {
  if (isOk(result)) {
    return fn(result._0);
  }
  return result as Result<U, E>;
}

/**
 * Provide an alternative Result if the first is Error
 */
export function orElse<T, E, F>(
  result: Result<T, E>,
  fn: (error: E) => Result<T, F>
): Result<T, F> {
  if (isError(result)) {
    return fn(result._0);
  }
  return result as Result<T, F>;
}

/**
 * Match on a Result and return a value
 */
export function match<T, E, U>(
  result: Result<T, E>,
  handlers: {
    ok: (value: T) => U;
    error: (error: E) => U;
  }
): U {
  return isOk(result) ? handlers.ok(result._0) : handlers.error(result._0);
}

/**
 * Convert a Result to a Promise
 */
export function toPromise<T, E>(result: Result<T, E>): Promise<T> {
  if (isOk(result)) {
    return Promise.resolve(result._0);
  }
  return Promise.reject(result._0);
}

/**
 * Convert a Promise to a Result
 */
export async function fromPromise<T>(promise: Promise<T>): Promise<Result<T, Error>> {
  try {
    const value = await promise;
    return { TAG: 'Ok', _0: value };
  } catch (error) {
    return { TAG: 'Error', _0: error instanceof Error ? error : new Error(String(error)) };
  }
}

/**
 * Create an Ok Result
 */
export function ok<T, E = never>(value: T): Result<T, E> {
  return { TAG: 'Ok', _0: value };
}

/**
 * Create an Error Result
 */
export function error<T = never, E = unknown>(err: E): Result<T, E> {
  return { TAG: 'Error', _0: err };
}

// ============================================================================
// OPTION UTILITIES
// ============================================================================

/**
 * Check if an Option has a value
 */
export function isSome<T>(option: Option<T>): option is T {
  return option !== undefined;
}

/**
 * Check if an Option is None
 */
export function isNone<T>(option: Option<T>): option is undefined {
  return option === undefined;
}

/**
 * Unwrap an Option, throwing if None
 */
export function unwrapOption<T>(option: Option<T>): T {
  if (isSome(option)) {
    return option;
  }
  throw new Error('Unwrap failed: Option is None');
}

/**
 * Unwrap an Option with a default value
 */
export function unwrapOptionOr<T>(option: Option<T>, defaultValue: T): T {
  return isSome(option) ? option : defaultValue;
}

/**
 * Map over an Option's value
 */
export function mapOption<T, U>(option: Option<T>, fn: (value: T) => U): Option<U> {
  return isSome(option) ? fn(option) : undefined;
}

/**
 * Chain Option operations (flatMap)
 */
export function andThenOption<T, U>(
  option: Option<T>,
  fn: (value: T) => Option<U>
): Option<U> {
  return isSome(option) ? fn(option) : undefined;
}

/**
 * Provide an alternative Option if the first is None
 */
export function orElseOption<T>(option: Option<T>, alternative: () => Option<T>): Option<T> {
  return isSome(option) ? option : alternative();
}

/**
 * Match on an Option and return a value
 */
export function matchOption<T, U>(
  option: Option<T>,
  handlers: {
    some: (value: T) => U;
    none: () => U;
  }
): U {
  return isSome(option) ? handlers.some(option) : handlers.none();
}

/**
 * Convert an Option to a Result
 */
export function optionToResult<T, E>(option: Option<T>, error: E): Result<T, E> {
  return isSome(option) ? ok(option) : { TAG: 'Error', _0: error };
}

/**
 * Convert a Result to an Option (discards error)
 */
export function resultToOption<T, E>(result: Result<T, E>): Option<T> {
  return isOk(result) ? result._0 : undefined;
}

/**
 * Create Some Option
 */
export function some<T>(value: T): Option<T> {
  return value;
}

/**
 * Create None Option
 */
export function none<T>(): Option<T> {
  return undefined;
}

// ============================================================================
// ARRAY UTILITIES
// ============================================================================

/**
 * Collect all Ok values from an array of Results
 */
export function collectOk<T, E>(results: Array<Result<T, E>>): T[] {
  return results.filter(isOk).map(r => r._0);
}

/**
 * Collect all Error values from an array of Results
 */
export function collectErrors<T, E>(results: Array<Result<T, E>>): E[] {
  return results.filter(isError).map(r => r._0);
}

/**
 * Convert an array of Results to a Result of array
 * Returns Error if any Result is Error, Ok with array otherwise
 */
export function sequenceResults<T, E>(results: Array<Result<T, E>>): Result<T[], E> {
  const values: T[] = [];
  for (const result of results) {
    if (isError(result)) {
      return result as Result<T[], E>;
    }
    values.push(result._0);
  }
  return ok(values);
}

/**
 * Collect all Some values from an array of Options
 */
export function collectSome<T>(options: Array<Option<T>>): T[] {
  return options.filter(isSome);
}

/**
 * Find the first Ok Result in an array
 */
export function findOk<T, E>(results: Array<Result<T, E>>): Option<T> {
  const okResult = results.find(isOk);
  return okResult ? okResult._0 : undefined;
}

/**
 * Find the first Some Option in an array
 */
export function findSome<T>(options: Array<Option<T>>): Option<T> {
  return options.find(isSome);
}

// ============================================================================
// VALIDATION UTILITIES
// ============================================================================

/**
 * Validate a value with a predicate
 */
export function validate<T>(
  value: T,
  predicate: (value: T) => boolean,
  error: string
): Result<T, string> {
  return predicate(value) ? ok(value) : { TAG: 'Error', _0: error };
}

/**
 * Validate multiple conditions
 */
export function validateAll<T>(
  value: T,
  validators: Array<{ predicate: (value: T) => boolean; error: string }>
): Result<T, string[]> {
  const errors = validators
    .filter(v => !v.predicate(value))
    .map(v => v.error);

  return errors.length === 0 ? ok(value) : { TAG: 'Error', _0: errors };
}

// ============================================================================
// ASYNC UTILITIES
// ============================================================================

/**
 * Map over an async Result's Ok value
 */
export async function mapResultAsync<T, U, E>(
  resultPromise: Promise<Result<T, E>>,
  fn: (value: T) => U | Promise<U>
): Promise<Result<U, E>> {
  const result = await resultPromise;
  if (isOk(result)) {
    const mapped = await fn(result._0);
    return ok(mapped);
  }
  return result as Result<U, E>;
}

/**
 * Chain async Result operations
 */
export async function andThenAsync<T, U, E>(
  resultPromise: Promise<Result<T, E>>,
  fn: (value: T) => Promise<Result<U, E>>
): Promise<Result<U, E>> {
  const result = await resultPromise;
  if (isOk(result)) {
    return await fn(result._0);
  }
  return result as Result<U, E>;
}

/**
 * Run multiple async operations and collect Results
 */
export async function allResults<T, E>(
  promises: Array<Promise<Result<T, E>>>
): Promise<Result<T[], E>> {
  const results = await Promise.all(promises);
  return sequenceResults(results);
}

/**
 * Retry an async operation that returns a Result
 */
export async function retry<T, E>(
  fn: () => Promise<Result<T, E>>,
  options: {
    maxAttempts: number;
    delayMs?: number;
    onRetry?: (attempt: number, error: E) => void;
  }
): Promise<Result<T, E>> {
  let lastResult: Result<T, E> = { TAG: 'Error', _0: 'No attempts made' as unknown as E };

  for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {
    lastResult = await fn();

    if (isOk(lastResult)) {
      return lastResult;
    }

    if (attempt < options.maxAttempts) {
      if (options.onRetry) {
        options.onRetry(attempt, lastResult._0);
      }
      if (options.delayMs) {
        await new Promise(resolve => setTimeout(resolve, options.delayMs));
      }
    }
  }

  return lastResult;
}

// ============================================================================
// UTILITY TYPES
// ============================================================================

/**
 * Extract the Ok type from a Result
 */
export type OkType<T> = T extends Result<infer U, any> ? U : never;

/**
 * Extract the Error type from a Result
 */
export type ErrorType<T> = T extends Result<any, infer E> ? E : never;

/**
 * Extract the value type from an Option
 */
export type SomeType<T> = T extends Option<infer U> ? U : never;
