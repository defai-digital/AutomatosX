// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function toString(stepType) {
  switch (stepType) {
    case "AgentTask" :
        return "agent_task";
    case "HttpRequest" :
        return "http_request";
    case "FileOperation" :
        return "file_operation";
    case "DatabaseQuery" :
        return "database_query";
    case "SemanticSearch" :
        return "semantic_search";
    case "Transform" :
        return "transform";
    case "Conditional" :
        return "conditional";
    case "Parallel" :
        return "parallel";
    case "Sequential" :
        return "sequential";
    
  }
}

function fromString(str) {
  switch (str) {
    case "agent_task" :
        return "AgentTask";
    case "conditional" :
        return "Conditional";
    case "database_query" :
        return "DatabaseQuery";
    case "file_operation" :
        return "FileOperation";
    case "http_request" :
        return "HttpRequest";
    case "parallel" :
        return "Parallel";
    case "semantic_search" :
        return "SemanticSearch";
    case "sequential" :
        return "Sequential";
    case "transform" :
        return "Transform";
    default:
      return ;
  }
}

var StepType = {
  toString: toString,
  fromString: fromString
};

var StepConfig = {};

function make(id, name, stepType, config, dependsOn, timeout, retries, continueOnErrorOpt, param) {
  var continueOnError = continueOnErrorOpt !== undefined ? continueOnErrorOpt : false;
  return {
          id: id,
          name: name,
          stepType: stepType,
          config: config,
          dependsOn: Belt_Option.getWithDefault(dependsOn, []),
          timeout: timeout,
          retries: retries,
          continueOnError: continueOnError
        };
}

function getId(step) {
  return step.id;
}

function getName(step) {
  return step.name;
}

function getType(step) {
  return step.stepType;
}

function getDependencies(step) {
  return step.dependsOn;
}

function hasDependencies(step) {
  return step.dependsOn.length !== 0;
}

function canRetry(step) {
  var retries = step.retries;
  if (retries !== undefined) {
    return retries > 0;
  } else {
    return false;
  }
}

var StepDefinition = {
  make: make,
  getId: getId,
  getName: getName,
  getType: getType,
  getDependencies: getDependencies,
  hasDependencies: hasDependencies,
  canRetry: canRetry
};

function make$1(name, description, version, author, tags, param) {
  return {
          name: name,
          description: description,
          version: version,
          author: author,
          tags: Belt_Option.getWithDefault(tags, []),
          createdAt: Date.now(),
          updatedAt: undefined
        };
}

function getName$1(metadata) {
  return metadata.name;
}

function getVersion(metadata) {
  return metadata.version;
}

function getTags(metadata) {
  return metadata.tags;
}

function hasTag(metadata, tag) {
  return Belt_Array.some(metadata.tags, (function (t) {
                return t === tag;
              }));
}

var WorkflowMetadata = {
  make: make$1,
  getName: getName$1,
  getVersion: getVersion,
  getTags: getTags,
  hasTag: hasTag
};

function make$2(name, varType, defaultValue, requiredOpt, description, param) {
  var required = requiredOpt !== undefined ? requiredOpt : false;
  return {
          name: name,
          varType: varType,
          defaultValue: defaultValue,
          required: required,
          description: description
        };
}

function typeToString(varType) {
  switch (varType) {
    case "String" :
        return "string";
    case "Number" :
        return "number";
    case "Boolean" :
        return "boolean";
    case "Object" :
        return "object";
    case "Array" :
        return "array";
    
  }
}

function typeFromString(str) {
  switch (str) {
    case "array" :
        return "Array";
    case "boolean" :
        return "Boolean";
    case "number" :
        return "Number";
    case "object" :
        return "Object";
    case "string" :
        return "String";
    default:
      return ;
  }
}

var VariableDefinition = {
  make: make$2,
  typeToString: typeToString,
  typeFromString: typeFromString
};

function make$3(id, metadata, variables, steps, onSuccess, onFailure, onCancel, param) {
  return {
          id: id,
          metadata: metadata,
          variables: Belt_Option.getWithDefault(variables, []),
          steps: steps,
          onSuccess: onSuccess,
          onFailure: onFailure,
          onCancel: onCancel
        };
}

function getId$1(workflow) {
  return workflow.id;
}

function getName$2(workflow) {
  return workflow.metadata.name;
}

function getSteps(workflow) {
  return workflow.steps;
}

function getStepById(workflow, stepId) {
  return Belt_Array.getBy(workflow.steps, (function (step) {
                return step.id === stepId;
              }));
}

function getVariables(workflow) {
  return workflow.variables;
}

function getRequiredVariables(workflow) {
  return Belt_Array.keep(workflow.variables, (function (v) {
                return v.required;
              }));
}

function hasStep(workflow, stepId) {
  return Belt_Array.some(workflow.steps, (function (step) {
                return step.id === stepId;
              }));
}

function getStepCount(workflow) {
  return workflow.steps.length;
}

var WorkflowDefinition = {
  make: make$3,
  getId: getId$1,
  getName: getName$2,
  getSteps: getSteps,
  getStepById: getStepById,
  getVariables: getVariables,
  getRequiredVariables: getRequiredVariables,
  hasStep: hasStep,
  getStepCount: getStepCount
};

function makeNode(stepId, dependencies, level) {
  return {
          stepId: stepId,
          dependencies: dependencies,
          dependents: [],
          level: level
        };
}

function make$4(steps) {
  var nodes = Belt_Array.map(steps, (function (step) {
          return makeNode(step.id, step.dependsOn, 0);
        }));
  var calculateLevels = function (_nodes, _maxIterations) {
    while(true) {
      var maxIterations = _maxIterations;
      var nodes = _nodes;
      if (maxIterations <= 0) {
        return nodes;
      }
      var updated = Belt_Array.map(nodes, (function(nodes){
          return function (node) {
            if (node.dependencies.length === 0) {
              return {
                      stepId: node.stepId,
                      dependencies: node.dependencies,
                      dependents: node.dependents,
                      level: 0
                    };
            }
            var maxDepLevel = Belt_Array.reduce(node.dependencies, 0, (function (acc, depId) {
                    var depNode = Belt_Array.getBy(nodes, (function (n) {
                            return n.stepId === depId;
                          }));
                    if (depNode !== undefined && acc <= depNode.level) {
                      return depNode.level;
                    } else {
                      return acc;
                    }
                  }));
            return {
                    stepId: node.stepId,
                    dependencies: node.dependencies,
                    dependents: node.dependents,
                    level: maxDepLevel + 1 | 0
                  };
          }
          }(nodes)));
      var changed = Belt_Array.some(Belt_Array.zip(nodes, updated), (function (param) {
              return param[0].level !== param[1].level;
            }));
      if (!changed) {
        return updated;
      }
      _maxIterations = maxIterations - 1 | 0;
      _nodes = updated;
      continue ;
    };
  };
  var leveledNodes = calculateLevels(nodes, 100);
  var maxLevel = Belt_Array.reduce(leveledNodes, 0, (function (acc, node) {
          if (acc > node.level) {
            return acc;
          } else {
            return node.level;
          }
        }));
  var levels = Belt_Array.makeBy(maxLevel + 1 | 0, (function (level) {
          return Belt_Array.keepMap(leveledNodes, (function (node) {
                        if (node.level === level) {
                          return node.stepId;
                        }
                        
                      }));
        }));
  return {
          nodes: leveledNodes,
          levels: levels
        };
}

function getNode(graph, stepId) {
  return Belt_Array.getBy(graph.nodes, (function (n) {
                return n.stepId === stepId;
              }));
}

function getLevel(graph, stepId) {
  var node = getNode(graph, stepId);
  if (node !== undefined) {
    return node.level;
  }
  
}

function getLevelSteps(graph, level) {
  var steps = Belt_Array.get(graph.levels, level);
  if (steps !== undefined) {
    return steps;
  } else {
    return [];
  }
}

function getMaxLevel(graph) {
  return graph.levels.length - 1 | 0;
}

function hasCycle(graph) {
  return Belt_Array.some(graph.nodes, (function (node) {
                return Belt_Array.some(node.dependencies, (function (depId) {
                              return Belt_Array.some(node.dependents, (function (dependentId) {
                                            return depId === dependentId;
                                          }));
                            }));
              }));
}

function getExecutionOrder(graph) {
  return graph.levels;
}

function canExecuteInParallel(graph, stepIds) {
  var firstId = Belt_Array.get(stepIds, 0);
  if (firstId === undefined) {
    return false;
  }
  var level = getLevel(graph, firstId);
  if (level !== undefined) {
    return Belt_Array.every(stepIds, (function (stepId) {
                  var l = getLevel(graph, stepId);
                  if (l !== undefined) {
                    return l === level;
                  } else {
                    return false;
                  }
                }));
  } else {
    return false;
  }
}

var DependencyGraph = {
  makeNode: makeNode,
  make: make$4,
  getNode: getNode,
  getLevel: getLevel,
  getLevelSteps: getLevelSteps,
  getMaxLevel: getMaxLevel,
  hasCycle: hasCycle,
  getExecutionOrder: getExecutionOrder,
  canExecuteInParallel: canExecuteInParallel
};

function make$5(stepId, startedAt) {
  return {
          stepId: stepId,
          status: "Success",
          output: undefined,
          error: undefined,
          startedAt: startedAt,
          completedAt: undefined,
          duration: undefined,
          retryCount: 0
        };
}

function success(result, output) {
  var now = Date.now();
  return {
          stepId: result.stepId,
          status: "Success",
          output: output,
          error: result.error,
          startedAt: result.startedAt,
          completedAt: now,
          duration: now - result.startedAt,
          retryCount: result.retryCount
        };
}

function failure(result, error) {
  var now = Date.now();
  return {
          stepId: result.stepId,
          status: "Failure",
          output: result.output,
          error: error,
          startedAt: result.startedAt,
          completedAt: now,
          duration: now - result.startedAt,
          retryCount: result.retryCount
        };
}

function skip(result) {
  var now = Date.now();
  return {
          stepId: result.stepId,
          status: "Skipped",
          output: result.output,
          error: result.error,
          startedAt: result.startedAt,
          completedAt: now,
          duration: now - result.startedAt,
          retryCount: result.retryCount
        };
}

function cancel(result) {
  var now = Date.now();
  return {
          stepId: result.stepId,
          status: "Cancelled",
          output: result.output,
          error: result.error,
          startedAt: result.startedAt,
          completedAt: now,
          duration: now - result.startedAt,
          retryCount: result.retryCount
        };
}

function incrementRetry(result) {
  return {
          stepId: result.stepId,
          status: result.status,
          output: result.output,
          error: result.error,
          startedAt: result.startedAt,
          completedAt: result.completedAt,
          duration: result.duration,
          retryCount: result.retryCount + 1 | 0
        };
}

function statusToString(status) {
  switch (status) {
    case "Success" :
        return "success";
    case "Failure" :
        return "failure";
    case "Skipped" :
        return "skipped";
    case "Cancelled" :
        return "cancelled";
    
  }
}

function statusFromString(str) {
  switch (str) {
    case "cancelled" :
        return "Cancelled";
    case "failure" :
        return "Failure";
    case "skipped" :
        return "Skipped";
    case "success" :
        return "Success";
    default:
      return ;
  }
}

function isComplete(result) {
  return Belt_Option.isSome(result.completedAt);
}

function isSuccess(result) {
  return result.status === "Success";
}

function isFailure(result) {
  return result.status === "Failure";
}

var ExecutionResult = {
  make: make$5,
  success: success,
  failure: failure,
  skip: skip,
  cancel: cancel,
  incrementRetry: incrementRetry,
  statusToString: statusToString,
  statusFromString: statusFromString,
  isComplete: isComplete,
  isSuccess: isSuccess,
  isFailure: isFailure
};

var makeStepDefinition = make;

var makeWorkflowMetadata = make$1;

var makeWorkflowDefinition = make$3;

var makeDependencyGraph = make$4;

var makeExecutionResult = make$5;

export {
  StepType ,
  StepConfig ,
  StepDefinition ,
  WorkflowMetadata ,
  VariableDefinition ,
  WorkflowDefinition ,
  DependencyGraph ,
  ExecutionResult ,
  makeStepDefinition ,
  makeWorkflowMetadata ,
  makeWorkflowDefinition ,
  makeDependencyGraph ,
  makeExecutionResult ,
}
/* No side effect */
