// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function createDependency(name, version, checksum, param) {
  return {
          name: name,
          version: version,
          checksum: checksum
        };
}

function createConfigBundle(bundleId, version, dependencies, signature, param) {
  return {
          bundleId: bundleId,
          version: version,
          dependencies: dependencies,
          signature: signature
        };
}

function verifyChecksum(dependency, actualChecksum, checksumVerifier) {
  var expectedChecksum = dependency.checksum;
  if (expectedChecksum === undefined) {
    return "MissingChecksum";
  }
  if (expectedChecksum.length === 0) {
    return {
            TAG: "InvalidChecksumFormat",
            _0: "checksum cannot be empty"
          };
  }
  if (expectedChecksum.length !== 64) {
    return {
            TAG: "InvalidChecksumFormat",
            _0: "checksum must be 64-character SHA-256 hash"
          };
  }
  var isValid = checksumVerifier(actualChecksum, expectedChecksum);
  if (isValid) {
    return "ChecksumValid";
  } else {
    return {
            TAG: "ChecksumMismatch",
            _0: "Expected: " + expectedChecksum + ", Actual: " + actualChecksum
          };
  }
}

function bundleToCanonicalString(bundle) {
  var depsStr = Belt_Array.joinWith(Belt_Array.map(bundle.dependencies, (function (dep) {
              var cs = dep.checksum;
              var checksumStr = cs !== undefined ? cs : "none";
              return dep.name + "@" + dep.version + ":" + checksumStr;
            })), ";", (function (x) {
          return x;
        }));
  return bundle.bundleId + ":" + bundle.version + ":" + depsStr;
}

function verifyBundleSignature(bundle, secretKey, signatureVerifier) {
  var sig = bundle.signature;
  if (sig === undefined) {
    return "MissingBundleSignature";
  }
  if (sig.length === 0) {
    return {
            TAG: "BundleInvalid",
            _0: "signature cannot be empty"
          };
  }
  var canonical = bundleToCanonicalString(bundle);
  var isValid = signatureVerifier(canonical, secretKey, sig);
  if (isValid) {
    return "BundleValid";
  } else {
    return "BundleSignatureMismatch";
  }
}

function validateBundleDependencies(bundle, getActualChecksum, checksumVerifier) {
  var invalidDeps = Belt_Array.keepMap(bundle.dependencies, (function (dep) {
          var actualChecksum = getActualChecksum(dep.name);
          var checksumResult = verifyChecksum(dep, actualChecksum, checksumVerifier);
          if (typeof checksumResult !== "object") {
            if (checksumResult === "ChecksumValid") {
              return ;
            } else {
              return dep.name + ": missing checksum";
            }
          } else if (checksumResult.TAG === "ChecksumMismatch") {
            return dep.name + ": " + checksumResult._0;
          } else {
            return dep.name + ": " + checksumResult._0;
          }
        }));
  if (invalidDeps.length === 0) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  var errorMsg = Belt_Array.joinWith(invalidDeps, ", ", (function (x) {
          return x;
        }));
  return {
          TAG: "Error",
          _0: "Invalid dependencies: " + errorMsg
        };
}

function validateConfigBundle(bundle, secretKey, getActualChecksum, checksumVerifier, signatureVerifier) {
  var reason = verifyBundleSignature(bundle, secretKey, signatureVerifier);
  if (typeof reason === "object") {
    return {
            TAG: "Error",
            _0: "Bundle invalid: " + reason._0
          };
  }
  switch (reason) {
    case "BundleValid" :
        var msg = validateBundleDependencies(bundle, getActualChecksum, checksumVerifier);
        if (msg.TAG === "Ok") {
          return {
                  TAG: "Ok",
                  _0: bundle
                };
        } else {
          return {
                  TAG: "Error",
                  _0: "Dependency validation failed: " + msg._0
                };
        }
    case "BundleSignatureMismatch" :
        return {
                TAG: "Error",
                _0: "Bundle signature mismatch"
              };
    case "MissingBundleSignature" :
        return {
                TAG: "Error",
                _0: "Bundle signature missing"
              };
    
  }
}

function checksumResultToString(result) {
  if (typeof result !== "object") {
    if (result === "ChecksumValid") {
      return "ChecksumValid";
    } else {
      return "MissingChecksum";
    }
  } else if (result.TAG === "ChecksumMismatch") {
    return "ChecksumMismatch(" + result._0 + ")";
  } else {
    return "InvalidChecksumFormat(" + result._0 + ")";
  }
}

function bundleResultToString(result) {
  if (typeof result === "object") {
    return "BundleInvalid(" + result._0 + ")";
  }
  switch (result) {
    case "BundleValid" :
        return "BundleValid";
    case "BundleSignatureMismatch" :
        return "BundleSignatureMismatch";
    case "MissingBundleSignature" :
        return "MissingBundleSignature";
    
  }
}

function isChecksumValid(result) {
  if (typeof result !== "object" && result === "ChecksumValid") {
    return true;
  } else {
    return false;
  }
}

function isBundleValid(result) {
  if (typeof result !== "object" && result === "BundleValid") {
    return true;
  } else {
    return false;
  }
}

export {
  createDependency ,
  createConfigBundle ,
  verifyChecksum ,
  bundleToCanonicalString ,
  verifyBundleSignature ,
  validateBundleDependencies ,
  validateConfigBundle ,
  checksumResultToString ,
  bundleResultToString ,
  isChecksumValid ,
  isBundleValid ,
}
/* No side effect */
