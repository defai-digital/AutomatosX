# AutomatosX v8.0.0 - Spec-Kit Auto-Generation PRD

**Version:** 8.0.0
**Status:** Ready for Implementation
**Priority:** P0 (Critical Gap)
**Timeline:** 2 weeks (Week 3-4 of 6-week roadmap)
**Effort:** 10 person-days

---

## Executive Summary

Spec-Kit Auto-Generation transforms natural language descriptions into production-ready workflows, execution plans, dependency graphs, project scaffolds, and test suites. This feature eliminates the manual YAML authoring barrier and enables anyone to create complex workflows through conversational specification.

**Impact:**
- **Productivity:** 10x faster workflow creation (5 minutes vs 50 minutes)
- **Accessibility:** Non-technical users can create workflows
- **Quality:** AI-generated workflows follow best practices
- **Iteration Speed:** Rapid refinement through natural language edits

**Success Criteria:**
- `ax spec create "description"` generates valid YAML workflow
- `ax gen plan` produces execution plan with cost/time estimates
- `ax gen dag` visualizes dependencies as ASCII/DOT graph
- `ax gen scaffold` creates project structure from workflow
- `ax gen tests` generates comprehensive test suite
- >90% generated workflows execute successfully

---

## Problem Statement

### Current State (v8.0.0)

Manual YAML authoring required:
```yaml
# workflows/security-audit.yaml (200 lines, 30 minutes to write)
name: "Security Audit"
version: "1.0.0"
description: "Comprehensive security analysis"

steps:
  - id: "scan-dependencies"
    name: "Scan Dependencies"
    agent: "security"
    action: "scan-dependencies"
    config:
      severity: ["high", "critical"]
    dependsOn: []

  - id: "analyze-code"
    name: "Analyze Code"
    agent: "security"
    action: "static-analysis"
    dependsOn: ["scan-dependencies"]

  # ... 15 more steps
```

**Barriers:**
- Must learn YAML workflow schema
- Manual dependency management (error-prone)
- No cost/time estimation before execution
- No project scaffolding automation
- No automated test generation

### Target State (v7.6.1 Parity)

Natural language workflow generation:
```bash
# 1. Generate workflow from description
$ ax spec create "Run a comprehensive security audit: scan dependencies for CVEs, analyze code for vulnerabilities, check for secrets in code, audit Docker configs, and generate a report. Fail if any critical issues found."

âœ… Generated: workflows/security-audit-20250111.yaml (18 steps)

# 2. Generate execution plan
$ ax gen plan workflows/security-audit-20250111.yaml

ğŸ“Š Execution Plan
â”œâ”€ Phase 1: Setup (2 steps, 30s, $0.02)
â”œâ”€ Phase 2: Scanning (6 steps, 5m, $0.15)
â”œâ”€ Phase 3: Analysis (8 steps, 10m, $0.30)
â””â”€ Phase 4: Reporting (2 steps, 1m, $0.05)

Total: 18 steps, ~16 minutes, ~$0.52

# 3. Generate dependency graph
$ ax gen dag workflows/security-audit-20250111.yaml

ğŸ“ˆ Dependency Graph (DOT format):
digraph workflow {
  "scan-deps" -> "analyze-code";
  "scan-deps" -> "check-secrets";
  "analyze-code" -> "generate-report";
  "check-secrets" -> "generate-report";
}

# 4. Generate project scaffold
$ ax gen scaffold workflows/security-audit-20250111.yaml --output ./audit-project

âœ… Created project structure:
./audit-project/
â”œâ”€â”€ workflows/security-audit.yaml
â”œâ”€â”€ configs/audit.config.json
â”œâ”€â”€ scripts/run-audit.sh
â”œâ”€â”€ docs/README.md
â””â”€â”€ tests/audit.test.ts

# 5. Generate test suite
$ ax gen tests workflows/security-audit-20250111.yaml

âœ… Generated: tests/workflows/security-audit.test.ts (50 tests)
```

---

## Architecture

### System Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Spec-Kit Layer                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚    Spec      â”‚    â”‚     Plan     â”‚    â”‚     DAG      â”‚  â”‚
â”‚  â”‚  Generator   â”‚â”€â”€â”€â–¶â”‚  Generator   â”‚â”€â”€â”€â–¶â”‚  Generator   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                    â”‚                    â”‚          â”‚
â”‚         â–¼                    â–¼                    â–¼          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Scaffold   â”‚    â”‚     Test     â”‚    â”‚   Template   â”‚  â”‚
â”‚  â”‚  Generator   â”‚    â”‚  Generator   â”‚    â”‚   Registry   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                    â”‚                    â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                    â”‚                    â”‚
          â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Existing v8.0.0 Infrastructure                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  WorkflowParser    â”‚  WorkflowEngineV2  â”‚  AgentRegistry   â”‚
â”‚  ProviderRouterV2  â”‚  FileSystem        â”‚  TemplateEngine  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Core Components

#### 1. SpecGenerator (`src/services/SpecGenerator.ts`)

**Responsibilities:**
- Convert natural language description to YAML workflow
- Infer appropriate agents and actions
- Generate dependency chains
- Add error handling and retry logic
- Validate generated YAML against schema

**Key Methods:**
```typescript
export class SpecGenerator {
  constructor(
    private providerRouter: ProviderRouterV2,
    private agentRegistry: AgentRegistry,
    private workflowParser: WorkflowParser
  ) {}

  async generateSpec(description: string, options?: SpecOptions): Promise<GeneratedSpec>;
  private buildPrompt(description: string, options: SpecOptions): string;
  private parseYAML(response: string): WorkflowDefinition;
  private validateSpec(spec: WorkflowDefinition): ValidationResult;
  private inferDependencies(steps: Step[]): Step[];
  private optimizeStepOrder(steps: Step[]): Step[];
}

export interface SpecOptions {
  outputPath?: string;
  projectName?: string;
  includeExamples?: boolean;
  verbosity?: 'minimal' | 'normal' | 'detailed';
  agents?: string[]; // Restrict to specific agents
  maxSteps?: number;
  includeTests?: boolean;
}

export interface GeneratedSpec {
  yaml: string;
  definition: WorkflowDefinition;
  outputPath: string;
  metadata: {
    generatedAt: Date;
    description: string;
    stepsCount: number;
    estimatedDuration: number;
    estimatedCost: number;
  };
}
```

**Prompt Engineering:**
```typescript
private buildPrompt(description: string, options: SpecOptions): string {
  const availableAgents = this.agentRegistry.list()
    .map(a => `- ${a.name}: ${a.description}`)
    .join('\n');

  return `You are a workflow architect for AutomatosX v8.0.0.

Generate a YAML workflow definition for:
"""
${description}
"""

Available Agents:
${availableAgents}

Output valid YAML adhering to this schema:

\`\`\`yaml
name: "Workflow Name"
version: "1.0.0"
description: "Description"

steps:
  - id: "step-1"
    name: "Step Name"
    agent: "agent-name"
    action: "action-name"
    config:
      key: value
    dependsOn: []
    retryConfig:
      maxRetries: 3
      backoffMs: 1000
    timeout: 300000
    continueOnError: false
\`\`\`

Requirements:
1. Use appropriate agents for each task
2. Define clear dependencies with dependsOn
3. Include error handling (retryConfig, continueOnError)
4. Add reasonable timeouts
5. Output ONLY valid YAML (no markdown, no comments)

Generate the workflow now:`;
}
```

#### 2. PlanGenerator (`src/services/PlanGenerator.ts`)

**Responsibilities:**
- Analyze workflow definition for execution plan
- Calculate time estimates per step
- Calculate cost estimates (provider API costs)
- Group steps into phases based on dependencies
- Identify parallelization opportunities
- Generate human-readable plan output

**Implementation:**
```typescript
export interface ExecutionPlan {
  phases: ExecutionPhase[];
  totalSteps: number;
  totalDuration: number; // milliseconds
  totalCost: number; // USD
  parallelizationRatio: number; // 0.0-1.0
  criticalPath: string[]; // Step IDs on critical path
}

export interface ExecutionPhase {
  phaseNumber: number;
  name: string;
  steps: PlanStep[];
  duration: number;
  cost: number;
  canParallelize: boolean;
}

export interface PlanStep {
  id: string;
  name: string;
  agent: string;
  estimatedDuration: number;
  estimatedCost: number;
  dependencies: string[];
  risks: string[];
}

export class PlanGenerator {
  constructor(
    private workflowParser: WorkflowParser,
    private costEstimator: CostEstimator
  ) {}

  async generatePlan(workflowPath: string): Promise<ExecutionPlan> {
    const definition = await this.workflowParser.parseFile(workflowPath);
    const graph = this.buildDependencyGraph(definition.steps);
    const phases = this.groupByPhases(graph);

    return {
      phases: phases.map(p => this.enrichPhase(p)),
      totalSteps: definition.steps.length,
      totalDuration: this.calculateTotalDuration(phases),
      totalCost: this.calculateTotalCost(phases),
      parallelizationRatio: this.calculateParallelization(phases),
      criticalPath: this.findCriticalPath(graph)
    };
  }

  private buildDependencyGraph(steps: Step[]): DependencyGraph {
    const graph = new Map<string, string[]>();
    for (const step of steps) {
      graph.set(step.id, step.dependsOn || []);
    }
    return graph;
  }

  private groupByPhases(graph: DependencyGraph): ExecutionPhase[] {
    const phases: ExecutionPhase[] = [];
    const levels = this.topologicalSort(graph);

    levels.forEach((stepIds, index) => {
      phases.push({
        phaseNumber: index + 1,
        name: `Phase ${index + 1}`,
        steps: stepIds.map(id => this.createPlanStep(id)),
        duration: 0,
        cost: 0,
        canParallelize: stepIds.length > 1
      });
    });

    return phases;
  }

  private estimateStepDuration(step: Step): number {
    // Heuristics based on agent and action type
    const baseTime = 5000; // 5s baseline
    const agentMultipliers = {
      'security': 3.0,
      'quality': 2.5,
      'testing': 2.0,
      'backend': 1.5,
      'frontend': 1.5,
      'default': 1.0
    };

    const multiplier = agentMultipliers[step.agent] || agentMultipliers.default;
    return baseTime * multiplier;
  }

  private estimateStepCost(step: Step): number {
    // Cost estimation based on provider API pricing
    return this.costEstimator.estimate({
      agent: step.agent,
      action: step.action,
      inputTokens: 1000, // Average
      outputTokens: 500  // Average
    });
  }
}
```

**CLI Output Formatting:**
```typescript
// src/cli/commands/gen.ts - plan subcommand
function displayPlan(plan: ExecutionPlan): void {
  console.log(chalk.bold('\nğŸ“Š Execution Plan\n'));

  plan.phases.forEach(phase => {
    const icon = phase.canParallelize ? 'âš¡' : 'â†’';
    const duration = formatDuration(phase.duration);
    const cost = `$${phase.cost.toFixed(2)}`;

    console.log(chalk.cyan(`${icon} Phase ${phase.phaseNumber}: ${phase.name}`));
    console.log(`   ${chalk.gray(`${phase.steps.length} steps, ${duration}, ${cost}`)}`);

    phase.steps.forEach(step => {
      console.log(`   - ${step.name} (${step.agent})`);
    });
    console.log();
  });

  console.log(chalk.bold('Total:'));
  console.log(`  Steps: ${plan.totalSteps}`);
  console.log(`  Duration: ~${formatDuration(plan.totalDuration)}`);
  console.log(`  Cost: ~$${plan.totalCost.toFixed(2)}`);
  console.log(`  Parallelization: ${(plan.parallelizationRatio * 100).toFixed(0)}%`);
  console.log(`  Critical Path: ${plan.criticalPath.join(' â†’ ')}`);
}
```

#### 3. DAGGenerator (`src/services/DAGGenerator.ts`)

**Responsibilities:**
- Generate visual dependency graphs
- Support ASCII art output (terminal)
- Support DOT format (Graphviz)
- Support Mermaid format (markdown)
- Highlight critical path
- Identify cycles and issues

**Implementation:**
```typescript
export type GraphFormat = 'ascii' | 'dot' | 'mermaid' | 'json';

export interface DAGOptions {
  format: GraphFormat;
  highlightCriticalPath?: boolean;
  includeMetadata?: boolean;
  outputPath?: string;
}

export class DAGGenerator {
  constructor(private workflowParser: WorkflowParser) {}

  async generateDAG(workflowPath: string, options: DAGOptions): Promise<string> {
    const definition = await this.workflowParser.parseFile(workflowPath);
    const graph = this.buildGraph(definition.steps);

    switch (options.format) {
      case 'ascii':
        return this.generateASCII(graph, options);
      case 'dot':
        return this.generateDOT(graph, options);
      case 'mermaid':
        return this.generateMermaid(graph, options);
      case 'json':
        return JSON.stringify(graph, null, 2);
    }
  }

  private generateDOT(graph: Graph, options: DAGOptions): string {
    const lines: string[] = ['digraph workflow {'];
    lines.push('  rankdir=TB;');
    lines.push('  node [shape=box, style=rounded];');
    lines.push('');

    // Nodes
    for (const node of graph.nodes) {
      const label = `${node.name}\\n(${node.agent})`;
      const color = options.highlightCriticalPath && node.onCriticalPath
        ? 'fillcolor=yellow, style="rounded,filled"'
        : '';
      lines.push(`  "${node.id}" [label="${label}", ${color}];`);
    }

    lines.push('');

    // Edges
    for (const edge of graph.edges) {
      const style = edge.onCriticalPath ? ', color=red, penwidth=2' : '';
      lines.push(`  "${edge.from}" -> "${edge.to}"${style};`);
    }

    lines.push('}');
    return lines.join('\n');
  }

  private generateASCII(graph: Graph, options: DAGOptions): string {
    // Simple ASCII tree representation
    const lines: string[] = ['Dependency Graph:'];
    const roots = graph.nodes.filter(n => n.dependencies.length === 0);

    const visited = new Set<string>();
    const renderNode = (node: Node, depth: number) => {
      const indent = '  '.repeat(depth);
      const marker = node.onCriticalPath ? 'âš¡' : 'â”œâ”€';
      lines.push(`${indent}${marker} ${node.name} (${node.agent})`);
      visited.add(node.id);

      const children = graph.nodes.filter(n =>
        n.dependencies.includes(node.id) && !visited.has(n.id)
      );

      children.forEach(child => renderNode(child, depth + 1));
    };

    roots.forEach(root => renderNode(root, 0));
    return lines.join('\n');
  }

  private generateMermaid(graph: Graph, options: DAGOptions): string {
    const lines: string[] = ['```mermaid', 'graph TD'];

    // Nodes
    for (const node of graph.nodes) {
      const style = node.onCriticalPath ? ':::critical' : '';
      lines.push(`  ${node.id}["${node.name}<br/>(${node.agent})"]${style}`);
    }

    // Edges
    for (const edge of graph.edges) {
      lines.push(`  ${edge.from} --> ${edge.to}`);
    }

    lines.push('  classDef critical fill:#ff9999,stroke:#ff0000');
    lines.push('```');
    return lines.join('\n');
  }
}
```

#### 4. ScaffoldGenerator (`src/services/ScaffoldGenerator.ts`)

**Responsibilities:**
- Generate project structure from workflow
- Create config files, scripts, documentation
- Set up testing infrastructure
- Configure CI/CD templates
- Initialize version control

**Implementation:**
```typescript
export interface ScaffoldOptions {
  outputPath: string;
  includeTests?: boolean;
  includeCI?: boolean;
  includeDocs?: boolean;
  templateName?: string;
}

export class ScaffoldGenerator {
  constructor(
    private templateRegistry: TemplateRegistry,
    private fileSystem: FileSystemService
  ) {}

  async generateScaffold(
    workflowPath: string,
    options: ScaffoldOptions
  ): Promise<ScaffoldResult> {
    const definition = await this.workflowParser.parseFile(workflowPath);
    const structure = this.buildStructure(definition, options);

    await this.createDirectories(structure.directories, options.outputPath);
    await this.createFiles(structure.files, options.outputPath);

    return {
      createdFiles: structure.files.length,
      createdDirectories: structure.directories.length,
      outputPath: options.outputPath
    };
  }

  private buildStructure(
    definition: WorkflowDefinition,
    options: ScaffoldOptions
  ): ProjectStructure {
    const directories = [
      'workflows',
      'configs',
      'scripts',
      'docs'
    ];

    const files: FileTemplate[] = [
      {
        path: 'workflows/main.yaml',
        content: this.generateWorkflowFile(definition)
      },
      {
        path: 'configs/default.config.json',
        content: this.generateConfigFile(definition)
      },
      {
        path: 'scripts/run.sh',
        content: this.generateRunScript(definition),
        executable: true
      },
      {
        path: 'docs/README.md',
        content: this.generateReadme(definition)
      }
    ];

    if (options.includeTests) {
      directories.push('tests');
      files.push({
        path: 'tests/workflow.test.ts',
        content: this.generateTestFile(definition)
      });
    }

    if (options.includeCI) {
      directories.push('.github/workflows');
      files.push({
        path: '.github/workflows/ci.yaml',
        content: this.generateCIConfig(definition)
      });
    }

    return { directories, files };
  }

  private generateRunScript(definition: WorkflowDefinition): string {
    return `#!/bin/bash
# Generated by AutomatosX v8.0.0
# Workflow: ${definition.name}

set -e

echo "ğŸš€ Running workflow: ${definition.name}"
ax workflow run workflows/main.yaml --config configs/default.config.json

echo "âœ… Workflow completed successfully"
`;
  }

  private generateReadme(definition: WorkflowDefinition): string {
    return `# ${definition.name}

${definition.description}

## Setup

\`\`\`bash
npm install -g automatosx
\`\`\`

## Usage

\`\`\`bash
./scripts/run.sh
\`\`\`

## Workflow Steps

${definition.steps.map((s, i) => `${i + 1}. **${s.name}** (${s.agent})`).join('\n')}

## Generated by AutomatosX v8.0.0

Date: ${new Date().toISOString()}
`;
  }
}
```

#### 5. TestGenerator (`src/services/TestGenerator.ts`)

**Responsibilities:**
- Generate comprehensive test suite for workflow
- Create unit tests for each step
- Create integration tests for phase execution
- Create end-to-end tests for full workflow
- Mock external dependencies
- Generate test fixtures

**Implementation:**
```typescript
export interface TestOptions {
  outputPath: string;
  framework?: 'vitest' | 'jest' | 'mocha';
  coverage?: boolean;
  includeE2E?: boolean;
}

export class TestGenerator {
  async generateTests(
    workflowPath: string,
    options: TestOptions
  ): Promise<GeneratedTests> {
    const definition = await this.workflowParser.parseFile(workflowPath);

    const tests: TestFile[] = [
      this.generateUnitTests(definition, options),
      this.generateIntegrationTests(definition, options)
    ];

    if (options.includeE2E) {
      tests.push(this.generateE2ETests(definition, options));
    }

    return {
      files: tests,
      totalTests: tests.reduce((sum, t) => sum + t.testCount, 0)
    };
  }

  private generateUnitTests(
    definition: WorkflowDefinition,
    options: TestOptions
  ): TestFile {
    const imports = `import { describe, it, expect, vi } from 'vitest';
import { WorkflowEngineV2 } from 'automatosx';`;

    const tests = definition.steps.map(step => `
  describe('${step.name}', () => {
    it('should execute successfully', async () => {
      const engine = new WorkflowEngineV2(/* deps */);
      const result = await engine.executeStep('${step.id}', {});
      expect(result.success).toBe(true);
    });

    it('should handle errors gracefully', async () => {
      const engine = new WorkflowEngineV2(/* deps */);
      // Mock failure condition
      const result = await engine.executeStep('${step.id}', {});
      expect(result.error).toBeDefined();
    });

    it('should respect timeout', async () => {
      const engine = new WorkflowEngineV2(/* deps */);
      await expect(
        engine.executeStep('${step.id}', { timeout: 100 })
      ).rejects.toThrow('timeout');
    });
  });`).join('\n');

    return {
      path: `${options.outputPath}/unit.test.ts`,
      content: `${imports}\n\ndescribe('${definition.name} - Unit Tests', () => {${tests}\n});`,
      testCount: definition.steps.length * 3
    };
  }

  private generateE2ETests(
    definition: WorkflowDefinition,
    options: TestOptions
  ): TestFile {
    return {
      path: `${options.outputPath}/e2e.test.ts`,
      content: `import { describe, it, expect } from 'vitest';
import { WorkflowEngineV2 } from 'automatosx';

describe('${definition.name} - E2E Tests', () => {
  it('should execute full workflow successfully', async () => {
    const engine = new WorkflowEngineV2(/* deps */);
    const result = await engine.executeWorkflow('${definition.name}');

    expect(result.success).toBe(true);
    expect(result.completedSteps).toBe(${definition.steps.length});
  });

  it('should create checkpoints at each phase', async () => {
    const engine = new WorkflowEngineV2(/* deps */);
    const result = await engine.executeWorkflow('${definition.name}');

    expect(result.checkpoints.length).toBeGreaterThan(0);
  });

  it('should resume from checkpoint on failure', async () => {
    const engine = new WorkflowEngineV2(/* deps */);
    // Mock failure at step 5
    const result = await engine.resumeWorkflow(checkpointId);

    expect(result.resumedFromStep).toBe('${definition.steps[4]?.id}');
  });
});`,
      testCount: 3
    };
  }
}
```

---

## CLI Commands

### 1. `ax spec create <description>`

Generate workflow YAML from natural language description.

**Usage:**
```bash
ax spec create "Run security audit with dependency scanning and code analysis"
ax spec create --file description.txt --output workflows/custom.yaml
ax spec create "CI/CD pipeline" --agents backend,devops,testing
```

**Options:**
- `-o, --output <path>` - Output file path (default: `workflows/<name>-<timestamp>.yaml`)
- `-a, --agents <list>` - Restrict to specific agents (comma-separated)
- `--max-steps <n>` - Maximum number of steps (default: 50)
- `--include-tests` - Generate test file alongside workflow
- `-v, --verbose` - Detailed output

### 2. `ax gen plan <workflow>`

Generate execution plan with time and cost estimates.

**Usage:**
```bash
ax gen plan workflows/security-audit.yaml
ax gen plan workflows/ci-cd.yaml --format json
ax gen plan workflows/test.yaml --output plan.txt
```

**Options:**
- `-f, --format <type>` - Output format: `text`, `json`, `yaml` (default: `text`)
- `-o, --output <path>` - Save plan to file
- `--show-risks` - Include risk analysis

### 3. `ax gen dag <workflow>`

Generate dependency graph visualization.

**Usage:**
```bash
ax gen dag workflows/security-audit.yaml
ax gen dag workflows/ci-cd.yaml --format dot --output graph.dot
ax gen dag workflows/test.yaml --format mermaid
```

**Options:**
- `-f, --format <type>` - Output format: `ascii`, `dot`, `mermaid`, `json` (default: `ascii`)
- `-o, --output <path>` - Save graph to file
- `--highlight-critical` - Highlight critical path
- `--include-metadata` - Include step metadata in nodes

### 4. `ax gen scaffold <workflow>`

Generate project structure from workflow.

**Usage:**
```bash
ax gen scaffold workflows/security-audit.yaml --output ./audit-project
ax gen scaffold workflows/ci-cd.yaml --output ./pipeline --include-ci
```

**Options:**
- `-o, --output <path>` - Output directory (required)
- `--include-tests` - Generate test files
- `--include-ci` - Generate CI/CD configuration
- `--include-docs` - Generate documentation
- `--template <name>` - Use specific template (default: `standard`)

### 5. `ax gen tests <workflow>`

Generate test suite for workflow.

**Usage:**
```bash
ax gen tests workflows/security-audit.yaml
ax gen tests workflows/ci-cd.yaml --output tests/custom --framework jest
```

**Options:**
- `-o, --output <path>` - Output directory (default: `tests/workflows`)
- `--framework <name>` - Test framework: `vitest`, `jest`, `mocha` (default: `vitest`)
- `--coverage` - Include coverage configuration
- `--e2e` - Include end-to-end tests

---

## Implementation Plan

### Week 3: Core Generation (Spec + Plan + DAG)

**Day 11-12: SpecGenerator**
- [ ] Create `src/services/SpecGenerator.ts`
- [ ] Implement natural language â†’ YAML conversion
- [ ] Prompt engineering for workflow generation
- [ ] Schema validation for generated YAML
- [ ] Dependency inference and optimization
- [ ] CLI command: `ax spec create`
- [ ] Unit tests for SpecGenerator

**Day 13: PlanGenerator**
- [ ] Create `src/services/PlanGenerator.ts`
- [ ] Implement dependency graph analysis
- [ ] Phase grouping and parallelization detection
- [ ] Cost and time estimation algorithms
- [ ] Critical path calculation
- [ ] CLI command: `ax gen plan`
- [ ] Unit tests for PlanGenerator

**Day 14: DAGGenerator**
- [ ] Create `src/services/DAGGenerator.ts`
- [ ] Implement ASCII art generation
- [ ] Implement DOT format (Graphviz)
- [ ] Implement Mermaid format
- [ ] Critical path highlighting
- [ ] CLI command: `ax gen dag`
- [ ] Unit tests for DAGGenerator

**Day 15: Integration + Polish**
- [ ] Integration tests for spec â†’ plan â†’ dag flow
- [ ] Error handling and validation
- [ ] CLI output formatting and colors
- [ ] Documentation for core commands

**Deliverables:**
- âœ… `ax spec create` generates valid workflows
- âœ… `ax gen plan` produces accurate estimates
- âœ… `ax gen dag` visualizes dependencies
- âœ… Unit test coverage >80%

### Week 4: Advanced Generation (Scaffold + Tests)

**Day 16-17: ScaffoldGenerator**
- [ ] Create `src/services/ScaffoldGenerator.ts`
- [ ] Implement project structure generation
- [ ] Template system for files
- [ ] Config file generation
- [ ] Script generation (run.sh, deploy.sh)
- [ ] Documentation generation (README.md)
- [ ] CLI command: `ax gen scaffold`
- [ ] Unit tests for ScaffoldGenerator

**Day 18-19: TestGenerator**
- [ ] Create `src/services/TestGenerator.ts`
- [ ] Implement unit test generation
- [ ] Implement integration test generation
- [ ] Implement E2E test generation
- [ ] Test fixture generation
- [ ] Support multiple test frameworks
- [ ] CLI command: `ax gen tests`
- [ ] Unit tests for TestGenerator

**Day 20: Integration + Examples**
- [ ] End-to-end integration tests
- [ ] Example workflows and generated outputs
- [ ] Performance optimization
- [ ] CLI help documentation
- [ ] Tutorial and examples in docs

**Deliverables:**
- âœ… `ax gen scaffold` creates project structure
- âœ… `ax gen tests` generates comprehensive test suites
- âœ… Full workflow: spec â†’ plan â†’ dag â†’ scaffold â†’ tests
- âœ… Documentation with examples

---

## Testing Strategy

### Unit Tests

**SpecGenerator Tests** (`src/services/__tests__/SpecGenerator.test.ts`):
```typescript
describe('SpecGenerator', () => {
  it('should generate valid YAML from description', async () => {});
  it('should infer appropriate agents', async () => {});
  it('should create valid dependencies', async () => {});
  it('should validate against schema', async () => {});
  it('should handle complex multi-step workflows', async () => {});
  it('should respect agent restrictions', async () => {});
  it('should add error handling config', async () => {});
});
```

**PlanGenerator Tests** (`__tests__/PlanGenerator.test.ts`):
```typescript
describe('PlanGenerator', () => {
  it('should group steps into phases', async () => {});
  it('should calculate accurate time estimates', async () => {});
  it('should calculate accurate cost estimates', async () => {});
  it('should identify parallelizable steps', async () => {});
  it('should find critical path', async () => {});
  it('should handle circular dependencies', async () => {});
});
```

**DAGGenerator Tests** (`__tests__/DAGGenerator.test.ts`):
```typescript
describe('DAGGenerator', () => {
  it('should generate ASCII graph', async () => {});
  it('should generate DOT format', async () => {});
  it('should generate Mermaid format', async () => {});
  it('should highlight critical path', async () => {});
  it('should handle disconnected subgraphs', async () => {});
});
```

### Integration Tests

**Full Generation Pipeline** (`src/__tests__/integration/spec-kit.test.ts`):
```typescript
describe('Spec-Kit Integration', () => {
  it('should generate spec â†’ plan â†’ dag â†’ scaffold â†’ tests', async () => {
    // 1. Generate spec
    const spec = await specGenerator.generateSpec('security audit');
    expect(spec.yaml).toContain('name:');

    // 2. Generate plan
    const plan = await planGenerator.generatePlan(spec.outputPath);
    expect(plan.phases.length).toBeGreaterThan(0);

    // 3. Generate DAG
    const dag = await dagGenerator.generateDAG(spec.outputPath, { format: 'dot' });
    expect(dag).toContain('digraph');

    // 4. Generate scaffold
    const scaffold = await scaffoldGenerator.generateScaffold(spec.outputPath, {
      outputPath: './test-output'
    });
    expect(scaffold.createdFiles).toBeGreaterThan(0);

    // 5. Generate tests
    const tests = await testGenerator.generateTests(spec.outputPath, {
      outputPath: './test-output/tests'
    });
    expect(tests.totalTests).toBeGreaterThan(0);
  });
});
```

---

## Success Metrics

### Quality Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Workflow validity | >95% | Generated YAML parses successfully |
| Execution success | >90% | Generated workflows execute without errors |
| Dependency correctness | >95% | No circular dependencies or invalid refs |
| Cost estimate accuracy | Â±20% | Actual cost vs estimated cost |
| Time estimate accuracy | Â±30% | Actual duration vs estimated duration |

### Performance Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Spec generation | <30s | Time to generate workflow YAML |
| Plan generation | <5s | Time to analyze and produce plan |
| DAG generation | <2s | Time to produce graph |
| Scaffold generation | <10s | Time to create project structure |
| Test generation | <20s | Time to generate test suite |

### Adoption Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Spec-Kit usage | >60% of workflows | Telemetry: generated vs manual |
| Iteration rate | >2 refinements per workflow | Users regenerate with edits |
| Time savings | >80% | Manual authoring (50m) vs generated (5m) |

---

## Dependencies

### NPM Packages

All required packages already installed:
- `js-yaml` - YAML parsing and generation
- `chalk` - Terminal colors
- `ora` - Loading spinners
- Existing: `ProviderRouterV2`, `AgentRegistry`, `WorkflowParser`

---

## Risk Mitigation

### Risk 1: Poor Workflow Generation Quality

**Probability:** Medium
**Impact:** High (unusable workflows)

**Mitigation:**
- Extensive prompt engineering with examples
- Schema validation before returning
- Human-in-the-loop confirmation
- Iterative refinement: `ax spec refine <workflow> "changes"`
- Telemetry to track success rates

### Risk 2: Inaccurate Cost/Time Estimates

**Probability:** Medium
**Impact:** Medium (user disappointment)

**Mitigation:**
- Conservative estimates (overestimate by 20%)
- Learn from actual execution data
- Display estimates as ranges (5-10 minutes)
- Allow user calibration with historical data

### Risk 3: Template Complexity

**Probability:** Low
**Impact:** Low (limited scaffold features)

**Mitigation:**
- Start with simple templates
- Extensible template system
- Community-contributed templates
- Template validation and testing

---

## Documentation Deliverables

1. **Spec-Kit User Guide** (`docs/spec-kit/user-guide.md`)
   - Overview and benefits
   - Tutorial for each command
   - Examples and best practices
   - Troubleshooting

2. **API Reference** (`docs/spec-kit/api-reference.md`)
   - SpecGenerator API
   - PlanGenerator API
   - DAGGenerator API
   - ScaffoldGenerator API
   - TestGenerator API

3. **Examples** (`examples/spec-kit/`)
   - Generated workflows
   - Execution plans
   - DAG visualizations
   - Project scaffolds
   - Test suites

---

## Conclusion

Spec-Kit Auto-Generation is a **critical P0 feature** that transforms workflow creation from manual YAML authoring to natural language specification. This 10x productivity boost makes AutomatosX accessible to non-technical users while maintaining power-user capabilities.

**Key Benefits:**
- âœ… 10x faster workflow creation
- âœ… Eliminates YAML expertise requirement
- âœ… AI-generated workflows follow best practices
- âœ… Full lifecycle: spec â†’ plan â†’ dag â†’ scaffold â†’ tests
- âœ… Foundation for iterative workflow refinement

**Ready to start Week 3 implementation.**

---

**Document Version:** 1.0
**Last Updated:** 2025-01-11
**Next Review:** After Week 3 completion
