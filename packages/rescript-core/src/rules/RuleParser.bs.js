// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Int from "rescript/lib/es6/belt_Int.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Float from "rescript/lib/es6/belt_Float.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";

function isWhitespace(c) {
  if (c === " " || c === "\t" || c === "\n") {
    return true;
  } else {
    return c === "\r";
  }
}

function isDigit(c) {
  var code = c.charCodeAt(0);
  if (code >= 48.0) {
    return code <= 57.0;
  } else {
    return false;
  }
}

function isAlpha(c) {
  var code = c.charCodeAt(0);
  if (code >= 65.0 && code <= 90.0) {
    return true;
  } else if (code >= 97.0) {
    return code <= 122.0;
  } else {
    return false;
  }
}

function isAlphaNumeric(c) {
  if (isAlpha(c) || isDigit(c)) {
    return true;
  } else {
    return c === "_";
  }
}

function readNumber(input, start) {
  var readDigits = function (_pos, _acc) {
    while(true) {
      var acc = _acc;
      var pos = _pos;
      if (pos >= input.length) {
        return [
                acc,
                pos
              ];
      }
      var c = input.charAt(pos);
      if (!isDigit(c)) {
        return [
                acc,
                pos
              ];
      }
      _acc = acc + c;
      _pos = pos + 1 | 0;
      continue ;
    };
  };
  var match = readDigits(start, "");
  var afterInt = match[1];
  var intPart = match[0];
  if (!(afterInt < input.length && input.charAt(afterInt) === ".")) {
    return [
            {
              TAG: "IntLiteral",
              _0: Belt_Option.getWithDefault(Belt_Int.fromString(intPart), 0)
            },
            afterInt
          ];
  }
  var match$1 = readDigits(afterInt + 1 | 0, "");
  var floatStr = intPart + "." + match$1[0];
  return [
          {
            TAG: "FloatLiteral",
            _0: Belt_Option.getWithDefault(Belt_Float.fromString(floatStr), 0.0)
          },
          match$1[1]
        ];
}

function readIdentifier(input, start) {
  var readChars = function (_pos, _acc) {
    while(true) {
      var acc = _acc;
      var pos = _pos;
      if (pos >= input.length) {
        return [
                acc,
                pos
              ];
      }
      var c = input.charAt(pos);
      if (!isAlphaNumeric(c)) {
        return [
                acc,
                pos
              ];
      }
      _acc = acc + c;
      _pos = pos + 1 | 0;
      continue ;
    };
  };
  var match = readChars(start, "");
  var ident = match[0];
  var tok;
  switch (ident) {
    case "ALWAYS" :
        tok = "Always";
        break;
    case "AND" :
        tok = "And";
        break;
    case "NEVER" :
        tok = "Never";
        break;
    case "NOT" :
        tok = "Not";
        break;
    case "OR" :
        tok = "Or";
        break;
    case "contains" :
        tok = "Contains";
        break;
    case "false" :
        tok = {
          TAG: "BoolLiteral",
          _0: false
        };
        break;
    case "matches" :
        tok = "Matches";
        break;
    case "then" :
        tok = "Then";
        break;
    case "true" :
        tok = {
          TAG: "BoolLiteral",
          _0: true
        };
        break;
    case "when" :
        tok = "When";
        break;
    default:
      tok = {
        TAG: "Identifier",
        _0: ident
      };
  }
  return [
          tok,
          match[1]
        ];
}

function readString(input, start) {
  var readChars = function (_pos, _acc) {
    while(true) {
      var acc = _acc;
      var pos = _pos;
      if (pos >= input.length) {
        return [
                acc,
                pos
              ];
      }
      var c = input.charAt(pos);
      if (c === "\"" || c === "'") {
        return [
                acc,
                pos + 1 | 0
              ];
      }
      _acc = acc + c;
      _pos = pos + 1 | 0;
      continue ;
    };
  };
  var match = readChars(start + 1 | 0, "");
  return [
          {
            TAG: "StringLiteral",
            _0: match[0]
          },
          match[1]
        ];
}

function tokenize(input) {
  var _pos = 0;
  var _tokens = [];
  while(true) {
    var tokens = _tokens;
    var pos = _pos;
    if (pos >= input.length) {
      return {
              TAG: "Success",
              _0: tokens.concat(["EOF"])
            };
    }
    var c = input.charAt(pos);
    if (isWhitespace(c)) {
      _pos = pos + 1 | 0;
      continue ;
    }
    if (c === "(") {
      _tokens = tokens.concat(["LeftParen"]);
      _pos = pos + 1 | 0;
      continue ;
    }
    if (c === ")") {
      _tokens = tokens.concat(["RightParen"]);
      _pos = pos + 1 | 0;
      continue ;
    }
    if (c === ",") {
      _tokens = tokens.concat(["Comma"]);
      _pos = pos + 1 | 0;
      continue ;
    }
    if (c === "$") {
      var match = readIdentifier(input, pos + 1 | 0);
      var ident = match[0];
      if (typeof ident !== "object") {
        return {
                TAG: "Failure",
                _0: {
                  message: "Invalid context reference after $",
                  position: pos,
                  token: "$"
                }
              };
      }
      if (ident.TAG !== "Identifier") {
        return {
                TAG: "Failure",
                _0: {
                  message: "Invalid context reference after $",
                  position: pos,
                  token: "$"
                }
              };
      }
      _tokens = tokens.concat([{
              TAG: "ContextRef",
              _0: ident._0
            }]);
      _pos = match[1];
      continue ;
    } else {
      if (c === "=") {
        if (!((pos + 1 | 0) < input.length && input.charAt(pos + 1 | 0) === "=")) {
          return {
                  TAG: "Failure",
                  _0: {
                    message: "Expected '==' for equality",
                    position: pos,
                    token: "="
                  }
                };
        }
        _tokens = tokens.concat(["Equals"]);
        _pos = pos + 2 | 0;
        continue ;
      }
      if (c === "!") {
        if (!((pos + 1 | 0) < input.length && input.charAt(pos + 1 | 0) === "=")) {
          return {
                  TAG: "Failure",
                  _0: {
                    message: "Expected '!=' for inequality",
                    position: pos,
                    token: "!"
                  }
                };
        }
        _tokens = tokens.concat(["NotEquals"]);
        _pos = pos + 2 | 0;
        continue ;
      }
      if (c === ">") {
        if ((pos + 1 | 0) < input.length && input.charAt(pos + 1 | 0) === "=") {
          _tokens = tokens.concat(["GreaterThanOrEqual"]);
          _pos = pos + 2 | 0;
          continue ;
        }
        _tokens = tokens.concat(["GreaterThan"]);
        _pos = pos + 1 | 0;
        continue ;
      }
      if (c === "<") {
        if ((pos + 1 | 0) < input.length && input.charAt(pos + 1 | 0) === "=") {
          _tokens = tokens.concat(["LessThanOrEqual"]);
          _pos = pos + 2 | 0;
          continue ;
        }
        _tokens = tokens.concat(["LessThan"]);
        _pos = pos + 1 | 0;
        continue ;
      }
      if (c === "\"" || c === "'") {
        var match$1 = readString(input, pos);
        _tokens = tokens.concat([match$1[0]]);
        _pos = match$1[1];
        continue ;
      }
      if (isDigit(c)) {
        var match$2 = readNumber(input, pos);
        _tokens = tokens.concat([match$2[0]]);
        _pos = match$2[1];
        continue ;
      }
      if (!isAlpha(c)) {
        return {
                TAG: "Failure",
                _0: {
                  message: "Unexpected character: " + c,
                  position: pos,
                  token: c
                }
              };
      }
      var match$3 = readIdentifier(input, pos);
      _tokens = tokens.concat([match$3[0]]);
      _pos = match$3[1];
      continue ;
    }
  };
}

var Tokenizer = {
  isWhitespace: isWhitespace,
  isDigit: isDigit,
  isAlpha: isAlpha,
  isAlphaNumeric: isAlphaNumeric,
  readNumber: readNumber,
  readIdentifier: readIdentifier,
  readString: readString,
  tokenize: tokenize
};

function peek(state) {
  return Belt_Option.getWithDefault(Belt_Array.get(state.tokens, state.position), "EOF");
}

function advance(state) {
  return {
          tokens: state.tokens,
          position: state.position + 1 | 0
        };
}

function expect(state, expected) {
  var current = peek(state);
  if (current === expected) {
    return {
            TAG: "Success",
            _0: advance(state)
          };
  } else {
    return {
            TAG: "Failure",
            _0: {
              message: "Expected " + expected + ", got " + current,
              position: state.position,
              token: undefined
            }
          };
  }
}

function parseValue(state) {
  var current = peek(state);
  if (typeof current === "object") {
    switch (current.TAG) {
      case "StringLiteral" :
          return {
                  TAG: "Success",
                  _0: [
                    {
                      TAG: "StringValue",
                      _0: current._0
                    },
                    advance(state)
                  ]
                };
      case "IntLiteral" :
          return {
                  TAG: "Success",
                  _0: [
                    {
                      TAG: "IntValue",
                      _0: current._0
                    },
                    advance(state)
                  ]
                };
      case "FloatLiteral" :
          return {
                  TAG: "Success",
                  _0: [
                    {
                      TAG: "FloatValue",
                      _0: current._0
                    },
                    advance(state)
                  ]
                };
      case "BoolLiteral" :
          return {
                  TAG: "Success",
                  _0: [
                    {
                      TAG: "BoolValue",
                      _0: current._0
                    },
                    advance(state)
                  ]
                };
      case "ContextRef" :
          return {
                  TAG: "Success",
                  _0: [
                    {
                      TAG: "ContextRef",
                      _0: current._0
                    },
                    advance(state)
                  ]
                };
      default:
        
    }
  }
  return {
          TAG: "Failure",
          _0: {
            message: "Expected value, got " + current,
            position: state.position,
            token: undefined
          }
        };
}

function parseCompareOp(state) {
  var current = peek(state);
  if (typeof current !== "object") {
    switch (current) {
      case "Equals" :
          return {
                  TAG: "Success",
                  _0: [
                    "Equal",
                    advance(state)
                  ]
                };
      case "NotEquals" :
          return {
                  TAG: "Success",
                  _0: [
                    "NotEqual",
                    advance(state)
                  ]
                };
      case "GreaterThan" :
          return {
                  TAG: "Success",
                  _0: [
                    "GreaterThan",
                    advance(state)
                  ]
                };
      case "LessThan" :
          return {
                  TAG: "Success",
                  _0: [
                    "LessThan",
                    advance(state)
                  ]
                };
      case "GreaterThanOrEqual" :
          return {
                  TAG: "Success",
                  _0: [
                    "GreaterThanOrEqual",
                    advance(state)
                  ]
                };
      case "LessThanOrEqual" :
          return {
                  TAG: "Success",
                  _0: [
                    "LessThanOrEqual",
                    advance(state)
                  ]
                };
      case "Contains" :
          return {
                  TAG: "Success",
                  _0: [
                    "Contains",
                    advance(state)
                  ]
                };
      case "Matches" :
          return {
                  TAG: "Success",
                  _0: [
                    "Matches",
                    advance(state)
                  ]
                };
      default:
        
    }
  }
  return {
          TAG: "Failure",
          _0: {
            message: "Expected comparison operator, got " + current,
            position: state.position,
            token: undefined
          }
        };
}

function parsePrimaryCondition(state) {
  var current = peek(state);
  if (typeof current !== "object") {
    switch (current) {
      case "Not" :
          var state1 = advance(state);
          var err = parsePrimaryCondition(state1);
          if (err.TAG !== "Success") {
            return {
                    TAG: "Failure",
                    _0: err._0
                  };
          }
          var match = err._0;
          return {
                  TAG: "Success",
                  _0: [
                    {
                      TAG: "Not",
                      _0: match[0]
                    },
                    match[1]
                  ]
                };
      case "Always" :
          return {
                  TAG: "Success",
                  _0: [
                    "Always",
                    advance(state)
                  ]
                };
      case "Never" :
          return {
                  TAG: "Success",
                  _0: [
                    "Never",
                    advance(state)
                  ]
                };
      case "LeftParen" :
          var state1$1 = advance(state);
          var err$1 = parseCondition(state1$1);
          if (err$1.TAG !== "Success") {
            return {
                    TAG: "Failure",
                    _0: err$1._0
                  };
          }
          var match$1 = err$1._0;
          var state3 = expect(match$1[1], "RightParen");
          if (state3.TAG === "Success") {
            return {
                    TAG: "Success",
                    _0: [
                      match$1[0],
                      state3._0
                    ]
                  };
          } else {
            return {
                    TAG: "Failure",
                    _0: state3._0
                  };
          }
      default:
        
    }
  }
  var err$2 = parseValue(state);
  if (err$2.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: err$2._0
          };
  }
  var match$2 = err$2._0;
  var err$3 = parseCompareOp(match$2[1]);
  if (err$3.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: err$3._0
          };
  }
  var match$3 = err$3._0;
  var err$4 = parseValue(match$3[1]);
  if (err$4.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: err$4._0
          };
  }
  var match$4 = err$4._0;
  return {
          TAG: "Success",
          _0: [
            {
              TAG: "Comparison",
              _0: match$2[0],
              _1: match$3[0],
              _2: match$4[0]
            },
            match$4[1]
          ]
        };
}

function parseCondition(state) {
  var err = parsePrimaryCondition(state);
  if (err.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: err._0
          };
  }
  var match = err._0;
  var state1 = match[1];
  var left = match[0];
  var current = peek(state1);
  if (typeof current === "object") {
    return {
            TAG: "Success",
            _0: [
              left,
              state1
            ]
          };
  }
  switch (current) {
    case "And" :
        var state2 = advance(state1);
        var err$1 = parseCondition(state2);
        if (err$1.TAG !== "Success") {
          return {
                  TAG: "Failure",
                  _0: err$1._0
                };
        }
        var match$1 = err$1._0;
        return {
                TAG: "Success",
                _0: [
                  {
                    TAG: "LogicalOp",
                    _0: "And",
                    _1: left,
                    _2: match$1[0]
                  },
                  match$1[1]
                ]
              };
    case "Or" :
        var state2$1 = advance(state1);
        var err$2 = parseCondition(state2$1);
        if (err$2.TAG !== "Success") {
          return {
                  TAG: "Failure",
                  _0: err$2._0
                };
        }
        var match$2 = err$2._0;
        return {
                TAG: "Success",
                _0: [
                  {
                    TAG: "LogicalOp",
                    _0: "Or",
                    _1: left,
                    _2: match$2[0]
                  },
                  match$2[1]
                ]
              };
    default:
      return {
              TAG: "Success",
              _0: [
                left,
                state1
              ]
            };
  }
}

function parseAction(state) {
  var current = peek(state);
  if (typeof current === "object" && current.TAG === "Identifier") {
    switch (current._0) {
      case "NoAction" :
          return {
                  TAG: "Success",
                  _0: [
                    "NoAction",
                    advance(state)
                  ]
                };
      case "ScheduleRetry" :
          return {
                  TAG: "Success",
                  _0: [
                    {
                      TAG: "ExecuteEffect",
                      _0: "ScheduleRetry"
                    },
                    advance(state)
                  ]
                };
      default:
        
    }
  }
  return {
          TAG: "Failure",
          _0: {
            message: "Expected action, got " + current,
            position: state.position,
            token: undefined
          }
        };
}

function parseRule(state) {
  var state1 = expect(state, "When");
  if (state1.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: state1._0
          };
  }
  var err = parseCondition(state1._0);
  if (err.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: err._0
          };
  }
  var match = err._0;
  var state3 = expect(match[1], "Then");
  if (state3.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: state3._0
          };
  }
  var err$1 = parseAction(state3._0);
  if (err$1.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: err$1._0
          };
  }
  var match$1 = err$1._0;
  var state4 = match$1[1];
  var current = peek(state4);
  if (current === "EOF") {
    return {
            TAG: "Success",
            _0: {
              metadata: {
                name: "parsed-rule",
                description: undefined,
                tags: [],
                enabled: true,
                createdAt: Date.now(),
                updatedAt: undefined
              },
              priority: "Medium",
              condition: match[0],
              actions: [match$1[0]]
            }
          };
  } else {
    return {
            TAG: "Failure",
            _0: {
              message: "Expected EOF, got " + current,
              position: state4.position,
              token: undefined
            }
          };
  }
}

var Parser = {
  peek: peek,
  advance: advance,
  expect: expect,
  parseValue: parseValue,
  parseCompareOp: parseCompareOp,
  parsePrimaryCondition: parsePrimaryCondition,
  parseCondition: parseCondition,
  parseAction: parseAction,
  parseRule: parseRule
};

function parseRuleString(input) {
  var tokens = tokenize(input);
  if (tokens.TAG !== "Success") {
    return {
            TAG: "Failure",
            _0: tokens._0
          };
  }
  var state_tokens = tokens._0;
  var state = {
    tokens: state_tokens,
    position: 0
  };
  return parseRule(state);
}

function getErrorMessage(result) {
  if (result.TAG === "Success") {
    return ;
  } else {
    return result._0.message;
  }
}

export {
  Tokenizer ,
  Parser ,
  parseRuleString ,
  getErrorMessage ,
}
/* No side effect */
