// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_string from "rescript/lib/es6/js_string.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function createRetryable(operation, shouldRetryOpt, onRetryOpt, onSuccessOpt, onFailureOpt) {
  var shouldRetry = shouldRetryOpt !== undefined ? shouldRetryOpt : (function (param) {
        return true;
      });
  var onRetry = onRetryOpt !== undefined ? onRetryOpt : (function (param, param$1) {
        
      });
  var onSuccess = onSuccessOpt !== undefined ? onSuccessOpt : (function (param) {
        
      });
  var onFailure = onFailureOpt !== undefined ? onFailureOpt : (function (param) {
        
      });
  return {
          operation: operation,
          shouldRetry: shouldRetry,
          onRetry: onRetry,
          onSuccess: onSuccess,
          onFailure: onFailure
        };
}

function calculateDelayWithJitter(baseDelay, useJitter) {
  if (!useJitter) {
    return baseDelay;
  }
  var jitterFactor = 0.75 + Math.random() * 0.5;
  return baseDelay * jitterFactor | 0;
}

function calculateExponentialDelay(config, attemptNumber) {
  var power = attemptNumber - 1 | 0;
  var delay = config.initialDelayMs * Math.pow(config.backoffMultiplier, power);
  var cappedDelay = Math.min(delay, config.maxDelayMs) | 0;
  return calculateDelayWithJitter(cappedDelay, config.jitter);
}

function calculateLinearDelay(baseDelayMs, attemptNumber) {
  return Math.imul(baseDelayMs, attemptNumber);
}

function getDelayForStrategy(strategy, attemptNumber) {
  switch (strategy.TAG) {
    case "Exponential" :
        return calculateExponentialDelay(strategy._0, attemptNumber);
    case "Linear" :
        return Math.imul(strategy._1, attemptNumber);
    case "Immediate" :
        return 0;
    case "Fixed" :
        return strategy._1;
    
  }
}

function getMaxAttempts(strategy) {
  if (strategy.TAG === "Exponential") {
    return strategy._0.maxAttempts;
  } else {
    return strategy._0;
  }
}

function retry(retryable, strategy) {
  var maxAttempts = getMaxAttempts(strategy);
  var attempt = function (attemptNumber) {
    var __x = retryable.operation();
    return Js_promise.then_((function (result) {
                  if (result.TAG === "Ok") {
                    var value = result._0;
                    retryable.onSuccess(value);
                    return Promise.resolve({
                                TAG: "Ok",
                                _0: value
                              });
                  }
                  var err = result._0;
                  if (attemptNumber >= maxAttempts) {
                    retryable.onFailure(err);
                    return Promise.resolve({
                                TAG: "Error",
                                _0: err
                              });
                  }
                  if (retryable.shouldRetry(err)) {
                    retryable.onRetry(attemptNumber, err);
                    var delayMs = getDelayForStrategy(strategy, attemptNumber);
                    return new Promise((function (resolve, param) {
                                  setTimeout((function () {
                                          ((function (__x) {
                                                  return Js_promise.then_((function (result) {
                                                                resolve(result);
                                                                return Promise.resolve();
                                                              }), __x);
                                                })(attempt(attemptNumber + 1 | 0)));
                                        }), delayMs);
                                }));
                  }
                  retryable.onFailure(err);
                  return Promise.resolve({
                              TAG: "Error",
                              _0: err
                            });
                }), __x);
  };
  return attempt(1);
}

var defaultCircuitBreakerConfig = {
  failureThreshold: 5,
  successThreshold: 2,
  cooldownPeriodMs: 60000,
  timeoutMs: 5000
};

function createCircuitBreaker(operation, configOpt) {
  var config = configOpt !== undefined ? configOpt : defaultCircuitBreakerConfig;
  return {
          state: "Closed",
          failureCount: 0,
          successCount: 0,
          config: config,
          operation: operation
        };
}

function shouldAllowOperation(breaker) {
  var openedAt = breaker.state;
  if (typeof openedAt !== "object") {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  var now = Date.now() | 0;
  var timeSinceOpen = now - openedAt._0 | 0;
  if (timeSinceOpen >= breaker.config.cooldownPeriodMs) {
    breaker.state = "HalfOpen";
    breaker.successCount = 0;
    return {
            TAG: "Ok",
            _0: undefined
          };
  } else {
    return {
            TAG: "Error",
            _0: "Circuit breaker is open"
          };
  }
}

function recordSuccess(breaker) {
  var match = breaker.state;
  if (typeof match === "object") {
    return ;
  }
  if (match === "Closed") {
    breaker.failureCount = 0;
    return ;
  }
  breaker.successCount = breaker.successCount + 1 | 0;
  if (breaker.successCount >= breaker.config.successThreshold) {
    breaker.state = "Closed";
    breaker.failureCount = 0;
    breaker.successCount = 0;
    return ;
  }
  
}

function recordFailure(breaker) {
  var match = breaker.state;
  if (typeof match === "object") {
    return ;
  }
  if (match === "Closed") {
    breaker.failureCount = breaker.failureCount + 1 | 0;
    if (breaker.failureCount >= breaker.config.failureThreshold) {
      breaker.state = {
        TAG: "Open",
        _0: Date.now() | 0
      };
      return ;
    } else {
      return ;
    }
  }
  breaker.state = {
    TAG: "Open",
    _0: Date.now() | 0
  };
  breaker.successCount = 0;
}

function executeWithCircuitBreaker(breaker) {
  var err = shouldAllowOperation(breaker);
  if (err.TAG === "Ok") {
    var __x = breaker.operation.operation();
    return Js_promise.then_((function (result) {
                  if (result.TAG === "Ok") {
                    var value = result._0;
                    recordSuccess(breaker);
                    breaker.operation.onSuccess(value);
                    return Promise.resolve({
                                TAG: "Ok",
                                _0: value
                              });
                  }
                  var err = result._0;
                  recordFailure(breaker);
                  breaker.operation.onFailure(err);
                  return Promise.resolve({
                              TAG: "Error",
                              _0: err
                            });
                }), __x);
  } else {
    return Promise.resolve({
                TAG: "Error",
                _0: err._0
              });
  }
}

function retryWithCircuitBreaker(retryable, strategy, circuitConfig) {
  var breaker = createCircuitBreaker(retryable, circuitConfig);
  var wrappedOperation = createRetryable((function () {
          return executeWithCircuitBreaker(breaker);
        }), retryable.shouldRetry, retryable.onRetry, retryable.onSuccess, retryable.onFailure);
  return retry(wrappedOperation, strategy);
}

function retryBatch(operations, strategy) {
  var results = {
    contents: []
  };
  var error = {
    contents: undefined
  };
  var processNext = function (_index) {
    while(true) {
      var index = _index;
      if (index >= operations.length) {
        var err = error.contents;
        if (err !== undefined) {
          return Promise.resolve({
                      TAG: "Error",
                      _0: Caml_option.valFromOption(err)
                    });
        } else {
          return Promise.resolve({
                      TAG: "Ok",
                      _0: results.contents
                    });
        }
      }
      var op = Belt_Array.get(operations, index);
      if (op !== undefined) {
        var __x = retry(op, strategy);
        return Js_promise.then_((function(index){
                  return function (result) {
                    if (result.TAG === "Ok") {
                      results.contents = Belt_Array.concat(results.contents, [result._0]);
                      return processNext(index + 1 | 0);
                    }
                    var err = result._0;
                    error.contents = Caml_option.some(err);
                    return Promise.resolve({
                                TAG: "Error",
                                _0: err
                              });
                  }
                  }(index)), __x);
      }
      _index = index + 1 | 0;
      continue ;
    };
  };
  return processNext(0);
}

function retryBatchParallel(operations, strategy) {
  return Promise.all(Belt_Array.map(operations, (function (op) {
                    return retry(op, strategy);
                  })));
}

function getStrategyName(strategy) {
  switch (strategy.TAG) {
    case "Exponential" :
        return "Exponential";
    case "Linear" :
        return "Linear";
    case "Immediate" :
        return "Immediate";
    case "Fixed" :
        return "Fixed";
    
  }
}

function getCircuitStateName(state) {
  if (typeof state !== "object") {
    if (state === "Closed") {
      return "Closed";
    } else {
      return "HalfOpen";
    }
  } else {
    return "Open";
  }
}

function isNetworkError(statusCode) {
  if (statusCode >= 500) {
    return true;
  } else {
    return statusCode === 429;
  }
}

function isTimeoutError(message) {
  return Js_string.includes("timeout", message.toLowerCase());
}

function isConnectionError(message) {
  if (Js_string.includes("connection", message.toLowerCase())) {
    return true;
  } else {
    return Js_string.includes("network", message.toLowerCase());
  }
}

var defaultRetryConfig = {
  maxAttempts: 3,
  initialDelayMs: 1000,
  maxDelayMs: 30000,
  backoffMultiplier: 2.0,
  jitter: true
};

export {
  defaultRetryConfig ,
  createRetryable ,
  calculateDelayWithJitter ,
  calculateExponentialDelay ,
  calculateLinearDelay ,
  getDelayForStrategy ,
  getMaxAttempts ,
  retry ,
  defaultCircuitBreakerConfig ,
  createCircuitBreaker ,
  shouldAllowOperation ,
  recordSuccess ,
  recordFailure ,
  executeWithCircuitBreaker ,
  retryWithCircuitBreaker ,
  retryBatch ,
  retryBatchParallel ,
  getStrategyName ,
  getCircuitStateName ,
  isNetworkError ,
  isTimeoutError ,
  isConnectionError ,
}
/* No side effect */
