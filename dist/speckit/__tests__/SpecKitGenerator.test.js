/**
 * Tests for SpecKitGenerator base class
 *
 * Tests the Template Method Pattern implementation and shared utilities
 */
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { SpecKitGenerator } from '../SpecKitGenerator.js';
import * as fs from 'fs';
// Mock fs module
vi.mock('fs', () => ({
    existsSync: vi.fn(),
    mkdirSync: vi.fn(),
    writeFileSync: vi.fn(),
}));
/**
 * Concrete implementation for testing
 */
class TestGenerator extends SpecKitGenerator {
    generatorName = 'Test';
    async analyze(options) {
        return {
            files: [
                {
                    path: 'src/test.ts',
                    language: 'typescript',
                    lines: 100,
                    symbols: [
                        {
                            name: 'TestClass',
                            kind: 'class',
                            line: 10,
                        },
                    ],
                    imports: ['lodash'],
                    exports: ['TestClass'],
                },
            ],
            patterns: [
                {
                    type: 'design-pattern',
                    name: 'Singleton',
                    description: 'Singleton pattern implementation',
                    locations: [{ file: 'src/test.ts', line: 10, context: 'class TestClass' }],
                    confidence: 0.9,
                    examples: [
                        {
                            code: 'class TestClass { private static instance; }',
                            language: 'typescript',
                            explanation: 'Singleton pattern',
                        },
                    ],
                },
            ],
            stats: {
                totalFiles: 1,
                totalLines: 100,
                languages: { typescript: 1 },
            },
            dependencies: [
                {
                    name: 'lodash',
                    version: '4.17.21',
                    type: 'npm',
                    usageCount: 5,
                },
            ],
            architecture: [
                {
                    category: 'pattern',
                    title: 'Singleton Pattern',
                    description: 'Using singleton pattern for configuration',
                    impact: 'medium',
                    recommendation: 'Consider dependency injection',
                },
            ],
        };
    }
    async detect(analysis, options) {
        return analysis.patterns;
    }
    async generateContent(patterns, analysis, options) {
        // CRITICAL: Call AI provider so mock intercepts
        const result = await this.providerRouter.route({
            messages: [{
                    role: 'user',
                    content: `Generate test document. Patterns: ${patterns.length}, Files: ${analysis.files.length}`
                }],
            preferredProvider: options.provider || 'claude',
            maxTokens: 4000,
            temperature: 0.7
        });
        return result.content;
    }
}
describe('SpecKitGenerator', () => {
    let generator;
    let mockProviderRouter;
    let mockMemoryService;
    beforeEach(() => {
        // Create mocks
        mockProviderRouter = {
            route: vi.fn().mockResolvedValue({
                content: `# Test Document

## Overview
This is a comprehensive test document generated by the SpecKit system.

## Analysis Results
The analysis has identified patterns and structures in the codebase that warrant documentation.

## Patterns Detected
Several design patterns and architectural decisions have been identified:
- Singleton pattern for configuration management
- Factory pattern for object creation
- Dependency injection for loose coupling

## Recommendations
Based on the analysis, we recommend the following improvements:
- Continue using established patterns consistently
- Document architectural decisions
- Maintain clear separation of concerns

## Conclusion
This document provides a thorough analysis of the codebase architecture and patterns.`,
                provider: 'claude',
            }),
        };
        mockMemoryService = {
            search: vi.fn().mockResolvedValue([
                {
                    file: 'src/test.ts',
                    line: 10,
                    name: 'TestClass',
                    content: 'class TestClass {}',
                },
            ]),
        };
        // Create generator
        generator = new TestGenerator(mockProviderRouter, mockMemoryService);
        // Reset fs mocks
        vi.mocked(fs.existsSync).mockReturnValue(true);
        vi.mocked(fs.mkdirSync).mockReturnValue(undefined);
        vi.mocked(fs.writeFileSync).mockReturnValue(undefined);
    });
    afterEach(() => {
        vi.clearAllMocks();
        generator.clearCache();
    });
    describe('Template Method Pattern', () => {
        it('should execute generation pipeline in correct order', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            const result = await generator.generate(options);
            expect(result.success).toBe(true);
            expect(result.outputPath).toBe('/test/output/test.md');
            expect(result.content).toContain('# Test Document');
            expect(result.content).toContain('Generated by AutomatosX SpecKit');
        });
        it('should include header in formatted output', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            const result = await generator.generate(options);
            expect(result.content).toContain('Generated by AutomatosX SpecKit');
            expect(result.content).toContain('Test');
            expect(result.content).toContain('/test/project');
        });
        it('should validate generated content', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            const result = await generator.generate(options);
            expect(result.validation).toBeDefined();
            expect(result.validation?.valid).toBe(true);
            expect(result.validation?.errors).toHaveLength(0);
        });
        it('should save content to file', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            await generator.generate(options);
            expect(fs.writeFileSync).toHaveBeenCalledWith('/test/output/test.md', expect.stringContaining('# Test Document'), 'utf-8');
        });
        it('should create output directory if it does not exist', async () => {
            vi.mocked(fs.existsSync).mockReturnValue(false);
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            await generator.generate(options);
            expect(fs.mkdirSync).toHaveBeenCalledWith('/test/output', { recursive: true });
        });
        it('should include metadata in result', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            const result = await generator.generate(options);
            expect(result.metadata).toBeDefined();
            expect(result.metadata.generator).toBe('test');
            expect(result.metadata.filesAnalyzed).toBe(1);
            expect(result.metadata.patternsDetected).toBe(1);
            expect(result.metadata.provider).toBe('claude');
            expect(result.metadata.generationTime).toBeGreaterThan(0);
        });
    });
    describe('Progress Callback', () => {
        it('should call progress callback for each stage', async () => {
            const onProgress = vi.fn();
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            await generator.generate(options, onProgress);
            // Check all stages were called
            expect(onProgress).toHaveBeenCalledWith('analyzing', 0);
            expect(onProgress).toHaveBeenCalledWith('analyzing', 100);
            expect(onProgress).toHaveBeenCalledWith('detecting', 0);
            expect(onProgress).toHaveBeenCalledWith('detecting', 100);
            expect(onProgress).toHaveBeenCalledWith('generating', 0);
            expect(onProgress).toHaveBeenCalledWith('generating', 100);
            expect(onProgress).toHaveBeenCalledWith('formatting', 0);
            expect(onProgress).toHaveBeenCalledWith('formatting', 100);
            expect(onProgress).toHaveBeenCalledWith('validating', 0);
            expect(onProgress).toHaveBeenCalledWith('validating', 100);
            expect(onProgress).toHaveBeenCalledWith('saving', 0);
            expect(onProgress).toHaveBeenCalledWith('saving', 100);
        });
    });
    describe('Caching', () => {
        it('should cache generation results', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                enableCache: true,
                verbose: false,
            };
            // First call
            const result1 = await generator.generate(options);
            expect(result1.metadata.cacheHit).toBe(false);
            // Second call should hit cache
            const result2 = await generator.generate(options);
            expect(result2.metadata.cacheHit).toBe(true);
            expect(result2.content).toBe(result1.content);
        });
        it('should not cache when enableCache is false', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                enableCache: false,
                verbose: false,
            };
            // First call
            const result1 = await generator.generate(options);
            expect(result1.metadata.cacheHit).toBe(false);
            // Second call should not hit cache
            const result2 = await generator.generate(options);
            expect(result2.metadata.cacheHit).toBe(false);
        });
        it('should expire cache after TTL', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                enableCache: true,
                verbose: false,
            };
            // First call
            await generator.generate(options);
            // Manually expire cache
            const cacheKey = `Test:/test/project:/test/output/test.md`;
            const entry = generator.cache.get(cacheKey);
            if (entry) {
                entry.expiresAt = new Date(Date.now() - 1000);
            }
            // Second call should not hit cache
            const result2 = await generator.generate(options);
            expect(result2.metadata.cacheHit).toBe(false);
        });
        it('should provide cache stats', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                enableCache: true,
                verbose: false,
            };
            await generator.generate(options);
            const stats = generator.getCacheStats();
            expect(stats.entries).toBe(1);
            expect(stats.size).toBeGreaterThan(0);
        });
        it('should clear cache', async () => {
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                enableCache: true,
                verbose: false,
            };
            await generator.generate(options);
            expect(generator.getCacheStats().entries).toBe(1);
            generator.clearCache();
            expect(generator.getCacheStats().entries).toBe(0);
        });
    });
    describe('AI Provider Integration', () => {
        it('should call AI provider with correct parameters', async () => {
            await generator.callAI('Test prompt', {
                provider: 'claude',
            });
            expect(mockProviderRouter.route).toHaveBeenCalledWith({
                messages: [
                    {
                        role: 'user',
                        content: 'Test prompt',
                    },
                ],
                preferredProvider: 'claude',
                temperature: 0.7,
                maxTokens: 8000,
            });
        });
        it('should use default provider if not specified', async () => {
            await generator.callAI('Test prompt', {});
            expect(mockProviderRouter.route).toHaveBeenCalledWith(expect.objectContaining({
                preferredProvider: 'claude',
            }));
        });
        it('should return AI generated content', async () => {
            const content = await generator.callAI('Test prompt', {});
            expect(content).toContain('# Test Document');
            expect(content).toContain('comprehensive test document');
        });
    });
    describe('Code Search Integration', () => {
        it('should search code using MemoryService', async () => {
            const results = await generator.searchCode('TestClass');
            expect(mockMemoryService.search).toHaveBeenCalledWith('TestClass', {
                limit: 20,
                includeContent: true,
            });
            expect(results).toHaveLength(1);
            expect(results[0].name).toBe('TestClass');
        });
        it('should respect search limit option', async () => {
            await generator.searchCode('TestClass', { limit: 5 });
            expect(mockMemoryService.search).toHaveBeenCalledWith('TestClass', {
                limit: 5,
                includeContent: true,
            });
        });
    });
    describe('Error Handling', () => {
        it('should handle analyze() errors gracefully', async () => {
            // Override analyze to throw error
            vi.spyOn(generator, 'analyze').mockRejectedValue(new Error('Analysis failed'));
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            const result = await generator.generate(options);
            expect(result.success).toBe(false);
            expect(result.error).toBe('Analysis failed');
        });
        it('should handle detect() errors gracefully', async () => {
            vi.spyOn(generator, 'detect').mockRejectedValue(new Error('Detection failed'));
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            const result = await generator.generate(options);
            expect(result.success).toBe(false);
            expect(result.error).toBe('Detection failed');
        });
        it('should handle generateContent() errors gracefully', async () => {
            vi.spyOn(generator, 'generateContent').mockRejectedValue(new Error('Generation failed'));
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            const result = await generator.generate(options);
            expect(result.success).toBe(false);
            expect(result.error).toBe('Generation failed');
        });
        it('should handle validation failures', async () => {
            // Override validate to return invalid result
            vi.spyOn(generator, 'validate').mockResolvedValue({
                valid: false,
                errors: [{ field: 'content', message: 'Content is invalid', severity: 'error' }],
                warnings: [],
            });
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            const result = await generator.generate(options);
            expect(result.success).toBe(false);
            expect(result.error).toContain('Validation failed');
        });
    });
    describe('Validation', () => {
        it('should reject empty content', async () => {
            const validation = await generator.validate('', {});
            expect(validation.valid).toBe(false);
            expect(validation.errors.length).toBeGreaterThan(0);
            expect(validation.errors.some((e) => e.message.includes('empty'))).toBe(true);
        });
        it('should reject too short content', async () => {
            const validation = await generator.validate('Short', {});
            expect(validation.valid).toBe(false);
            expect(validation.errors).toHaveLength(1);
            expect(validation.errors[0].message).toContain('too short');
        });
        it('should accept valid content', async () => {
            const validation = await generator.validate('A'.repeat(200), {});
            expect(validation.valid).toBe(true);
            expect(validation.errors).toHaveLength(0);
        });
    });
    describe('Logging', () => {
        it('should log messages when verbose is true', async () => {
            const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => { });
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: true,
            };
            await generator.generate(options);
            expect(consoleSpy).toHaveBeenCalled();
            expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('[Test]'));
            consoleSpy.mockRestore();
        });
        it('should not log messages when verbose is false', async () => {
            const consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => { });
            const options = {
                projectRoot: '/test/project',
                outputPath: '/test/output/test.md',
                verbose: false,
            };
            await generator.generate(options);
            expect(consoleSpy).not.toHaveBeenCalled();
            consoleSpy.mockRestore();
        });
    });
});
//# sourceMappingURL=SpecKitGenerator.test.js.map