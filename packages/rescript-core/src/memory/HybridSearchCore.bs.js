// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_MapString from "rescript/lib/es6/belt_MapString.js";
import * as Belt_SetString from "rescript/lib/es6/belt_SetString.js";
import * as Belt_SortArray from "rescript/lib/es6/belt_SortArray.js";
import * as HybridSearchTypes from "./HybridSearchTypes.bs.js";

function combineResults(ftsResults, vectorResults, weights) {
  var ftsMap = Belt_MapString.fromArray(Belt_Array.map(ftsResults, (function (msg) {
              return [
                      msg.id,
                      msg
                    ];
            })));
  var vectorMap = Belt_MapString.fromArray(Belt_Array.map(vectorResults, (function (vr) {
              return [
                      vr.messageId,
                      vr
                    ];
            })));
  var allIds = Belt_SetString.fromArray(Belt_Array.concat(Belt_Array.map(ftsResults, (function (msg) {
                  return msg.id;
                })), Belt_Array.map(vectorResults, (function (vr) {
                  return vr.messageId;
                }))));
  return Belt_Array.keepMap(Belt_SetString.toArray(allIds), (function (messageId) {
                var ftsMsg = Belt_MapString.get(ftsMap, messageId);
                var vectorRes = Belt_MapString.get(vectorMap, messageId);
                if (ftsMsg !== undefined) {
                  if (vectorRes !== undefined) {
                    var recencyScore = HybridSearchTypes.calculateRecencyScore(ftsMsg.createdAt);
                    var combinedScore = HybridSearchTypes.combineScores(1.0, vectorRes.score, recencyScore, weights);
                    return {
                            source: {
                              TAG: "Hybrid",
                              _0: ftsMsg,
                              _1: vectorRes
                            },
                            combinedScore: combinedScore,
                            message: ftsMsg,
                            vectorResult: vectorRes
                          };
                  }
                  var recencyScore$1 = HybridSearchTypes.calculateRecencyScore(ftsMsg.createdAt);
                  var combinedScore$1 = HybridSearchTypes.combineScores(1.0, undefined, recencyScore$1, weights);
                  return {
                          source: {
                            TAG: "FtsOnly",
                            _0: ftsMsg
                          },
                          combinedScore: combinedScore$1,
                          message: ftsMsg,
                          vectorResult: undefined
                        };
                }
                if (vectorRes === undefined) {
                  return ;
                }
                var combinedScore$2 = HybridSearchTypes.combineScores(undefined, vectorRes.score, 0.5, weights);
                return {
                        source: {
                          TAG: "VectorOnly",
                          _0: vectorRes
                        },
                        combinedScore: combinedScore$2,
                        message: undefined,
                        vectorResult: vectorRes
                      };
              }));
}

function filterByScore(results, minScore) {
  return Belt_Array.keep(results, (function (result) {
                return result.combinedScore >= minScore;
              }));
}

function sortByScore(results) {
  Belt_SortArray.stableSortBy(results, (function (a, b) {
          if (a.combinedScore > b.combinedScore) {
            return -1;
          } else if (a.combinedScore < b.combinedScore) {
            return 1;
          } else {
            return 0;
          }
        }));
  return results;
}

function applyLimit(results, limit) {
  return Belt_Array.slice(results, 0, limit);
}

function processResults(ftsResults, vectorResults, options) {
  return Belt_Array.slice(sortByScore(filterByScore(combineResults(ftsResults, vectorResults, options.weights), options.minScore)), 0, options.limit);
}

function extractMessages(results) {
  return Belt_Array.keepMap(results, (function (result) {
                return HybridSearchTypes.getMessageFromResult(result);
              }));
}

function getResultStats(results) {
  var total = results.length;
  var hybrid = Belt_Array.keep(results, HybridSearchTypes.isHybridResult).length;
  var ftsOnly = Belt_Array.keep(results, (function (result) {
          var match = result.source;
          switch (match.TAG) {
            case "FtsOnly" :
                return true;
            case "VectorOnly" :
            case "Hybrid" :
                return false;
            
          }
        })).length;
  var vectorOnly = Belt_Array.keep(results, (function (result) {
          var match = result.source;
          switch (match.TAG) {
            case "VectorOnly" :
                return true;
            case "FtsOnly" :
            case "Hybrid" :
                return false;
            
          }
        })).length;
  var totalScore = Belt_Array.reduce(results, 0.0, (function (acc, result) {
          return acc + result.combinedScore;
        }));
  var avgScore = total > 0 ? totalScore / total : 0.0;
  return {
          total: total,
          hybrid: hybrid,
          ftsOnly: ftsOnly,
          vectorOnly: vectorOnly,
          avgScore: avgScore
        };
}

export {
  combineResults ,
  filterByScore ,
  sortByScore ,
  applyLimit ,
  processResults ,
  extractMessages ,
  getResultStats ,
}
/* No side effect */
