// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function toString(verdict) {
  if (typeof verdict !== "object") {
    return "Pass";
  } else if (verdict.TAG === "Fail") {
    return "Fail(" + verdict._0 + ")";
  } else {
    return "Defer(" + verdict._0 + ")";
  }
}

var GuardVerdict = {
  toString: toString
};

function create(state, $$event, metadata) {
  return {
          currentState: state,
          event: $$event,
          metadata: metadata,
          frozen: true
        };
}

function isFrozen(ctx) {
  return ctx.frozen;
}

var GuardContext = {
  create: create,
  isFrozen: isFrozen
};

function computeHmac(message, secretKey) {
  var combined = message + "::" + secretKey;
  try {
    return btoa(combined);
  }
  catch (exn){
    return "mock-hmac-" + message;
  }
}

function hashContext(ctx) {
  var match = ctx.currentState;
  var stateStr;
  switch (match) {
    case "Bootstrapping" :
        stateStr = "BOOTSTRAPPING";
        break;
    case "Idle" :
        stateStr = "IDLE";
        break;
    case "Preparing" :
        stateStr = "PREPARING";
        break;
    case "WaitingOnDependency" :
        stateStr = "WAITING_ON_DEP";
        break;
    case "Executing" :
        stateStr = "EXECUTING";
        break;
    case "Completed" :
        stateStr = "COMPLETED";
        break;
    case "Failed" :
        stateStr = "FAILED";
        break;
    case "Canceled" :
        stateStr = "CANCELED";
        break;
    
  }
  var match$1 = ctx.event;
  var eventStr;
  switch (match$1) {
    case "TaskSubmitted" :
        eventStr = "TASK_SUBMITTED";
        break;
    case "DependenciesReady" :
        eventStr = "DEPENDENCIES_READY";
        break;
    case "RuleViolation" :
        eventStr = "RULE_VIOLATION";
        break;
    case "Timeout" :
        eventStr = "TIMEOUT";
        break;
    case "CancelRequest" :
        eventStr = "CANCEL_REQUEST";
        break;
    case "RetryTrigger" :
        eventStr = "RETRY_TRIGGER";
        break;
    case "TelemetryFlushed" :
        eventStr = "TELEMETRY_FLUSHED";
        break;
    
  }
  var meta = ctx.metadata;
  var metadataStr = meta !== undefined ? JSON.stringify(meta) : "NO_METADATA";
  return computeHmac(stateStr + "::" + eventStr + "::" + metadataStr, "context-hash-key");
}

function sign(verdict, guardName, ctx, secretKey) {
  var timestamp = Date.now();
  var contextHash = hashContext(ctx);
  var verdictStr = toString(verdict);
  var message = verdictStr + "::" + guardName + "::" + contextHash + "::" + timestamp.toString();
  var signature = computeHmac(message, secretKey);
  return {
          verdict: verdict,
          signature: signature,
          timestamp: timestamp,
          guardName: guardName,
          contextHash: contextHash
        };
}

function verify(signedVerdict, ctx, secretKey) {
  var contextHash = hashContext(ctx);
  if (contextHash !== signedVerdict.contextHash) {
    return false;
  }
  var verdictStr = toString(signedVerdict.verdict);
  var message = verdictStr + "::" + signedVerdict.guardName + "::" + contextHash + "::" + signedVerdict.timestamp.toString();
  var expectedSignature = computeHmac(message, secretKey);
  return expectedSignature === signedVerdict.signature;
}

function isExpired(signedVerdict, maxAgeMs) {
  var now = Date.now();
  var age = now - signedVerdict.timestamp;
  return age > maxAgeMs;
}

var VerdictSignature = {
  computeHmac: computeHmac,
  hashContext: hashContext,
  sign: sign,
  verify: verify,
  isExpired: isExpired
};

function executeIsolated(guard, guardName, ctx, secretKey) {
  if (ctx.frozen) {
    var startTime = Date.now();
    var verdict;
    try {
      verdict = guard(ctx);
    }
    catch (raw_obj){
      var obj = Caml_js_exceptions.internalToOCamlException(raw_obj);
      if (obj.RE_EXN_ID === Js_exn.$$Error) {
        var msg = obj._1.message;
        var message = msg !== undefined ? msg : "Guard execution failed with unknown error";
        verdict = {
          TAG: "Fail",
          _0: "Guard execution exception: " + message
        };
      } else {
        verdict = {
          TAG: "Fail",
          _0: "Guard execution failed with non-JS exception"
        };
      }
    }
    var endTime = Date.now();
    var executionTimeMs = endTime - startTime;
    var signed = sign(verdict, guardName, ctx, secretKey);
    return {
            signedVerdict: signed,
            executionTimeMs: executionTimeMs,
            isolated: true
          };
  }
  var signed$1 = sign({
        TAG: "Fail",
        _0: "Guard context must be frozen for isolated execution"
      }, guardName, ctx, secretKey);
  return {
          signedVerdict: signed$1,
          executionTimeMs: 0.0,
          isolated: false
        };
}

function executeBatch(guards, ctx, secretKey) {
  var results = [];
  var shouldContinue = {
    contents: true
  };
  guards.forEach(function (param) {
        if (!shouldContinue.contents) {
          return ;
        }
        var result = executeIsolated(param[0], param[1], ctx, secretKey);
        results.push(result);
        var match = result.signedVerdict.verdict;
        if (typeof match !== "object" || match.TAG !== "Fail") {
          return ;
        } else {
          shouldContinue.contents = false;
          return ;
        }
      });
  return results;
}

function combineVerdicts(results) {
  var mutableVerdict = {
    contents: "Pass"
  };
  results.forEach(function (result) {
        var match = mutableVerdict.contents;
        var match$1 = result.signedVerdict.verdict;
        if (typeof match !== "object") {
          if (typeof match$1 !== "object") {
            return ;
          } else {
            if (match$1.TAG === "Fail") {
              mutableVerdict.contents = {
                TAG: "Fail",
                _0: match$1._0
              };
            } else {
              mutableVerdict.contents = {
                TAG: "Defer",
                _0: match$1._0
              };
            }
            return ;
          }
        } else if (match.TAG === "Fail" || typeof match$1 !== "object" || match$1.TAG !== "Fail") {
          return ;
        } else {
          mutableVerdict.contents = {
            TAG: "Fail",
            _0: match$1._0
          };
          return ;
        }
      });
  return mutableVerdict.contents;
}

var IsolatedGuardExecutor = {
  executeIsolated: executeIsolated,
  executeBatch: executeBatch,
  combineVerdicts: combineVerdicts
};

function create$1() {
  return [];
}

function append(log, result) {
  var entry_guardName = result.signedVerdict.guardName;
  var entry_verdict = result.signedVerdict.verdict;
  var entry_signature = result.signedVerdict.signature;
  var entry_timestamp = result.signedVerdict.timestamp;
  var entry_contextHash = result.signedVerdict.contextHash;
  var entry_executionTimeMs = result.executionTimeMs;
  var entry = {
    guardName: entry_guardName,
    verdict: entry_verdict,
    signature: entry_signature,
    timestamp: entry_timestamp,
    contextHash: entry_contextHash,
    executionTimeMs: entry_executionTimeMs
  };
  return log.concat([entry]);
}

function getEntries(log) {
  return log;
}

function verifyIntegrity(log, ctx, secretKey) {
  return log.every(function (entry) {
              var signedVerdict_verdict = entry.verdict;
              var signedVerdict_signature = entry.signature;
              var signedVerdict_timestamp = entry.timestamp;
              var signedVerdict_guardName = entry.guardName;
              var signedVerdict_contextHash = entry.contextHash;
              var signedVerdict = {
                verdict: signedVerdict_verdict,
                signature: signedVerdict_signature,
                timestamp: signedVerdict_timestamp,
                guardName: signedVerdict_guardName,
                contextHash: signedVerdict_contextHash
              };
              return verify(signedVerdict, ctx, secretKey);
            });
}

var AuditLog = {
  create: create$1,
  append: append,
  getEntries: getEntries,
  verifyIntegrity: verifyIntegrity
};

var createContext = create;

var signVerdict = sign;

var verifySignature = verify;

var isSignatureExpired = isExpired;

var executeGuardIsolated = executeIsolated;

var executeGuardsBatch = executeBatch;

var combineGuardVerdicts = combineVerdicts;

var createAuditLog = create$1;

var appendToAuditLog = append;

var verifyAuditLogIntegrity = verifyIntegrity;

export {
  GuardVerdict ,
  GuardContext ,
  VerdictSignature ,
  IsolatedGuardExecutor ,
  AuditLog ,
  createContext ,
  signVerdict ,
  verifySignature ,
  isSignatureExpired ,
  executeGuardIsolated ,
  executeGuardsBatch ,
  combineGuardVerdicts ,
  createAuditLog ,
  appendToAuditLog ,
  verifyAuditLogIntegrity ,
}
/* No side effect */
