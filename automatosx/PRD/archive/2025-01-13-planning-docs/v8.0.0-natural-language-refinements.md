# AutomatosX v8.0.0 - Natural Language Refinements PRD

**Date:** 2025-01-13
**Version:** 8.0.0 ‚Üí 8.0.1
**Status:** Ready for Implementation
**Timeline:** 2 days
**Priority:** P1 (Polish & Enhancement)

---

## üéØ EXECUTIVE SUMMARY

### Mission

Enhance the Natural Language Query system from "basic pattern matching" to "context-aware, learning, fuzzy-matching intelligent interface" that understands user intent with >90% accuracy.

### Current State (50% Complete)

**What Works:**
- ‚úÖ Intent classification with pattern matching
- ‚úÖ Basic entity extraction (workflow names, agent names)
- ‚úÖ Command mapping for 15+ commands
- ‚úÖ Slash command routing

**What's Missing:**
- ‚ùå Context-aware classification (pronouns, references)
- ‚ùå Fuzzy matching (typo tolerance)
- ‚ùå Confidence-based clarification prompts
- ‚ùå Learning from user corrections
- ‚ùå Ambiguity detection and resolution

### Success Criteria

After refinements:
- ‚úÖ Classification accuracy >90% (up from 70%)
- ‚úÖ Typos automatically corrected (Levenshtein distance ‚â§3)
- ‚úÖ Ambiguous queries prompt for clarification
- ‚úÖ System learns from corrections over time
- ‚úÖ Context awareness (last 5 messages)

---

## üìã REFINEMENT AREAS

### 1. Context-Aware Intent Classification (P0 - Must Have)

**Current Problem:**
```
ax> run security audit
‚úÖ Executes: ax workflow run security-audit.yaml

ax> show me the results
‚ùå Error: Unknown command "show me the results"
```

**Desired Behavior:**
```
ax> run security audit
‚úÖ Executes: ax workflow run security-audit.yaml

ax> show me the results
‚úÖ Context: Last command was workflow execution
‚úÖ Executes: ax workflow status security-audit.yaml --output
```

**Implementation:**

File: `src/nlp/ContextAwareIntentClassifier.ts` (new file)

```typescript
import { IntentClassifier, ClassificationResult, Intent } from '../cli/interactive/IntentClassifier.js';
import { ConversationContext, Message } from '../cli/interactive/ConversationContext.js';

export class ContextAwareIntentClassifier extends IntentClassifier {
  private conversationContext: ConversationContext;

  constructor(conversationContext: ConversationContext) {
    super();
    this.conversationContext = conversationContext;
  }

  /**
   * Classify intent with context awareness
   */
  async classify(input: string): Promise<ClassificationResult> {
    // Check if input contains contextual references
    const hasReference = this.containsReference(input);

    if (!hasReference) {
      // No context needed, use base classification
      return super.classify(input);
    }

    // Get recent conversation history
    const recentMessages = await this.conversationContext.getHistory(5);

    // Expand query with context
    const expandedQuery = await this.expandWithContext(input, recentMessages);

    // Classify expanded query
    const result = await super.classify(expandedQuery);

    // Add metadata about context usage
    result.metadata = {
      ...result.metadata,
      originalQuery: input,
      expandedQuery,
      usedContext: true,
      contextMessages: recentMessages.length
    };

    return result;
  }

  /**
   * Detect if input contains contextual references
   */
  private containsReference(input: string): boolean {
    const referencePatterns = [
      /\b(it|this|that|these|those)\b/i,
      /\b(the|this|that) (results?|output|status|logs?)\b/i,
      /\b(last|previous|same) (workflow|command|run)\b/i,
      /\bshow me\b/i,
      /\btell me (more |about )?/i,
      /\bwhat (is|are|was|were)\b/i
    ];

    return referencePatterns.some(pattern => pattern.test(input));
  }

  /**
   * Expand query using conversation context
   */
  private async expandWithContext(
    input: string,
    history: Message[]
  ): Promise<string> {
    if (history.length === 0) {
      return input;
    }

    // Find last user command
    const lastUserMessage = history
      .filter(m => m.role === 'user')
      .reverse()[0];

    if (!lastUserMessage) {
      return input;
    }

    // Extract entities from last message
    const entities = this.extractEntities(lastUserMessage.content);

    // Replace pronouns with actual entities
    let expanded = input;

    // Replace "it" with workflow/file name
    if (/\bit\b/i.test(expanded) && entities.workflow) {
      expanded = expanded.replace(/\bit\b/i, entities.workflow);
    }

    // Replace "the results" with explicit reference
    if (/the results?/i.test(expanded) && entities.workflow) {
      expanded = expanded.replace(
        /the results?/i,
        `the results of ${entities.workflow}`
      );
    }

    // Replace "last workflow" with actual workflow name
    if (/last workflow/i.test(expanded) && entities.workflow) {
      expanded = expanded.replace(/last workflow/i, entities.workflow);
    }

    return expanded;
  }

  /**
   * Extract entities from message (workflow names, agent names, etc.)
   */
  private extractEntities(message: string): {
    workflow?: string;
    agent?: string;
    file?: string;
  } {
    const entities: any = {};

    // Workflow patterns
    const workflowMatch = message.match(/workflow\s+(?:run\s+)?([a-z0-9-]+\.ya?ml)/i);
    if (workflowMatch) {
      entities.workflow = workflowMatch[1];
    }

    // Agent patterns
    const agentMatch = message.match(/agent\s+([a-z0-9-]+)/i);
    if (agentMatch) {
      entities.agent = agentMatch[1];
    }

    // File patterns
    const fileMatch = message.match(/([a-z0-9-_/]+\.[a-z]+)/i);
    if (fileMatch) {
      entities.file = fileMatch[1];
    }

    return entities;
  }
}
```

**Integration:**

File: `src/cli/interactive/REPLSession.ts`

```typescript
import { ContextAwareIntentClassifier } from '../../nlp/ContextAwareIntentClassifier.js';

export class REPLSession {
  private nlClassifier: ContextAwareIntentClassifier;

  constructor() {
    this.conversationContext = new ConversationContext();
    this.nlClassifier = new ContextAwareIntentClassifier(this.conversationContext);
  }

  private async processInput(input: string): Promise<void> {
    // Classify with context awareness
    const classification = await this.nlClassifier.classify(input);

    if (classification.intent === 'chat') {
      await this.handleChatQuery(input);
    } else {
      await this.handleCommandQuery(classification);
    }

    // Save to conversation history
    await this.conversationContext.addMessage({
      role: 'user',
      content: input,
      timestamp: Date.now()
    });
  }
}
```

**Testing:**
```typescript
// src/nlp/__tests__/ContextAwareIntentClassifier.test.ts

describe('ContextAwareIntentClassifier', () => {
  let classifier: ContextAwareIntentClassifier;
  let context: ConversationContext;

  beforeEach(() => {
    context = new ConversationContext();
    classifier = new ContextAwareIntentClassifier(context);
  });

  it('should use base classification for non-contextual queries', async () => {
    const result = await classifier.classify('list agents');

    expect(result.usedContext).toBeUndefined();
    expect(result.intent).toBe('list_agents');
  });

  it('should detect contextual references', () => {
    expect(classifier['containsReference']('show me the results')).toBe(true);
    expect(classifier['containsReference']('run it again')).toBe(true);
    expect(classifier['containsReference']('what is the status')).toBe(true);
    expect(classifier['containsReference']('list agents')).toBe(false);
  });

  it('should expand query with workflow context', async () => {
    // Add previous message with workflow
    await context.addMessage({
      role: 'user',
      content: 'run workflow security-audit.yaml',
      timestamp: Date.now()
    });

    const result = await classifier.classify('show me the results');

    expect(result.metadata.usedContext).toBe(true);
    expect(result.metadata.expandedQuery).toContain('security-audit.yaml');
  });

  it('should replace pronouns with entities', async () => {
    await context.addMessage({
      role: 'user',
      content: 'run workflow test.yaml',
      timestamp: Date.now()
    });

    const expanded = await classifier['expandWithContext'](
      'run it again',
      await context.getHistory(5)
    );

    expect(expanded).toBe('run test.yaml again');
  });

  it('should handle missing context gracefully', async () => {
    const result = await classifier.classify('show me the results');

    // No context available, should still classify
    expect(result.metadata.usedContext).toBe(true);
    expect(result.metadata.contextMessages).toBe(0);
  });
});
```

**Time Estimate:** 0.5 days

---

### 2. Fuzzy Matching for Typo Tolerance (P0 - Must Have)

**Current Problem:**
```
ax> list agants
‚ùå Error: Unknown command "list agants"

ax> run secruity audit
‚ùå Error: Unknown workflow "secruity"
```

**Desired Behavior:**
```
ax> list agants
üí° Did you mean: list agents
‚úÖ Executes: list agents

ax> run secruity audit
üí° Did you mean: security-audit.yaml
‚úÖ Executes: run workflow security-audit.yaml
```

**Implementation:**

File: `src/nlp/FuzzyMatcher.ts` (new file)

```typescript
import { distance as levenshteinDistance } from 'fastest-levenshtein';

export interface FuzzyMatchResult {
  match: string;
  score: number;
  distance: number;
}

export class FuzzyMatcher {
  private readonly maxDistance: number = 3; // Maximum Levenshtein distance
  private readonly minSimilarity: number = 0.6; // Minimum similarity score (0-1)

  /**
   * Find closest match for input among candidates
   * @param input - User input (potentially misspelled)
   * @param candidates - List of valid options
   * @param threshold - Minimum similarity threshold (default 0.6)
   * @returns Best match or null if no match above threshold
   */
  findClosestMatch(
    input: string,
    candidates: string[],
    threshold: number = this.minSimilarity
  ): FuzzyMatchResult | null {
    const inputLower = input.toLowerCase().trim();

    let bestMatch: FuzzyMatchResult | null = null;
    let bestScore = 0;

    for (const candidate of candidates) {
      const candidateLower = candidate.toLowerCase().trim();

      // Calculate Levenshtein distance
      const dist = levenshteinDistance(inputLower, candidateLower);

      // Skip if distance too large
      if (dist > this.maxDistance) {
        continue;
      }

      // Calculate similarity score (1.0 = exact match, 0.0 = completely different)
      const maxLen = Math.max(inputLower.length, candidateLower.length);
      const score = 1 - (dist / maxLen);

      // Update best match if score is better
      if (score > bestScore && score >= threshold) {
        bestScore = score;
        bestMatch = {
          match: candidate,
          score,
          distance: dist
        };
      }
    }

    return bestMatch;
  }

  /**
   * Find all matches above threshold (sorted by score)
   */
  findAllMatches(
    input: string,
    candidates: string[],
    threshold: number = this.minSimilarity
  ): FuzzyMatchResult[] {
    const inputLower = input.toLowerCase().trim();
    const matches: FuzzyMatchResult[] = [];

    for (const candidate of candidates) {
      const candidateLower = candidate.toLowerCase().trim();
      const dist = levenshteinDistance(inputLower, candidateLower);

      if (dist > this.maxDistance) {
        continue;
      }

      const maxLen = Math.max(inputLower.length, candidateLower.length);
      const score = 1 - (dist / maxLen);

      if (score >= threshold) {
        matches.push({ match: candidate, score, distance: dist });
      }
    }

    // Sort by score (descending)
    return matches.sort((a, b) => b.score - a.score);
  }

  /**
   * Check if two strings are approximately equal
   */
  areApproximatelyEqual(str1: string, str2: string, maxDist: number = 2): boolean {
    const dist = levenshteinDistance(
      str1.toLowerCase().trim(),
      str2.toLowerCase().trim()
    );
    return dist <= maxDist;
  }
}
```

**Integration with IntentClassifier:**

File: `src/nlp/ContextAwareIntentClassifier.ts`

```typescript
import { FuzzyMatcher } from './FuzzyMatcher.js';

export class ContextAwareIntentClassifier extends IntentClassifier {
  private fuzzyMatcher: FuzzyMatcher;

  constructor(conversationContext: ConversationContext) {
    super();
    this.conversationContext = conversationContext;
    this.fuzzyMatcher = new FuzzyMatcher();
  }

  async classify(input: string): Promise<ClassificationResult> {
    // Try base classification first
    let result = await super.classify(input);

    // If confidence is low, try fuzzy matching
    if (result.confidence < 0.7) {
      const corrected = await this.fuzzyCorrect(input);

      if (corrected) {
        console.log(chalk.yellow(`üí° Did you mean: ${corrected.match}`));

        // Re-classify with corrected input
        result = await super.classify(corrected.match);
        result.metadata = {
          ...result.metadata,
          fuzzyMatched: true,
          originalInput: input,
          correctedInput: corrected.match,
          fuzzyScore: corrected.score
        };
      }
    }

    return result;
  }

  /**
   * Attempt fuzzy correction of user input
   */
  private async fuzzyCorrect(input: string): Promise<FuzzyMatchResult | null> {
    // Get known commands
    const knownCommands = [
      'list agents',
      'run workflow',
      'show status',
      'memory search',
      'provider status',
      // ... all known command patterns
    ];

    // Try fuzzy match against known commands
    const match = this.fuzzyMatcher.findClosestMatch(input, knownCommands, 0.6);

    if (match) {
      return match;
    }

    // Try fuzzy match on individual words
    const words = input.split(/\s+/);
    const correctedWords: string[] = [];
    let hasCorrected = false;

    for (const word of words) {
      const wordMatch = this.fuzzyMatcher.findClosestMatch(
        word,
        ['agents', 'workflow', 'status', 'memory', 'provider', 'security', 'audit'],
        0.7
      );

      if (wordMatch && wordMatch.distance > 0) {
        correctedWords.push(wordMatch.match);
        hasCorrected = true;
      } else {
        correctedWords.push(word);
      }
    }

    if (hasCorrected) {
      return {
        match: correctedWords.join(' '),
        score: 0.8,
        distance: 1
      };
    }

    return null;
  }
}
```

**Testing:**
```typescript
// src/nlp/__tests__/FuzzyMatcher.test.ts

describe('FuzzyMatcher', () => {
  const matcher = new FuzzyMatcher();

  it('should find exact match', () => {
    const result = matcher.findClosestMatch('agents', ['agents', 'workflows', 'status']);

    expect(result).not.toBeNull();
    expect(result!.match).toBe('agents');
    expect(result!.score).toBe(1.0);
    expect(result!.distance).toBe(0);
  });

  it('should match with 1 character typo', () => {
    const result = matcher.findClosestMatch('agants', ['agents', 'workflows']);

    expect(result).not.toBeNull();
    expect(result!.match).toBe('agents');
    expect(result!.distance).toBe(1);
    expect(result!.score).toBeGreaterThan(0.8);
  });

  it('should match with multiple typos (within threshold)', () => {
    const result = matcher.findClosestMatch('secruity', ['security', 'quality', 'audit']);

    expect(result).not.toBeNull();
    expect(result!.match).toBe('security');
    expect(result!.distance).toBeLessThanOrEqual(3);
  });

  it('should return null for completely different strings', () => {
    const result = matcher.findClosestMatch('xyz', ['agents', 'workflows']);

    expect(result).toBeNull();
  });

  it('should find all matches above threshold', () => {
    const results = matcher.findAllMatches('agent', ['agents', 'agent', 'reagent']);

    expect(results.length).toBeGreaterThan(0);
    expect(results[0].match).toBe('agent'); // Exact match first
    expect(results).toEqual(
      expect.arrayContaining([
        expect.objectContaining({ match: 'agent' }),
        expect.objectContaining({ match: 'agents' })
      ])
    );
  });

  it('should check approximate equality', () => {
    expect(matcher.areApproximatelyEqual('agent', 'agents', 1)).toBe(true);
    expect(matcher.areApproximatelyEqual('workflow', 'workflows', 1)).toBe(true);
    expect(matcher.areApproximatelyEqual('test', 'production', 2)).toBe(false);
  });
});
```

**Dependencies:**
```bash
npm install fastest-levenshtein
```

**Time Estimate:** 0.5 days

---

### 3. Confidence-Based Clarification (P0 - Must Have)

**Current Problem:**
```
ax> run audit
‚úÖ Executes: security-audit.yaml (but user meant quality-audit.yaml)
```

**Desired Behavior:**
```
ax> run audit
‚ùì Multiple workflows match "audit":
  1. security-audit.yaml
  2. quality-audit.yaml
  3. performance-audit.yaml

Which one? (1-3): 2
‚úÖ Executes: quality-audit.yaml
```

**Implementation:**

File: `src/nlp/ClarificationHandler.ts` (new file)

```typescript
import inquirer from 'inquirer';
import chalk from 'chalk';

export interface ClarificationRequest {
  query: string;
  candidates: string[];
  type: 'workflow' | 'agent' | 'command' | 'file';
}

export class ClarificationHandler {
  /**
   * Prompt user to clarify ambiguous input
   * @param request - Clarification request with candidates
   * @returns Selected option
   */
  async clarify(request: ClarificationRequest): Promise<string> {
    console.log(chalk.yellow(`\n‚ùì Multiple ${request.type}s match "${request.query}":\n`));

    const choices = request.candidates.map((candidate, index) => ({
      name: `${index + 1}. ${candidate}`,
      value: candidate
    }));

    choices.push({
      name: chalk.gray('0. Cancel'),
      value: '__CANCEL__'
    });

    const answer = await inquirer.prompt<{ selection: string }>([
      {
        type: 'list',
        name: 'selection',
        message: `Which ${request.type}?`,
        choices
      }
    ]);

    if (answer.selection === '__CANCEL__') {
      throw new Error('User cancelled clarification');
    }

    return answer.selection;
  }

  /**
   * Check if clarification is needed
   * @param candidates - Number of matching candidates
   * @param confidence - Classification confidence (0-1)
   * @returns True if clarification needed
   */
  needsClarification(candidates: number, confidence: number): boolean {
    // Clarify if multiple matches and low confidence
    return candidates > 1 && confidence < 0.7;
  }

  /**
   * Display "Did you mean" suggestion
   */
  async suggestCorrection(original: string, suggestion: string): Promise<boolean> {
    const answer = await inquirer.prompt<{ confirm: boolean }>([
      {
        type: 'confirm',
        name: 'confirm',
        message: chalk.yellow(`Did you mean "${suggestion}"?`),
        default: true
      }
    ]);

    return answer.confirm;
  }
}
```

**Integration:**

File: `src/nlp/ContextAwareIntentClassifier.ts`

```typescript
import { ClarificationHandler } from './ClarificationHandler.js';

export class ContextAwareIntentClassifier extends IntentClassifier {
  private clarificationHandler: ClarificationHandler;

  async classify(input: string): Promise<ClassificationResult> {
    const result = await super.classify(input);

    // Check if clarification needed
    if (this.clarificationHandler.needsClarification(
      result.metadata?.candidateCount || 0,
      result.confidence
    )) {
      const candidates = result.metadata?.candidates || [];

      const selected = await this.clarificationHandler.clarify({
        query: input,
        candidates,
        type: this.inferType(result.intent)
      });

      // Re-classify with selected option
      return await super.classify(selected);
    }

    return result;
  }

  private inferType(intent: Intent): 'workflow' | 'agent' | 'command' | 'file' {
    if (intent.includes('workflow')) return 'workflow';
    if (intent.includes('agent')) return 'agent';
    if (intent.includes('file')) return 'file';
    return 'command';
  }
}
```

**Testing:**
```typescript
// src/nlp/__tests__/ClarificationHandler.test.ts

describe('ClarificationHandler', () => {
  const handler = new ClarificationHandler();

  it('should determine clarification is needed', () => {
    expect(handler.needsClarification(3, 0.5)).toBe(true);
    expect(handler.needsClarification(3, 0.9)).toBe(false);
    expect(handler.needsClarification(1, 0.5)).toBe(false);
  });

  it('should prompt for clarification', async () => {
    // Mock inquirer
    vi.spyOn(inquirer, 'prompt').mockResolvedValue({ selection: 'security-audit.yaml' });

    const result = await handler.clarify({
      query: 'audit',
      candidates: ['security-audit.yaml', 'quality-audit.yaml'],
      type: 'workflow'
    });

    expect(result).toBe('security-audit.yaml');
  });

  it('should handle cancellation', async () => {
    vi.spyOn(inquirer, 'prompt').mockResolvedValue({ selection: '__CANCEL__' });

    await expect(
      handler.clarify({
        query: 'test',
        candidates: ['test1', 'test2'],
        type: 'workflow'
      })
    ).rejects.toThrow('User cancelled clarification');
  });

  it('should suggest corrections', async () => {
    vi.spyOn(inquirer, 'prompt').mockResolvedValue({ confirm: true });

    const confirmed = await handler.suggestCorrection('agants', 'agents');

    expect(confirmed).toBe(true);
  });
});
```

**Time Estimate:** 0.25 days

---

### 4. Learning from User Corrections (P1 - Nice to Have)

**Current Problem:**
```
ax> run security check
‚ùå Unknown workflow

ax> run security-audit.yaml
‚úÖ Works

(Next time)
ax> run security check
‚ùå Still unknown (didn't learn)
```

**Desired Behavior:**
```
ax> run security check
‚ùå Unknown workflow

ax> run security-audit.yaml
‚úÖ Works
üíæ Learned: "security check" ‚Üí "security-audit.yaml"

(Next time)
ax> run security check
‚úÖ Remembered: security-audit.yaml
```

**Implementation:**

File: `src/nlp/IntentLearner.ts` (new file)

```typescript
import Database from 'better-sqlite3';
import { getDatabase } from '../database/connection.js';

export interface LearningEntry {
  userInput: string;
  predictedIntent: string;
  actualIntent: string;
  confidence: number;
  timestamp: number;
}

export class IntentLearner {
  private db: Database.Database;

  constructor() {
    this.db = getDatabase();
    this.initializeSchema();
  }

  private initializeSchema(): void {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS intent_corrections (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_input TEXT NOT NULL,
        predicted_intent TEXT NOT NULL,
        actual_intent TEXT NOT NULL,
        confidence REAL NOT NULL,
        timestamp INTEGER NOT NULL
      );

      CREATE INDEX IF NOT EXISTS idx_corrections_user_input
        ON intent_corrections(user_input);
    `);
  }

  /**
   * Record a correction (when user rephrases query)
   */
  async recordCorrection(
    userInput: string,
    predictedIntent: string,
    actualIntent: string,
    confidence: number
  ): Promise<void> {
    this.db.prepare(`
      INSERT INTO intent_corrections (
        user_input, predicted_intent, actual_intent, confidence, timestamp
      ) VALUES (?, ?, ?, ?, ?)
    `).run(userInput, predictedIntent, actualIntent, confidence, Date.now());

    console.log(chalk.gray(`üíæ Learned: "${userInput}" ‚Üí "${actualIntent}"`));
  }

  /**
   * Get learned pattern for user input
   */
  async getLearnedIntent(userInput: string): Promise<string | null> {
    const row = this.db.prepare(`
      SELECT actual_intent, COUNT(*) as frequency
      FROM intent_corrections
      WHERE user_input = ?
      GROUP BY actual_intent
      ORDER BY frequency DESC, timestamp DESC
      LIMIT 1
    `).get(userInput) as { actual_intent: string; frequency: number } | undefined;

    return row?.actual_intent || null;
  }

  /**
   * Get improved patterns for intent (based on learning history)
   */
  async getImprovedPatterns(intent: string): Promise<RegExp[]> {
    const learnings = await this.getLearnings(intent, 20);

    const patterns: RegExp[] = [];

    for (const learning of learnings) {
      // Extract keywords from user input
      const words = learning.toLowerCase().split(/\s+/);

      // Create pattern from keywords
      const pattern = new RegExp(words.join('\\s+'), 'i');
      patterns.push(pattern);
    }

    return patterns;
  }

  /**
   * Get all learnings for an intent
   */
  private async getLearnings(intent: string, limit: number = 20): Promise<string[]> {
    const rows = this.db.prepare(`
      SELECT DISTINCT user_input
      FROM intent_corrections
      WHERE actual_intent = ?
      ORDER BY timestamp DESC
      LIMIT ?
    `).all(intent, limit) as { user_input: string }[];

    return rows.map(r => r.user_input);
  }

  /**
   * Get learning statistics
   */
  async getStats(): Promise<{
    totalCorrections: number;
    uniqueInputs: number;
    avgConfidence: number;
  }> {
    const row = this.db.prepare(`
      SELECT
        COUNT(*) as total_corrections,
        COUNT(DISTINCT user_input) as unique_inputs,
        AVG(confidence) as avg_confidence
      FROM intent_corrections
    `).get() as { total_corrections: number; unique_inputs: number; avg_confidence: number };

    return {
      totalCorrections: row.total_corrections,
      uniqueInputs: row.unique_inputs,
      avgConfidence: row.avg_confidence
    };
  }
}
```

**Integration:**

File: `src/nlp/ContextAwareIntentClassifier.ts`

```typescript
import { IntentLearner } from './IntentLearner.js';

export class ContextAwareIntentClassifier extends IntentClassifier {
  private learner: IntentLearner;

  async classify(input: string): Promise<ClassificationResult> {
    // Check if we've learned this pattern before
    const learned = await this.learner.getLearnedIntent(input);

    if (learned) {
      console.log(chalk.green(`‚úÖ Remembered: ${learned}`));
      return await super.classify(learned);
    }

    // Standard classification
    const result = await super.classify(input);

    // If confidence is low but we have a correction, learn it
    if (result.confidence < 0.7 && result.metadata?.correctedInput) {
      await this.learner.recordCorrection(
        input,
        result.intent,
        result.metadata.correctedInput,
        result.confidence
      );
    }

    return result;
  }
}
```

**Testing:**
```typescript
// src/nlp/__tests__/IntentLearner.test.ts

describe('IntentLearner', () => {
  let learner: IntentLearner;

  beforeEach(() => {
    learner = new IntentLearner();
    // Clear test data
    learner['db'].exec('DELETE FROM intent_corrections');
  });

  it('should record correction', async () => {
    await learner.recordCorrection(
      'run security check',
      'unknown',
      'run workflow security-audit.yaml',
      0.5
    );

    const learned = await learner.getLearnedIntent('run security check');
    expect(learned).toBe('run workflow security-audit.yaml');
  });

  it('should return most frequent correction', async () => {
    // Record multiple corrections for same input
    await learner.recordCorrection('audit', 'unknown', 'security-audit.yaml', 0.5);
    await learner.recordCorrection('audit', 'unknown', 'security-audit.yaml', 0.5);
    await learner.recordCorrection('audit', 'unknown', 'quality-audit.yaml', 0.5);

    const learned = await learner.getLearnedIntent('audit');
    expect(learned).toBe('security-audit.yaml'); // Most frequent
  });

  it('should generate improved patterns', async () => {
    await learner.recordCorrection('run check', 'unknown', 'workflow_run', 0.5);
    await learner.recordCorrection('execute test', 'unknown', 'workflow_run', 0.5);

    const patterns = await learner.getImprovedPatterns('workflow_run');

    expect(patterns.length).toBe(2);
    expect(patterns[0].test('run check')).toBe(true);
    expect(patterns[1].test('execute test')).toBe(true);
  });

  it('should return learning statistics', async () => {
    await learner.recordCorrection('input1', 'pred1', 'actual1', 0.6);
    await learner.recordCorrection('input2', 'pred2', 'actual2', 0.8);
    await learner.recordCorrection('input1', 'pred1', 'actual1', 0.7);

    const stats = await learner.getStats();

    expect(stats.totalCorrections).toBe(3);
    expect(stats.uniqueInputs).toBe(2);
    expect(stats.avgConfidence).toBeCloseTo(0.7, 1);
  });
});
```

**Database Migration:**

File: `src/migrations/014_create_intent_corrections.sql` (new file)

```sql
-- Intent learning table
CREATE TABLE IF NOT EXISTS intent_corrections (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  user_input TEXT NOT NULL,
  predicted_intent TEXT NOT NULL,
  actual_intent TEXT NOT NULL,
  confidence REAL NOT NULL,
  timestamp INTEGER NOT NULL
);

CREATE INDEX IF NOT EXISTS idx_corrections_user_input
  ON intent_corrections(user_input);

CREATE INDEX IF NOT EXISTS idx_corrections_actual_intent
  ON intent_corrections(actual_intent);
```

**Time Estimate:** 0.25 days

---

## üìä CONSOLIDATED TIMELINE

### Day 1: Context Awareness + Fuzzy Matching
**Morning (4 hours):**
- Implement ContextAwareIntentClassifier
- Add reference detection and context expansion
- Unit tests

**Afternoon (4 hours):**
- Implement FuzzyMatcher with Levenshtein distance
- Integrate with intent classifier
- Unit tests

### Day 2: Clarification + Learning
**Morning (2 hours):**
- Implement ClarificationHandler
- Add ambiguity detection
- Unit tests

**Afternoon (2 hours):**
- Implement IntentLearner
- Create database schema
- Integration testing
- Manual QA

---

## ‚úÖ SUCCESS CRITERIA

### Functional
- [ ] Context-aware queries work (pronouns resolved)
- [ ] Typos auto-corrected (Levenshtein ‚â§3)
- [ ] Ambiguous queries trigger clarification
- [ ] System learns from corrections
- [ ] Learned patterns persist across sessions

### Quality
- [ ] Classification accuracy >90% (up from 70%)
- [ ] Unit test coverage >80%
- [ ] All tests passing
- [ ] 0 P0 bugs
- [ ] <5 P1 bugs

### Performance
- [ ] Context expansion <50ms
- [ ] Fuzzy matching <100ms
- [ ] Learning lookup <10ms

---

## üìÅ DELIVERABLES

### New Files
- `src/nlp/ContextAwareIntentClassifier.ts`
- `src/nlp/FuzzyMatcher.ts`
- `src/nlp/ClarificationHandler.ts`
- `src/nlp/IntentLearner.ts`
- `src/nlp/__tests__/ContextAwareIntentClassifier.test.ts`
- `src/nlp/__tests__/FuzzyMatcher.test.ts`
- `src/nlp/__tests__/ClarificationHandler.test.ts`
- `src/nlp/__tests__/IntentLearner.test.ts`
- `src/migrations/014_create_intent_corrections.sql`

### Modified Files
- `src/cli/interactive/REPLSession.ts` (use ContextAwareIntentClassifier)
- `src/cli/interactive/IntentClassifier.ts` (base class for context-aware variant)

### Dependencies
- `fastest-levenshtein` (fuzzy matching)
- `inquirer` (clarification prompts - already installed)

### Documentation
- Update `docs/natural-language.md` with context-aware examples
- Add fuzzy matching examples
- Add clarification flow documentation
- Add learning system documentation

---

## üöÄ READY TO EXECUTE

This refinement plan enhances Natural Language processing to production-grade quality with context awareness, typo tolerance, intelligent clarification, and learning capabilities.

**Next steps:**
1. Create feature branch: `git checkout -b feature/natural-language-refinements`
2. Install dependencies: `npm install fastest-levenshtein`
3. Start with Day 1 morning task (context awareness)
4. Follow test-driven development
5. Create PR at end of Day 2

**Let's make Natural Language exceptional! üéâ**
