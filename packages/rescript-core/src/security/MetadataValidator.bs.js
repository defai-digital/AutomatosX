// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Js_json from "rescript/lib/es6/js_json.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

var taskMetadataSchema = [
  {
    name: "taskId",
    fieldType: "String",
    required: true,
    maxLength: 256,
    maxItems: undefined,
    allowedValues: undefined
  },
  {
    name: "manifestVersion",
    fieldType: "String",
    required: false,
    maxLength: 64,
    maxItems: undefined,
    allowedValues: undefined
  },
  {
    name: "attempt",
    fieldType: "Number",
    required: false,
    maxLength: undefined,
    maxItems: undefined,
    allowedValues: undefined
  },
  {
    name: "retryCount",
    fieldType: "Number",
    required: false,
    maxLength: undefined,
    maxItems: undefined,
    allowedValues: undefined
  },
  {
    name: "requestedBy",
    fieldType: "String",
    required: false,
    maxLength: 128,
    maxItems: undefined,
    allowedValues: undefined
  },
  {
    name: "tags",
    fieldType: "Array",
    required: false,
    maxLength: undefined,
    maxItems: 10,
    allowedValues: undefined
  },
  {
    name: "priority",
    fieldType: "String",
    required: false,
    maxLength: 16,
    maxItems: undefined,
    allowedValues: [
      "low",
      "medium",
      "high",
      "critical"
    ]
  }
];

function getFieldDefinition(schema, fieldName) {
  return Caml_option.undefined_to_opt(schema.find(function (field) {
                  return field.name === fieldName;
                }));
}

var MetadataSchema = {
  taskMetadataSchema: taskMetadataSchema,
  getFieldDefinition: getFieldDefinition
};

function isValid(result) {
  if (typeof result !== "object") {
    return true;
  } else {
    return false;
  }
}

function getErrors(result) {
  if (typeof result !== "object") {
    return [];
  } else {
    return result._0;
  }
}

function combine(results) {
  var allErrors = results.reduce((function (acc, result) {
          if (typeof result !== "object") {
            return acc;
          } else {
            return acc.concat(result._0);
          }
        }), []);
  if (allErrors.length === 0) {
    return "Valid";
  } else {
    return {
            TAG: "Invalid",
            _0: allErrors
          };
  }
}

var ValidationResult = {
  isValid: isValid,
  getErrors: getErrors,
  combine: combine
};

function escapeHtml(input) {
  return input.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\"/g, "&quot;").replace(/'/g, "&#x27;").replace(/\//g, "&#x2F;");
}

function sanitizeString(input) {
  var beforeInjection = input.split("\\n")[0];
  return escapeHtml(beforeInjection.trim().replace(/[\r\n]/g, "").replace(/\\r/g, "").replace(/\\t/g, ""));
}

function sanitizeMetadata(metadata) {
  var sanitized = {};
  Object.keys(metadata).forEach(function (key) {
        var value = Js_dict.get(metadata, key);
        if (value === undefined) {
          return ;
        }
        var str = Js_json.classify(value);
        if (typeof str !== "object") {
          sanitized[key] = value;
          return ;
        }
        switch (str.TAG) {
          case "JSONString" :
              var sanitizedStr = sanitizeString(str._0);
              sanitized[key] = sanitizedStr;
              return ;
          case "JSONObject" :
              var sanitizedObj = sanitizeMetadata(str._0);
              sanitized[key] = sanitizedObj;
              return ;
          case "JSONArray" :
              var sanitizedArr = str._0.map(function (item) {
                    var str = Js_json.classify(item);
                    if (typeof str !== "object" || str.TAG !== "JSONString") {
                      return item;
                    } else {
                      return sanitizeString(str._0);
                    }
                  });
              sanitized[key] = sanitizedArr;
              return ;
          default:
            sanitized[key] = value;
            return ;
        }
      });
  return sanitized;
}

var Sanitizer = {
  escapeHtml: escapeHtml,
  sanitizeString: sanitizeString,
  sanitizeMetadata: sanitizeMetadata
};

function calculateSize(metadata) {
  try {
    return JSON.stringify(metadata).length;
  }
  catch (exn){
    return 0;
  }
}

function validateSize(metadata) {
  var size = calculateSize(metadata);
  if (size > 10240) {
    return {
            TAG: "Invalid",
            _0: ["Metadata size (" + size.toString() + " bytes) exceeds maximum allowed (" + (10240).toString() + " bytes)"]
          };
  } else {
    return "Valid";
  }
}

var SizeValidator = {
  maxMetadataSizeBytes: 10240,
  calculateSize: calculateSize,
  validateSize: validateSize
};

function validateField(fieldDef, value) {
  var match = fieldDef.required;
  if (value === undefined) {
    if (match) {
      return {
              TAG: "Invalid",
              _0: ["Required field '" + fieldDef.name + "' is missing"]
            };
    } else {
      return "Valid";
    }
  }
  var match$1 = Js_json.classify(value);
  var match$2 = fieldDef.fieldType;
  var exit = 0;
  if (typeof match$1 !== "object") {
    switch (match$1) {
      case "JSONFalse" :
      case "JSONTrue" :
          exit = 2;
          break;
      case "JSONNull" :
          break;
      
    }
  } else {
    switch (match$1.TAG) {
      case "JSONString" :
          if (match$2 === "String") {
            var maxLen = fieldDef.maxLength;
            if (maxLen !== undefined && match$1._0.length > maxLen) {
              return {
                      TAG: "Invalid",
                      _0: ["Field '" + fieldDef.name + "' exceeds maximum length (" + maxLen.toString() + ")"]
                    };
            } else {
              return "Valid";
            }
          }
          break;
      case "JSONNumber" :
          if (match$2 === "Number") {
            return "Valid";
          }
          break;
      case "JSONObject" :
          if (match$2 === "Object") {
            return "Valid";
          }
          break;
      case "JSONArray" :
          if (match$2 === "Array") {
            var maxItems = fieldDef.maxItems;
            if (maxItems !== undefined && match$1._0.length > maxItems) {
              return {
                      TAG: "Invalid",
                      _0: ["Field '" + fieldDef.name + "' array exceeds maximum items (" + maxItems.toString() + ")"]
                    };
            } else {
              return "Valid";
            }
          }
          break;
      
    }
  }
  if (exit === 2 && match$2 === "Boolean") {
    return "Valid";
  }
  var match$3 = fieldDef.fieldType;
  var tmp;
  switch (match$3) {
    case "String" :
        tmp = "string";
        break;
    case "Number" :
        tmp = "number";
        break;
    case "Boolean" :
        tmp = "boolean";
        break;
    case "Array" :
        tmp = "array";
        break;
    case "Object" :
        tmp = "object";
        break;
    
  }
  return {
          TAG: "Invalid",
          _0: ["Field '" + fieldDef.name + "' has invalid type (expected " + tmp + ")"]
        };
}

function validate(schema, metadata) {
  var fieldResults = schema.map(function (fieldDef) {
        var value = Js_dict.get(metadata, fieldDef.name);
        return validateField(fieldDef, value);
      });
  return combine(fieldResults);
}

var SchemaValidator = {
  validateField: validateField,
  validate: validate
};

function whitelist(schema, metadata) {
  var whitelisted = {};
  var allowedFields = schema.map(function (field) {
        return field.name;
      });
  Object.keys(metadata).forEach(function (key) {
        if (!allowedFields.includes(key)) {
          return ;
        }
        var value = Js_dict.get(metadata, key);
        if (value !== undefined) {
          whitelisted[key] = value;
          return ;
        }
        
      });
  return whitelisted;
}

function getRemovedFields(schema, metadata) {
  var allowedFields = schema.map(function (field) {
        return field.name;
      });
  return Object.keys(metadata).filter(function (key) {
              return !allowedFields.some(function (field) {
                          return field === key;
                        });
            });
}

var FieldWhitelister = {
  whitelist: whitelist,
  getRemovedFields: getRemovedFields
};

function validate$1(schema, metadata) {
  var sizeValidation = validateSize(metadata);
  var removedFields = getRemovedFields(schema, metadata);
  var whitelisted = whitelist(schema, metadata);
  var schemaValidation = validate(schema, whitelisted);
  var sanitized = sanitizeMetadata(whitelisted);
  var allErrors = combine([
        sizeValidation,
        schemaValidation
      ]);
  var warnings = removedFields.length > 0 ? ["Removed " + removedFields.length.toString() + " unknown fields: " + removedFields.join(", ")] : [];
  return {
          valid: isValid(allErrors),
          errors: getErrors(allErrors),
          warnings: warnings,
          sanitized: sanitized
        };
}

function isValid$1(schema, metadata) {
  return validate$1(schema, metadata).valid;
}

function validateAndSanitize(schema, metadata) {
  var report = validate$1(schema, metadata);
  if (report.valid) {
    return report.sanitized;
  } else {
    return {};
  }
}

var MetadataValidator = {
  validate: validate$1,
  isValid: isValid$1,
  validateAndSanitize: validateAndSanitize
};

var validateMetadata = validate$1;

var isValidMetadata = isValid$1;

var whitelistFields = whitelist;

var calculateMetadataSize = calculateSize;

var maxMetadataSizeBytes = 10240;

export {
  MetadataSchema ,
  ValidationResult ,
  Sanitizer ,
  SizeValidator ,
  SchemaValidator ,
  FieldWhitelister ,
  MetadataValidator ,
  taskMetadataSchema ,
  escapeHtml ,
  sanitizeString ,
  sanitizeMetadata ,
  validateMetadata ,
  isValidMetadata ,
  validateAndSanitize ,
  whitelistFields ,
  calculateMetadataSize ,
  maxMetadataSizeBytes ,
}
/* No side effect */
