# AutomatosX v8.0.0 - Iterate Mode PRD

**Version:** 8.0.0
**Status:** Ready for Implementation
**Priority:** P1 (Important Gap)
**Timeline:** 1 week (Week 5 of 6-week roadmap)
**Effort:** 5 person-days

---

## Executive Summary

Iterate Mode enables autonomous problem-solving through intelligent retry loops with adaptive strategies and safety constraints. When a task fails, AutomatosX automatically analyzes the failure, selects a new approach, and retriesâ€”continuing until success or configured limits are reached.

**Impact:**
- **Autonomy:** Solves complex problems without human intervention
- **Resilience:** Automatic recovery from transient failures
- **Learning:** Improves strategies based on failure patterns
- **Safety:** Configurable risk tolerance prevents runaway execution

**Success Criteria:**
- `ax run --iterate` enables autonomous retry loop
- Automatic failure analysis and strategy adaptation
- Safety levels: `permissive`, `normal`, `paranoid`
- Max iterations configurable (default: 10)
- >70% success rate on multi-step workflows
- <5s strategy selection latency

---

## Problem Statement

### Current State (v8.0.0)

Single execution, fails fast:
```bash
$ ax workflow run security-audit.yaml

Step 3 failed: Network timeout connecting to vulnerability database
âŒ Workflow failed at step 3/15
```

**Barriers:**
- Manual intervention required for transient failures
- No automatic retry with different approaches
- Lost context and progress on failure
- Human must analyze failure and rerun

### Target State (v7.6.1 Parity)

Autonomous retry loop with strategy adaptation:
```bash
$ ax run security-audit.yaml --iterate --safety normal --max-iterations 10

ðŸ”„ Iteration 1: Executing workflow
   Step 3 failed: Network timeout
   Analyzing failure... transient network error detected

ðŸ”„ Iteration 2: Retrying with backoff strategy
   Step 3 failed: Still timing out
   Analyzing failure... endpoint may be down

ðŸ”„ Iteration 3: Switching to alternative vulnerability source
   Step 3 succeeded âœ…
   Step 4-15 executing...

âœ… Workflow completed successfully after 3 iterations (5m 30s)
```

**Key Features:**
1. **Automatic Retry:** No manual intervention
2. **Strategy Adaptation:** Changes approach based on failure patterns
3. **Safety Constraints:** Prevents dangerous operations
4. **Progress Preservation:** Resumes from checkpoint
5. **Learning:** Improves future iterations

---

## Architecture

### System Components

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Iterate Mode Layer                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Iterate    â”‚â”€â”€â”€â–¶â”‚  Strategy    â”‚â”€â”€â”€â–¶â”‚    Safety    â”‚  â”‚
â”‚  â”‚   Engine     â”‚    â”‚  Selector    â”‚    â”‚  Evaluator   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                    â”‚                    â”‚          â”‚
â”‚         â–¼                    â–¼                    â–¼          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Failure    â”‚    â”‚  Iteration   â”‚    â”‚   Progress   â”‚  â”‚
â”‚  â”‚   Analyzer   â”‚    â”‚   History    â”‚    â”‚   Tracker    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                    â”‚                    â”‚          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                    â”‚                    â”‚
          â–¼                    â–¼                    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Existing v8.0.0 Infrastructure                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  WorkflowEngineV2  â”‚  CheckpointServiceV2  â”‚  AgentRuntime â”‚
â”‚  ProviderRouterV2  â”‚  ErrorAnalyzer        â”‚  Telemetry    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Core Components

#### 1. IterateEngine (`src/services/IterateEngine.ts`)

**Responsibilities:**
- Manage iteration loop (max iterations, timeout)
- Coordinate strategy selection and execution
- Track progress and history
- Decide when to stop (success, max iterations, safety limit)
- Preserve context across iterations

**Key Methods:**
```typescript
export interface IterateOptions {
  maxIterations: number;
  safetyLevel: 'permissive' | 'normal' | 'paranoid';
  timeout?: number; // Total time limit in ms
  checkpointInterval?: number; // Save checkpoint every N iterations
  strategySelector?: 'auto' | 'conservative' | 'aggressive';
  onIteration?: (iteration: IterationResult) => void;
}

export interface IterationResult {
  iteration: number;
  success: boolean;
  complete: boolean; // Workflow fully completed
  strategy: Strategy;
  error?: Error;
  progress: ProgressSnapshot;
  duration: number;
  metadata: Record<string, unknown>;
}

export interface IterateResult {
  success: boolean;
  iterations: number;
  totalDuration: number;
  finalStrategy: Strategy;
  history: IterationResult[];
  checkpoints: string[]; // Checkpoint IDs
}

export class IterateEngine {
  constructor(
    private workflowEngine: WorkflowEngineV2,
    private strategySelector: StrategySelector,
    private safetyEvaluator: SafetyEvaluator,
    private failureAnalyzer: FailureAnalyzer,
    private checkpointService: CheckpointServiceV2
  ) {}

  async iterate(
    workflowPath: string,
    options: IterateOptions
  ): Promise<IterateResult> {
    const startTime = Date.now();
    const iterations: IterationResult[] = [];
    let currentStrategy = await this.strategySelector.selectInitial();
    let checkpointId: string | undefined;

    for (let i = 1; i <= options.maxIterations; i++) {
      // Check timeout
      if (options.timeout && Date.now() - startTime > options.timeout) {
        throw new Error('Iterate timeout exceeded');
      }

      // Safety check before iteration
      const safetyCheck = await this.safetyEvaluator.evaluate(
        currentStrategy,
        options.safetyLevel,
        iterations
      );

      if (!safetyCheck.safe) {
        throw new Error(`Safety violation: ${safetyCheck.reason}`);
      }

      // Execute iteration
      const result = await this.executeIteration(
        workflowPath,
        currentStrategy,
        checkpointId,
        i
      );

      iterations.push(result);

      // Checkpoint if configured
      if (options.checkpointInterval && i % options.checkpointInterval === 0) {
        checkpointId = await this.createCheckpoint(workflowPath, result);
      }

      // Success - workflow complete
      if (result.success && result.complete) {
        return {
          success: true,
          iterations: i,
          totalDuration: Date.now() - startTime,
          finalStrategy: currentStrategy,
          history: iterations,
          checkpoints: [checkpointId].filter(Boolean) as string[]
        };
      }

      // Failure - analyze and adapt strategy
      if (!result.success) {
        const analysis = await this.failureAnalyzer.analyze(
          result.error!,
          result.progress,
          iterations
        );

        currentStrategy = await this.strategySelector.selectNext(
          currentStrategy,
          analysis,
          iterations
        );

        console.log(`ðŸ”„ Iteration ${i} failed: ${result.error?.message}`);
        console.log(`   New strategy: ${currentStrategy.name}`);
      }
    }

    // Max iterations reached
    return {
      success: false,
      iterations: options.maxIterations,
      totalDuration: Date.now() - startTime,
      finalStrategy: currentStrategy,
      history: iterations,
      checkpoints: []
    };
  }

  private async executeIteration(
    workflowPath: string,
    strategy: Strategy,
    checkpointId: string | undefined,
    iteration: number
  ): Promise<IterationResult> {
    const startTime = Date.now();

    try {
      let result;
      if (checkpointId) {
        // Resume from checkpoint
        result = await this.workflowEngine.resumeFromCheckpoint(checkpointId);
      } else {
        // Execute from start with strategy config
        result = await this.workflowEngine.executeWorkflow(workflowPath, {
          strategy: strategy.config
        });
      }

      return {
        iteration,
        success: result.success,
        complete: result.completedSteps === result.totalSteps,
        strategy,
        progress: this.captureProgress(result),
        duration: Date.now() - startTime,
        metadata: result.metadata
      };
    } catch (error) {
      return {
        iteration,
        success: false,
        complete: false,
        strategy,
        error: error as Error,
        progress: this.captureProgress(null),
        duration: Date.now() - startTime,
        metadata: {}
      };
    }
  }
}
```

#### 2. StrategySelector (`src/services/StrategySelector.ts`)

**Responsibilities:**
- Select initial execution strategy
- Adapt strategy based on failure patterns
- Maintain strategy history
- Learn from past successes

**Strategies:**
```typescript
export interface Strategy {
  name: string;
  description: string;
  config: StrategyConfig;
  priority: number; // Higher = try first
  applicableErrors: string[]; // Error types this strategy handles
}

export interface StrategyConfig {
  timeout?: number;
  retryBackoff?: 'none' | 'linear' | 'exponential';
  parallelism?: number;
  fallbackProviders?: boolean;
  skipOptionalSteps?: boolean;
  useCache?: boolean;
  [key: string]: unknown;
}

export const BUILTIN_STRATEGIES: Strategy[] = [
  {
    name: 'default',
    description: 'Standard execution with retries',
    config: {
      timeout: 300000,
      retryBackoff: 'exponential',
      parallelism: 5,
      useCache: true
    },
    priority: 10,
    applicableErrors: []
  },
  {
    name: 'aggressive-timeout',
    description: 'Increase timeouts for slow operations',
    config: {
      timeout: 600000,
      retryBackoff: 'exponential',
      parallelism: 5,
      useCache: true
    },
    priority: 8,
    applicableErrors: ['timeout', 'ETIMEDOUT', 'ECONNRESET']
  },
  {
    name: 'fallback-providers',
    description: 'Use alternative AI providers',
    config: {
      timeout: 300000,
      retryBackoff: 'exponential',
      parallelism: 5,
      fallbackProviders: true,
      useCache: false // Force fresh attempt
    },
    priority: 7,
    applicableErrors: ['rate_limit', 'api_error', '429', '503']
  },
  {
    name: 'reduced-parallelism',
    description: 'Execute steps sequentially to avoid resource contention',
    config: {
      timeout: 300000,
      retryBackoff: 'linear',
      parallelism: 1,
      useCache: true
    },
    priority: 6,
    applicableErrors: ['resource_exhausted', 'EMFILE', 'ENOMEM']
  },
  {
    name: 'skip-optional',
    description: 'Skip optional steps to reach completion',
    config: {
      timeout: 300000,
      retryBackoff: 'exponential',
      parallelism: 5,
      skipOptionalSteps: true,
      useCache: true
    },
    priority: 5,
    applicableErrors: ['partial_failure', 'non_critical_error']
  }
];

export class StrategySelector {
  private strategyHistory: Map<string, number> = new Map(); // strategy -> success count

  async selectInitial(): Promise<Strategy> {
    // Always start with default strategy
    return BUILTIN_STRATEGIES.find(s => s.name === 'default')!;
  }

  async selectNext(
    previousStrategy: Strategy,
    failureAnalysis: FailureAnalysis,
    iterationHistory: IterationResult[]
  ): Promise<Strategy> {
    // Find strategies applicable to the error type
    const candidates = BUILTIN_STRATEGIES.filter(strategy =>
      strategy.applicableErrors.some(errorType =>
        failureAnalysis.errorType.includes(errorType)
      )
    );

    // If no specific strategy, try next highest priority
    if (candidates.length === 0) {
      const nextStrategy = BUILTIN_STRATEGIES
        .filter(s => s.priority < previousStrategy.priority)
        .sort((a, b) => b.priority - a.priority)[0];

      return nextStrategy || previousStrategy; // Fallback to same strategy
    }

    // Sort by success history and priority
    candidates.sort((a, b) => {
      const aSuccesses = this.strategyHistory.get(a.name) || 0;
      const bSuccesses = this.strategyHistory.get(b.name) || 0;

      if (aSuccesses !== bSuccesses) {
        return bSuccesses - aSuccesses; // More successes first
      }

      return b.priority - a.priority; // Higher priority first
    });

    return candidates[0];
  }

  recordSuccess(strategy: Strategy): void {
    const count = this.strategyHistory.get(strategy.name) || 0;
    this.strategyHistory.set(strategy.name, count + 1);
  }
}
```

#### 3. FailureAnalyzer (`src/services/FailureAnalyzer.ts`)

**Responsibilities:**
- Classify error types
- Identify failure patterns
- Determine if error is transient or permanent
- Extract actionable insights

**Implementation:**
```typescript
export interface FailureAnalysis {
  errorType: string; // 'timeout', 'rate_limit', 'network', 'auth', 'validation', etc.
  isTransient: boolean; // Can retry help?
  isPermanent: boolean; // No point retrying
  severity: 'low' | 'medium' | 'high' | 'critical';
  failedStep: string;
  failurePattern?: string; // Detected pattern across iterations
  suggestedActions: string[];
  metadata: Record<string, unknown>;
}

export class FailureAnalyzer {
  private readonly ERROR_PATTERNS = [
    { pattern: /timeout|ETIMEDOUT/i, type: 'timeout', transient: true },
    { pattern: /rate limit|429/i, type: 'rate_limit', transient: true },
    { pattern: /ECONNREFUSED|ENOTFOUND/i, type: 'network', transient: true },
    { pattern: /unauthorized|401|403/i, type: 'auth', transient: false },
    { pattern: /validation|invalid/i, type: 'validation', transient: false },
    { pattern: /ENOMEM|EMFILE/i, type: 'resource_exhausted', transient: true },
    { pattern: /503|502|504/i, type: 'service_unavailable', transient: true }
  ];

  async analyze(
    error: Error,
    progress: ProgressSnapshot,
    iterationHistory: IterationResult[]
  ): Promise<FailureAnalysis> {
    // Classify error
    const errorType = this.classifyError(error);
    const isTransient = this.isTransientError(errorType);
    const isPermanent = !isTransient;

    // Detect patterns across iterations
    const pattern = this.detectPattern(error, iterationHistory);

    // Generate suggested actions
    const suggestedActions = this.generateActions(
      errorType,
      isTransient,
      pattern
    );

    return {
      errorType,
      isTransient,
      isPermanent,
      severity: this.calculateSeverity(error, progress),
      failedStep: progress.lastCompletedStep || 'initialization',
      failurePattern: pattern,
      suggestedActions,
      metadata: {
        errorMessage: error.message,
        errorStack: error.stack,
        progress: progress.completedSteps / progress.totalSteps
      }
    };
  }

  private classifyError(error: Error): string {
    for (const { pattern, type } of this.ERROR_PATTERNS) {
      if (pattern.test(error.message)) {
        return type;
      }
    }
    return 'unknown';
  }

  private isTransientError(errorType: string): boolean {
    const transientTypes = ['timeout', 'rate_limit', 'network', 'service_unavailable', 'resource_exhausted'];
    return transientTypes.includes(errorType);
  }

  private detectPattern(
    error: Error,
    history: IterationResult[]
  ): string | undefined {
    if (history.length < 2) return undefined;

    // Same error across all iterations
    const allSameError = history.every(h =>
      h.error?.message === error.message
    );

    if (allSameError) {
      return 'repeated_identical_error';
    }

    // Alternating errors
    const errorTypes = history.map(h => this.classifyError(h.error!));
    const alternating = errorTypes.every((type, i) =>
      i === 0 || type !== errorTypes[i - 1]
    );

    if (alternating) {
      return 'alternating_errors';
    }

    return undefined;
  }

  private generateActions(
    errorType: string,
    isTransient: boolean,
    pattern?: string
  ): string[] {
    const actions: string[] = [];

    if (errorType === 'timeout') {
      actions.push('Increase timeout values');
      actions.push('Reduce parallelism');
    }

    if (errorType === 'rate_limit') {
      actions.push('Switch to alternative provider');
      actions.push('Add exponential backoff');
    }

    if (errorType === 'network') {
      actions.push('Retry with exponential backoff');
      actions.push('Check network connectivity');
    }

    if (errorType === 'auth') {
      actions.push('Verify API credentials');
      actions.push('Check token expiration');
    }

    if (pattern === 'repeated_identical_error') {
      actions.push('Consider skipping this step if optional');
      actions.push('Manual intervention may be required');
    }

    return actions;
  }
}
```

#### 4. SafetyEvaluator (`src/services/SafetyEvaluator.ts`)

**Responsibilities:**
- Enforce safety constraints based on safety level
- Prevent runaway execution
- Block dangerous operations
- Track resource consumption

**Safety Levels:**
```typescript
export type SafetyLevel = 'permissive' | 'normal' | 'paranoid';

export interface SafetyConfig {
  maxCostPerIteration: number; // USD
  maxTotalCost: number; // USD
  maxDurationPerIteration: number; // ms
  maxTotalDuration: number; // ms
  allowDestructiveOperations: boolean;
  allowExternalAPICalls: boolean;
  allowFileSystemWrites: boolean;
  maxAPICallsPerIteration: number;
}

export const SAFETY_CONFIGS: Record<SafetyLevel, SafetyConfig> = {
  permissive: {
    maxCostPerIteration: 10,
    maxTotalCost: 50,
    maxDurationPerIteration: 600000, // 10 minutes
    maxTotalDuration: 3600000, // 1 hour
    allowDestructiveOperations: true,
    allowExternalAPICalls: true,
    allowFileSystemWrites: true,
    maxAPICallsPerIteration: 1000
  },
  normal: {
    maxCostPerIteration: 5,
    maxTotalCost: 20,
    maxDurationPerIteration: 300000, // 5 minutes
    maxTotalDuration: 1800000, // 30 minutes
    allowDestructiveOperations: false,
    allowExternalAPICalls: true,
    allowFileSystemWrites: true,
    maxAPICallsPerIteration: 500
  },
  paranoid: {
    maxCostPerIteration: 1,
    maxTotalCost: 5,
    maxDurationPerIteration: 120000, // 2 minutes
    maxTotalDuration: 600000, // 10 minutes
    allowDestructiveOperations: false,
    allowExternalAPICalls: false,
    allowFileSystemWrites: false,
    maxAPICallsPerIteration: 100
  }
};

export interface SafetyCheck {
  safe: boolean;
  reason?: string;
  violations: string[];
}

export class SafetyEvaluator {
  async evaluate(
    strategy: Strategy,
    safetyLevel: SafetyLevel,
    iterationHistory: IterationResult[]
  ): Promise<SafetyCheck> {
    const config = SAFETY_CONFIGS[safetyLevel];
    const violations: string[] = [];

    // Check cost limits
    const totalCost = this.calculateTotalCost(iterationHistory);
    if (totalCost > config.maxTotalCost) {
      violations.push(`Total cost $${totalCost.toFixed(2)} exceeds limit $${config.maxTotalCost}`);
    }

    // Check duration limits
    const totalDuration = this.calculateTotalDuration(iterationHistory);
    if (totalDuration > config.maxTotalDuration) {
      violations.push(`Total duration ${totalDuration}ms exceeds limit ${config.maxTotalDuration}ms`);
    }

    // Check operation permissions
    if (!config.allowDestructiveOperations && this.hasDestructiveOperations(strategy)) {
      violations.push('Destructive operations not allowed at this safety level');
    }

    if (!config.allowExternalAPICalls && this.hasExternalAPICalls(strategy)) {
      violations.push('External API calls not allowed at this safety level');
    }

    if (!config.allowFileSystemWrites && this.hasFileSystemWrites(strategy)) {
      violations.push('File system writes not allowed at this safety level');
    }

    return {
      safe: violations.length === 0,
      reason: violations[0],
      violations
    };
  }

  private calculateTotalCost(history: IterationResult[]): number {
    return history.reduce((sum, iter) => {
      const cost = (iter.metadata?.cost as number) || 0;
      return sum + cost;
    }, 0);
  }

  private calculateTotalDuration(history: IterationResult[]): number {
    return history.reduce((sum, iter) => sum + iter.duration, 0);
  }

  private hasDestructiveOperations(strategy: Strategy): boolean {
    // Check if strategy config includes destructive operations
    // This would be defined in workflow steps
    return false; // Placeholder
  }

  private hasExternalAPICalls(strategy: Strategy): boolean {
    // Check if workflow includes external API calls
    return false; // Placeholder
  }

  private hasFileSystemWrites(strategy: Strategy): boolean {
    // Check if workflow includes file writes
    return false; // Placeholder
  }
}
```

---

## CLI Integration

### `ax run --iterate`

Add iterate mode to existing `ax workflow run` command:

```bash
# Basic iterate mode (default: max 10 iterations, normal safety)
ax workflow run security-audit.yaml --iterate

# Custom max iterations
ax workflow run security-audit.yaml --iterate --max-iterations 20

# Safety level
ax workflow run security-audit.yaml --iterate --safety paranoid

# Timeout
ax workflow run security-audit.yaml --iterate --timeout 3600000  # 1 hour

# Strategy selector
ax workflow run security-audit.yaml --iterate --strategy aggressive

# Verbose output
ax workflow run security-audit.yaml --iterate --verbose
```

**Options:**
- `--iterate` - Enable iterate mode
- `--max-iterations <n>` - Maximum iterations (default: 10)
- `--safety <level>` - Safety level: `permissive`, `normal`, `paranoid` (default: `normal`)
- `--timeout <ms>` - Total timeout in milliseconds
- `--strategy <mode>` - Strategy selector: `auto`, `conservative`, `aggressive` (default: `auto`)
- `--checkpoint-interval <n>` - Save checkpoint every N iterations
- `-v, --verbose` - Show detailed iteration logs

---

## Implementation Plan

### Week 5: Iterate Mode Implementation

**Day 21-22: Core Iterate Engine**
- [ ] Create `src/services/IterateEngine.ts`
- [ ] Implement iteration loop with max iterations
- [ ] Integrate with WorkflowEngineV2
- [ ] Progress tracking across iterations
- [ ] Checkpoint creation and restoration
- [ ] Unit tests for IterateEngine

**Day 23: Strategy Selection**
- [ ] Create `src/services/StrategySelector.ts`
- [ ] Define 5 builtin strategies
- [ ] Implement strategy selection logic
- [ ] Strategy history and learning
- [ ] Unit tests for StrategySelector

**Day 24: Failure Analysis + Safety**
- [ ] Create `src/services/FailureAnalyzer.ts`
- [ ] Error classification and pattern detection
- [ ] Transient vs permanent error detection
- [ ] Create `src/services/SafetyEvaluator.ts`
- [ ] Implement safety level enforcement
- [ ] Cost and duration tracking
- [ ] Unit tests for both components

**Day 25: CLI Integration + Documentation**
- [ ] Add `--iterate` flag to `ax workflow run`
- [ ] CLI output formatting (iteration logs)
- [ ] Integration tests with real workflows
- [ ] Documentation in `docs/iterate-mode.md`
- [ ] Examples and best practices

**Deliverables:**
- âœ… `ax run --iterate` enables autonomous execution
- âœ… Automatic strategy adaptation
- âœ… Safety constraints enforced
- âœ… Unit test coverage >80%
- âœ… Documentation with examples

---

## Testing Strategy

### Unit Tests

**IterateEngine Tests** (`src/services/__tests__/IterateEngine.test.ts`):
```typescript
describe('IterateEngine', () => {
  it('should execute single iteration successfully', async () => {});
  it('should retry on failure with new strategy', async () => {});
  it('should stop after max iterations', async () => {});
  it('should stop on success', async () => {});
  it('should enforce timeout', async () => {});
  it('should create checkpoints at interval', async () => {});
  it('should resume from checkpoint', async () => {});
  it('should enforce safety limits', async () => {});
});
```

**StrategySelector Tests** (`__tests__/StrategySelector.test.ts`):
```typescript
describe('StrategySelector', () => {
  it('should select default strategy initially', async () => {});
  it('should select strategy based on error type', async () => {});
  it('should prefer strategies with success history', async () => {});
  it('should fallback to next priority strategy', async () => {});
  it('should record successes', async () => {});
});
```

**FailureAnalyzer Tests** (`__tests__/FailureAnalyzer.test.ts`):
```typescript
describe('FailureAnalyzer', () => {
  it('should classify timeout errors', async () => {});
  it('should classify rate limit errors', async () => {});
  it('should detect transient errors', async () => {});
  it('should detect permanent errors', async () => {});
  it('should detect repeated error pattern', async () => {});
  it('should generate actionable suggestions', async () => {});
});
```

**SafetyEvaluator Tests** (`__tests__/SafetyEvaluator.test.ts`):
```typescript
describe('SafetyEvaluator', () => {
  it('should allow operations within cost limit', async () => {});
  it('should block operations exceeding cost limit', async () => {});
  it('should enforce paranoid safety restrictions', async () => {});
  it('should allow permissive operations', async () => {});
  it('should track cumulative cost', async () => {});
});
```

### Integration Tests

**End-to-End Iterate Flow** (`src/__tests__/integration/iterate-mode.test.ts`):
```typescript
describe('Iterate Mode Integration', () => {
  it('should complete workflow after retry', async () => {
    // Mock workflow that fails once then succeeds
    const result = await iterateEngine.iterate('test-workflow.yaml', {
      maxIterations: 5,
      safetyLevel: 'normal'
    });

    expect(result.success).toBe(true);
    expect(result.iterations).toBeGreaterThan(1);
    expect(result.history.length).toBeGreaterThan(1);
  });

  it('should adapt strategy on failure', async () => {
    // Mock network timeout error
    const result = await iterateEngine.iterate('timeout-workflow.yaml', {
      maxIterations: 3,
      safetyLevel: 'normal'
    });

    // Should switch to aggressive-timeout strategy
    expect(result.finalStrategy.name).toBe('aggressive-timeout');
  });
});
```

---

## Success Metrics

### Quality Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Retry success rate | >70% | Workflows that succeed after retry |
| Strategy selection accuracy | >80% | Selected strategy resolves failure |
| False positive safety blocks | <5% | Safe operations blocked by safety evaluator |
| Runaway execution prevention | 100% | No execution exceeding limits |

### Performance Metrics

| Metric | Target | Measurement |
|--------|--------|-------------|
| Strategy selection latency | <5s | Time to analyze and select strategy |
| Iteration overhead | <10% | Additional time vs non-iterate mode |
| Checkpoint creation | <2s | Time to save checkpoint |
| Memory overhead | <50MB | Additional memory for iteration history |

---

## Dependencies

All dependencies already available:
- `WorkflowEngineV2` - Workflow execution
- `CheckpointServiceV2` - Checkpoint creation/restoration
- `ProviderRouterV2` - Provider fallback
- `Telemetry` - Cost tracking

---

## Risk Mitigation

### Risk 1: Runaway Execution

**Probability:** Medium
**Impact:** High (cost overruns)

**Mitigation:**
- Strict safety level enforcement
- Hard limits on cost and duration
- Real-time monitoring with alerts
- Kill switch: `ax workflow stop <id>`

### Risk 2: Poor Strategy Selection

**Probability:** Medium
**Impact:** Medium (wasted iterations)

**Mitigation:**
- Conservative initial strategy
- Learn from historical success rates
- Allow manual strategy override
- Telemetry to track effectiveness

### Risk 3: Infinite Loops

**Probability:** Low
**Impact:** High (system hang)

**Mitigation:**
- Hard max iterations limit (default: 10)
- Detect repeated identical errors
- Automatic escalation to permanent failure
- Timeout enforcement at engine level

---

## Documentation Deliverables

1. **Iterate Mode User Guide** (`docs/iterate-mode.md`)
   - Overview and use cases
   - Safety level recommendations
   - Strategy selection guide
   - Troubleshooting

2. **API Reference** (`docs/api/iterate-engine.md`)
   - IterateEngine API
   - StrategySelector API
   - FailureAnalyzer API
   - SafetyEvaluator API

3. **Examples** (`examples/iterate-mode/`)
   - Retry with backoff
   - Provider fallback
   - Multi-stage workflows

---

## Conclusion

Iterate Mode is a **critical P1 feature** that enables autonomous problem-solving and resilience. This feature transforms AutomatosX from a single-shot executor into an intelligent agent that learns from failures and adapts strategies automatically.

**Key Benefits:**
- âœ… Autonomous retry without human intervention
- âœ… Intelligent strategy adaptation
- âœ… Safety constraints prevent runaway execution
- âœ… Learning from failure patterns
- âœ… Foundation for fully autonomous agents

**Ready to start Week 5 implementation.**

---

**Document Version:** 1.0
**Last Updated:** 2025-01-11
**Next Review:** After Week 5 completion
