// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as StateMachine from "./StateMachine.bs.js";

function createGuardContext(currentState, $$event, metadata) {
  return {
          currentState: currentState,
          event: $$event,
          metadata: metadata
        };
}

function verdictToString(verdict) {
  if (typeof verdict !== "object") {
    return "Pass";
  } else if (verdict.TAG === "Fail") {
    return "Fail(" + verdict._0 + ")";
  } else {
    return "Defer(" + verdict._0 + ")";
  }
}

function isPass(verdict) {
  if (typeof verdict !== "object") {
    return true;
  } else {
    return false;
  }
}

function isFail(verdict) {
  if (typeof verdict !== "object" || verdict.TAG !== "Fail") {
    return false;
  } else {
    return true;
  }
}

function isDefer(verdict) {
  if (typeof verdict !== "object" || verdict.TAG === "Fail") {
    return false;
  } else {
    return true;
  }
}

function schemaValidationGuard(validator, ctx) {
  var dict = ctx.metadata;
  if (dict === undefined) {
    return {
            TAG: "Fail",
            _0: "No metadata provided for schema validation"
          };
  }
  var error = validator(dict);
  if (typeof error !== "object") {
    return "Pass";
  } else {
    return {
            TAG: "Fail",
            _0: "Schema validation failed: " + error._0
          };
  }
}

function rateLimitGuard(state, _ctx) {
  var currentTime = Date.now();
  var timeSinceLastCheck = currentTime - state.lastCheckTime;
  if (timeSinceLastCheck > state.windowMs) {
    state.lastCheckTime = currentTime;
    state.checkCount = 1;
    return "Pass";
  } else if (state.checkCount >= state.maxChecks) {
    return {
            TAG: "Fail",
            _0: "Rate limit exceeded: " + String(state.checkCount) + " checks in " + String(state.windowMs) + "ms window"
          };
  } else {
    state.checkCount = state.checkCount + 1 | 0;
    return "Pass";
  }
}

function createRateLimitState(windowMs, maxChecks) {
  return {
          lastCheckTime: 0.0,
          checkCount: 0,
          windowMs: windowMs,
          maxChecks: maxChecks
        };
}

function dependencyCheckGuard(checker, _ctx) {
  var dep = checker();
  if (typeof dep !== "object") {
    return "Pass";
  } else if (dep.TAG === "Missing") {
    return {
            TAG: "Fail",
            _0: "Required dependency missing: " + dep._0
          };
  } else {
    return {
            TAG: "Fail",
            _0: "Dependency version mismatch: " + dep._0
          };
  }
}

function stateBasedGuard(allowedStates, ctx) {
  var isAllowed = Belt_Array.some(allowedStates, (function (allowedState) {
          return StateMachine.State.toString(allowedState) === StateMachine.State.toString(ctx.currentState);
        }));
  if (isAllowed) {
    return "Pass";
  }
  var allowedStateNames = Belt_Array.map(allowedStates, StateMachine.State.toString).join(", ");
  return {
          TAG: "Fail",
          _0: "Transition not allowed from state " + StateMachine.State.toString(ctx.currentState) + ". Allowed states: " + allowedStateNames
        };
}

function eventBasedGuard(allowedEvents, ctx) {
  var isAllowed = Belt_Array.some(allowedEvents, (function (allowedEvent) {
          return StateMachine.$$Event.toString(allowedEvent) === StateMachine.$$Event.toString(ctx.event);
        }));
  if (isAllowed) {
    return "Pass";
  }
  var allowedEventNames = Belt_Array.map(allowedEvents, StateMachine.$$Event.toString).join(", ");
  return {
          TAG: "Fail",
          _0: "Event " + StateMachine.$$Event.toString(ctx.event) + " not allowed. Allowed events: " + allowedEventNames
        };
}

function andGuard(guards, ctx) {
  var results = Belt_Array.map(guards, (function (g) {
          return g(ctx);
        }));
  var match = Belt_Array.getBy(results, isFail);
  if (match !== undefined && typeof match === "object" && match.TAG === "Fail") {
    return {
            TAG: "Fail",
            _0: match._0
          };
  }
  var match$1 = Belt_Array.getBy(results, isDefer);
  if (match$1 !== undefined && !(typeof match$1 !== "object" || match$1.TAG === "Fail")) {
    return {
            TAG: "Defer",
            _0: match$1._0
          };
  } else {
    return "Pass";
  }
}

function orGuard(guards, ctx) {
  var results = Belt_Array.map(guards, (function (g) {
          return g(ctx);
        }));
  if (Belt_Array.some(results, isPass)) {
    return "Pass";
  }
  var failures = Belt_Array.keepMap(results, (function (verdict) {
          if (typeof verdict !== "object" || verdict.TAG !== "Fail") {
            return ;
          } else {
            return verdict._0;
          }
        }));
  var combinedMsg = failures.join("; ");
  return {
          TAG: "Fail",
          _0: "All guards failed: " + combinedMsg
        };
}

function notGuard(guard, ctx) {
  var msg = guard(ctx);
  if (typeof msg !== "object") {
    return {
            TAG: "Fail",
            _0: "Guard passed but NOT combinator inverted it"
          };
  } else if (msg.TAG === "Fail") {
    return "Pass";
  } else {
    return {
            TAG: "Defer",
            _0: msg._0
          };
  }
}

function executeGuard(guard, ctx, guardName) {
  var verdict = guard(ctx);
  var logMsg = "[Guards] " + guardName + ": " + verdictToString(verdict) + " for " + StateMachine.$$Event.toString(ctx.event) + " in " + StateMachine.State.toString(ctx.currentState);
  console.log(logMsg);
  return verdict;
}

function executeGuards(guards, ctx) {
  var guardFunctions = Belt_Array.map(guards, (function (param) {
          return param[0];
        }));
  return andGuard(guardFunctions, ctx);
}

function alwaysPassGuard(_ctx) {
  return "Pass";
}

function alwaysFailGuard(reason, _ctx) {
  return {
          TAG: "Fail",
          _0: reason
        };
}

function metadataFieldGuard(fieldName, ctx) {
  var dict = ctx.metadata;
  if (dict === undefined) {
    return {
            TAG: "Fail",
            _0: "No metadata provided, expected field: " + fieldName
          };
  }
  var match = Js_dict.get(dict, fieldName);
  if (match !== undefined) {
    return "Pass";
  } else {
    return {
            TAG: "Fail",
            _0: "Required metadata field missing: " + fieldName
          };
  }
}

export {
  createGuardContext ,
  verdictToString ,
  isPass ,
  isFail ,
  isDefer ,
  schemaValidationGuard ,
  rateLimitGuard ,
  createRateLimitState ,
  dependencyCheckGuard ,
  stateBasedGuard ,
  eventBasedGuard ,
  andGuard ,
  orGuard ,
  notGuard ,
  executeGuard ,
  executeGuards ,
  alwaysPassGuard ,
  alwaysFailGuard ,
  metadataFieldGuard ,
}
/* No side effect */
