/**
 * Mock Generator
 *
 * Week 3-4 Implementation - Day 5
 * Generates mock files for testing
 */

import Handlebars from 'handlebars';
import type {
  MockRequirement,
  MockFile,
  TestFramework,
} from '../types/speckit.types.js';

/**
 * Mock Generator
 *
 * Generates mock implementations for agents, providers, database, and filesystem.
 */
export class MockGenerator {
  private templates: Map<string, HandlebarsTemplateDelegate>;

  constructor(private framework: TestFramework = 'vitest') {
    this.templates = new Map();
    this.registerTemplates();
    this.registerHelpers();
  }

  /**
   * Generate all mocks from requirements
   */
  generateMocks(requirements: MockRequirement[], workflowName: string): MockFile[] {
    const mocks: MockFile[] = [];

    for (const req of requirements) {
      const mock = this.generateMock(req, workflowName);
      mocks.push(mock);
    }

    return mocks;
  }

  /**
   * Generate a single mock file
   */
  private generateMock(requirement: MockRequirement, workflowName: string): MockFile {
    const template = this.templates.get(`${this.framework}-mock`);
    if (!template) {
      throw new Error(`Mock template not found for ${this.framework}`);
    }

    const content = template({
      mockType: requirement.type,
      mockName: requirement.name,
      methods: requirement.methods,
      pascalCaseName: this.pascalCase(requirement.name),
      timestamp: new Date().toISOString(),
    });

    return {
      path: `tests/${this.kebabCase(workflowName)}/mocks/${this.kebabCase(requirement.name)}.mock.ts`,
      content,
      mockType: requirement.type,
    };
  }

  /**
   * Register Handlebars templates
   */
  private registerTemplates(): void {
    // Vitest Mock Template
    this.templates.set('vitest-mock', Handlebars.compile(`import { vi } from 'vitest';

/**
 * Mock for {{mockType}}: {{mockName}}
 * Generated by AutomatosX v8.0.0 - {{timestamp}}
 */

/**
 * Create mock {{mockName}}
 */
export const mock{{pascalCaseName}} = () => {
  return {
{{#each methods}}
    {{this}}: vi.fn().mockResolvedValue({ success: true, output: {} }),
{{/each}}
  };
};

/**
 * Create mock {{mockName}} with custom behavior
 */
export const mock{{pascalCaseName}}WithBehavior = (
  behavior: Record<string, any>
) => {
  const baseMock = mock{{pascalCaseName}}();

  Object.entries(behavior).forEach(([method, impl]) => {
    if (baseMock[method as keyof typeof baseMock]) {
      (baseMock as any)[method] = vi.fn().mockImplementation(impl);
    }
  });

  return baseMock;
};

/**
 * Create failing mock {{mockName}}
 */
export const mock{{pascalCaseName}}WithError = (error: Error) => {
  return {
{{#each methods}}
    {{this}}: vi.fn().mockRejectedValue(error),
{{/each}}
  };
};
`));

    // Jest Mock Template (similar to Vitest)
    this.templates.set('jest-mock', Handlebars.compile(`/**
 * Mock for {{mockType}}: {{mockName}}
 * Generated by AutomatosX v8.0.0 - {{timestamp}}
 */

/**
 * Create mock {{mockName}}
 */
export const mock{{pascalCaseName}} = () => {
  return {
{{#each methods}}
    {{this}}: jest.fn().mockResolvedValue({ success: true, output: {} }),
{{/each}}
  };
};

/**
 * Create mock {{mockName}} with custom behavior
 */
export const mock{{pascalCaseName}}WithBehavior = (
  behavior: Record<string, any>
) => {
  const baseMock = mock{{pascalCaseName}}();

  Object.entries(behavior).forEach(([method, impl]) => {
    if (baseMock[method as keyof typeof baseMock]) {
      (baseMock as any)[method] = jest.fn().mockImplementation(impl);
    }
  });

  return baseMock;
};
`));

    // Mocha Mock Template (using Sinon)
    this.templates.set('mocha-mock', Handlebars.compile(`import * as sinon from 'sinon';

/**
 * Mock for {{mockType}}: {{mockName}}
 * Generated by AutomatosX v8.0.0 - {{timestamp}}
 */

/**
 * Create mock {{mockName}}
 */
export const mock{{pascalCaseName}} = () => {
  return {
{{#each methods}}
    {{this}}: sinon.stub().resolves({ success: true, output: {} }),
{{/each}}
  };
};

/**
 * Create mock {{mockName}} with custom behavior
 */
export const mock{{pascalCaseName}}WithBehavior = (
  behavior: Record<string, any>
) => {
  const baseMock = mock{{pascalCaseName}}();

  Object.entries(behavior).forEach(([method, impl]) => {
    if (baseMock[method as keyof typeof baseMock]) {
      (baseMock as any)[method] = sinon.stub().callsFake(impl);
    }
  });

  return baseMock;
};
`));
  }

  /**
   * Register Handlebars helpers
   */
  private registerHelpers(): void {
    Handlebars.registerHelper('pascalCase', (str: string) => {
      return this.pascalCase(str);
    });

    Handlebars.registerHelper('kebabCase', (str: string) => {
      return this.kebabCase(str);
    });
  }

  /**
   * Convert string to PascalCase
   */
  private pascalCase(str: string): string {
    return str
      .replace(/(?:^|[-_\s])(\w)/g, (_, c) => c.toUpperCase())
      .replace(/[-_\s]/g, '');
  }

  /**
   * Convert string to kebab-case
   */
  private kebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/[\s_]+/g, '-')
      .toLowerCase();
  }
}
