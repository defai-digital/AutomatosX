/**
 * Test Generator
 *
 * Generates test files from YAML specs with fixtures and assertions.
 *
 * @module core/spec/TestGenerator
 */

import { join } from 'path';
import type { SpecYAML } from '@/types/spec-yaml.js';
import { logger } from '@/utils/logger.js';

/**
 * Test generator for YAML specs
 */
export class TestGenerator {
  /**
   * Generate test files from spec
   *
   * @param spec - Parsed YAML spec
   * @param basePath - Base path for tests
   * @returns Array of test files (path + content)
   */
  generate(spec: SpecYAML, basePath: string): Array<{ path: string; content: string }> {
    const files: Array<{ path: string; content: string }> = [];

    // Validate spec.actors exists
    if (!spec.actors || spec.actors.length === 0) {
      throw new Error('Spec must have at least one actor');
    }

    // FIXED (Bug #29): Validate spec.metadata exists and has required fields
    if (!spec.metadata || typeof spec.metadata !== 'object') {
      throw new Error('Spec must have metadata object');
    }
    if (!spec.metadata.id || typeof spec.metadata.id !== 'string') {
      throw new Error('Spec metadata must have id field (string)');
    }
    if (!spec.metadata.name || typeof spec.metadata.name !== 'string') {
      throw new Error('Spec metadata must have name field (string)');
    }

    // FIXED (Bug #30): Validate basePath is a non-empty string
    if (typeof basePath !== 'string') {
      throw new Error(`basePath must be a string, got ${typeof basePath}`);
    }
    if (basePath.trim().length === 0) {
      throw new Error('basePath cannot be empty or whitespace-only');
    }

    // Generate test file for each actor
    for (const actor of spec.actors) {
      // FIXED (Bug #31): Validate actor.id before using in file path
      if (!actor.id || typeof actor.id !== 'string') {
        throw new Error(`Actor must have id field (string), got ${typeof actor.id}`);
      }

      files.push({
        path: join(basePath, 'tests', `${actor.id}.test.ts`),
        content: this.generateActorTest(actor, spec)
      });
    }

    // Generate integration test
    files.push({
      path: join(basePath, 'tests', 'integration.test.ts'),
      content: this.generateIntegrationTest(spec)
    });

    // Generate E2E test
    files.push({
      path: join(basePath, 'tests', 'e2e.test.ts'),
      content: this.generateE2ETest(spec)
    });

    // Generate test fixtures
    files.push({
      path: join(basePath, 'tests', 'fixtures', 'input.json'),
      content: this.generateInputFixtures(spec)
    });

    // Generate test config
    files.push({
      path: join(basePath, 'vitest.config.ts'),
      content: this.generateVitestConfig(spec)
    });

    logger.debug('Test files generated', {
      specId: spec.metadata.id,
      files: files.length
    });

    return files;
  }

  /**
   * Generate actor-specific test file
   */
  private generateActorTest(actor: any, spec: SpecYAML): string {
    // FIXED (Bug #32): Validate actor.id before accessing
    if (!actor.id || typeof actor.id !== 'string') {
      throw new Error(`Actor must have id field (string) for test generation, got ${typeof actor.id}`);
    }

    const lines: string[] = [
      `/**`,
      ` * Test: ${actor.id}`,
      ` * Generated by AutomatosX`,
      ` */`,
      ``,
      `import { describe, it, expect, beforeEach, afterEach } from 'vitest';`,
      ``,
      `describe('${actor.id}', () => {`,
      `  beforeEach(() => {`,
      `    // Setup for ${actor.id} tests`,
      `  });`,
      ``,
      `  afterEach(() => {`,
      `    // Cleanup after ${actor.id} tests`,
      `  });`,
      ``
    ];

    // Basic execution test
    lines.push(`  it('should execute task successfully', async () => {`);
    lines.push(`    // TODO: Implement execution test for ${actor.id}`);
    lines.push(`    const result = await executeActor('${actor.id}');`);
    lines.push(`    expect(result).toBeDefined();`);
    lines.push(`    expect(result.success).toBe(true);`);
    lines.push(`  });`);
    lines.push(``);

    // FIXED (Bug #33): Validate timeout is a positive number before using
    if (actor.timeout !== undefined) {
      if (typeof actor.timeout !== 'number' || !Number.isFinite(actor.timeout) || actor.timeout <= 0) {
        throw new Error(`Actor "${actor.id}" timeout must be a positive finite number, got ${typeof actor.timeout === 'number' ? actor.timeout : typeof actor.timeout}`);
      }
      lines.push(`  it('should complete within timeout of ${actor.timeout}ms', async () => {`);
      lines.push(`    const start = Date.now();`);
      lines.push(`    await executeActor('${actor.id}');`);
      lines.push(`    const duration = Date.now() - start;`);
      lines.push(`    expect(duration).toBeLessThan(${actor.timeout});`);
      lines.push(`  });`);
      lines.push(``);
    }

    // FIXED (Bug #34): Validate cost constraint is a positive number
    if (spec.policy?.constraints?.cost?.maxPerRequest !== undefined) {
      const maxCost = spec.policy.constraints.cost.maxPerRequest;
      if (typeof maxCost !== 'number' || !Number.isFinite(maxCost) || maxCost <= 0) {
        throw new Error(`spec.policy.constraints.cost.maxPerRequest must be a positive finite number, got ${typeof maxCost === 'number' ? maxCost : typeof maxCost}`);
      }
      lines.push(`  it('should not exceed cost limit of $${maxCost}', async () => {`);
      lines.push(`    // Track cost during execution`);
      lines.push(`    const costTracker = createCostTracker();`);
      lines.push(`    await executeActor('${actor.id}', { costTracker });`);
      lines.push(`    const actualCost = await costTracker.getTotalCost();`);
      lines.push(`    expect(actualCost).toBeLessThanOrEqual(${maxCost});`);
      lines.push(`  });`);
      lines.push(``);
    }

    // FIXED (Bug #35): Validate latency constraint is a positive number
    if (spec.policy?.constraints?.latency?.p95 !== undefined) {
      const maxLatency = spec.policy.constraints.latency.p95;
      if (typeof maxLatency !== 'number' || !Number.isFinite(maxLatency) || maxLatency <= 0) {
        throw new Error(`spec.policy.constraints.latency.p95 must be a positive finite number, got ${typeof maxLatency === 'number' ? maxLatency : typeof maxLatency}`);
      }
      lines.push(`  it('should complete within ${maxLatency}ms (P95)', async () => {`);
      lines.push(`    const durations: number[] = [];`);
      lines.push(``);
      lines.push(`    // Run multiple times to measure P95`);
      lines.push(`    for (let i = 0; i < 20; i++) {`);
      lines.push(`      const start = Date.now();`);
      lines.push(`      await executeActor('${actor.id}');`);
      lines.push(`      durations.push(Date.now() - start);`);
      lines.push(`    }`);
      lines.push(``);
      lines.push(`    // Calculate P95`);
      lines.push(`    durations.sort((a, b) => a - b);`);
      lines.push(`    const p95Index = Math.floor(durations.length * 0.95);`);
      lines.push(`    const p95 = durations[p95Index];`);
      lines.push(``);
      lines.push(`    expect(p95).toBeLessThanOrEqual(${maxLatency});`);
      lines.push(`  });`);
      lines.push(``);
    }

    // FIXED (Bug #36): Validate memory limit is a string (e.g., "512MB")
    if (actor.resources?.memory?.limit !== undefined) {
      const memLimit = actor.resources.memory.limit;
      if (typeof memLimit !== 'string' || memLimit.trim().length === 0) {
        throw new Error(`Actor "${actor.id}" memory limit must be a non-empty string (e.g., "512MB"), got ${typeof memLimit}`);
      }
      lines.push(`  it('should not exceed memory limit of ${memLimit}', async () => {`);
      lines.push(`    const memoryBefore = process.memoryUsage().heapUsed;`);
      lines.push(`    await executeActor('${actor.id}');`);
      lines.push(`    const memoryAfter = process.memoryUsage().heapUsed;`);
      lines.push(`    const memoryUsedMb = (memoryAfter - memoryBefore) / (1024 * 1024);`);
      lines.push(`    // TODO: Adjust this based on actual memory limit parsing`);
      lines.push(`    expect(memoryUsedMb).toBeLessThan(1024); // Placeholder`);
      lines.push(`  });`);
      lines.push(``);
    }

    // Error handling test
    lines.push(`  it('should handle errors gracefully', async () => {`);
    lines.push(`    // Test error scenarios for ${actor.id}`);
    lines.push(`    await expect(executeActor('${actor.id}', { simulateError: true }))`);
    lines.push(`      .rejects.toThrow();`);
    lines.push(`  });`);
    lines.push(``);

    // FIXED (Bug #37): Validate maxAttempts is a positive integer
    if (spec.recovery?.retry?.maxAttempts !== undefined) {
      const maxAttempts = spec.recovery.retry.maxAttempts;
      if (!Number.isInteger(maxAttempts) || maxAttempts <= 0) {
        throw new Error(`spec.recovery.retry.maxAttempts must be a positive integer, got ${typeof maxAttempts === 'number' ? maxAttempts : typeof maxAttempts}`);
      }
      lines.push(`  it('should retry on failure up to ${maxAttempts} times', async () => {`);
      lines.push(`    let attempts = 0;`);
      lines.push(``);
      lines.push(`    await executeActor('${actor.id}', {`);
      lines.push(`      onAttempt: () => { attempts++; throw new Error('Retry test'); }`);
      lines.push(`    }).catch(() => {});`);
      lines.push(``);
      lines.push(`    expect(attempts).toBe(${maxAttempts});`);
      lines.push(`  });`);
      lines.push(``);
    }

    lines.push(`});`);
    lines.push(``);

    // Helper function placeholder
    lines.push(`/**`);
    lines.push(` * Helper: Execute actor for testing`);
    lines.push(` * TODO: Implement actual actor execution logic`);
    lines.push(` */`);
    lines.push(`async function executeActor(`);
    lines.push(`  actorId: string,`);
    lines.push(`  options?: any`);
    lines.push(`): Promise<{ success: boolean; data?: any }> {`);
    lines.push(`  // Implementation needed`);
    lines.push(`  return { success: true };`);
    lines.push(`}`);
    lines.push(``);

    // Cost tracker helper
    if (spec.policy?.constraints?.cost) {
      lines.push(`/**`);
      lines.push(` * Helper: Create cost tracker`);
      lines.push(` * TODO: Implement actual cost tracking`);
      lines.push(` */`);
      lines.push(`function createCostTracker() {`);
      lines.push(`  return {`);
      lines.push(`    getTotalCost: async () => 0.001`);
      lines.push(`  };`);
      lines.push(`}`);
      lines.push(``);
    }

    return lines.join('\n');
  }

  /**
   * Generate integration test file
   */
  private generateIntegrationTest(spec: SpecYAML): string {
    // FIXED (Bug #38): Validate spec.metadata before accessing
    // Note: Already validated in generate() but defensive programming requires validation here too
    if (!spec.metadata?.name || typeof spec.metadata.name !== 'string') {
      throw new Error('Spec metadata.name must be a string for integration test generation');
    }
    if (!spec.metadata.id || typeof spec.metadata.id !== 'string') {
      throw new Error('Spec metadata.id must be a string for integration test generation');
    }

    const lines: string[] = [
      `/**`,
      ` * Integration Test`,
      ` * Tests full workflow execution`,
      ` * Generated by AutomatosX`,
      ` */`,
      ``,
      `import { describe, it, expect, beforeAll, afterAll } from 'vitest';`,
      ``,
      `describe('${spec.metadata.name} - Integration', () => {`,
      `  beforeAll(() => {`,
      `    // Setup integration test environment`,
      `  });`,
      ``,
      `  afterAll(() => {`,
      `    // Cleanup integration test environment`,
      `  });`,
      ``
    ];

    // Full workflow test
    lines.push(`  it('should execute complete workflow', async () => {`);
    lines.push(`    // Execute all actors in sequence/parallel`);
    lines.push(`    const result = await executeWorkflow('${spec.metadata.id}');`);
    lines.push(`    expect(result.success).toBe(true);`);
    lines.push(`    expect(result.completedActors).toBe(${spec.actors.length});`);
    lines.push(`  });`);
    lines.push(``);

    // Data flow test (if multiple actors)
    if (spec.actors.length > 1) {
      lines.push(`  it('should pass data between actors correctly', async () => {`);
      lines.push(`    const result = await executeWorkflow('${spec.metadata.id}');`);
      lines.push(`    // Verify data flow between actors`);
      for (let i = 0; i < spec.actors.length - 1; i++) {
        const current = spec.actors[i];
        const next = spec.actors[i + 1];
        if (current && next) {
          // FIXED (Bug #39): Validate actor.id before using in template string
          if (!current.id || typeof current.id !== 'string') {
            throw new Error(`Actor at index ${i} must have id field (string) for integration test generation`);
          }
          if (!next.id || typeof next.id !== 'string') {
            throw new Error(`Actor at index ${i + 1} must have id field (string) for integration test generation`);
          }
          lines.push(`    expect(result.dataFlow['${current.id}_to_${next.id}']).toBeDefined();`);
        }
      }
      lines.push(`  });`);
      lines.push(``);
    }

    // Recovery test (if recovery config exists)
    if (spec.recovery) {
      lines.push(`  it('should handle failures with recovery strategy', async () => {`);
      lines.push(`    // Simulate failure and recovery`);
      lines.push(`    const result = await executeWorkflow('${spec.metadata.id}', {`);
      lines.push(`      simulateFailure: true`);
      lines.push(`    });`);
      lines.push(`    expect(result.recovered).toBe(true);`);
      lines.push(`  });`);
      lines.push(``);
    }

    // Performance test
    lines.push(`  it('should complete workflow within expected duration', async () => {`);
    lines.push(`    const start = Date.now();`);
    lines.push(`    await executeWorkflow('${spec.metadata.id}');`);
    lines.push(`    const duration = Date.now() - start;`);
    lines.push(`    // TODO: Set expected duration based on spec`);
    lines.push(`    expect(duration).toBeLessThan(300000); // 5 minutes placeholder`);
    lines.push(`  });`);
    lines.push(``);

    lines.push(`});`);
    lines.push(``);

    // Helper function
    lines.push(`/**`);
    lines.push(` * Helper: Execute full workflow`);
    lines.push(` * TODO: Implement actual workflow execution`);
    lines.push(` */`);
    lines.push(`async function executeWorkflow(`);
    lines.push(`  workflowId: string,`);
    lines.push(`  options?: any`);
    lines.push(`): Promise<{ success: boolean; completedActors: number; dataFlow?: any; recovered?: boolean }> {`);
    lines.push(`  // Implementation needed`);
    lines.push(`  return { success: true, completedActors: ${spec.actors.length} };`);
    lines.push(`}`);
    lines.push(``);

    return lines.join('\n');
  }

  /**
   * Generate E2E test file
   */
  private generateE2ETest(spec: SpecYAML): string {
    // FIXED (Bug #40): Validate spec.metadata.name before accessing
    if (!spec.metadata?.name || typeof spec.metadata.name !== 'string') {
      throw new Error('Spec metadata.name must be a string for E2E test generation');
    }

    return `/**
 * E2E Test
 * End-to-end test for ${spec.metadata.name}
 * Generated by AutomatosX
 */

import { describe, it, expect, beforeAll, afterAll } from 'vitest';

describe('${spec.metadata.name} - E2E', () => {
  beforeAll(async () => {
    // Setup E2E environment (databases, external services, etc.)
  });

  afterAll(async () => {
    // Cleanup E2E environment
  });

  it('should execute full system workflow end-to-end', async () => {
    // TODO: Implement full E2E test
    // This should test the system as a user would experience it
    expect(true).toBe(true);
  });

  it('should handle realistic input data', async () => {
    // Load realistic input from fixtures
    // Execute workflow
    // Verify output against expected results
    expect(true).toBe(true);
  });

  it('should meet performance requirements under load', async () => {
    // Execute multiple concurrent workflows
    // Measure performance metrics
    // Verify against SLA requirements
    expect(true).toBe(true);
  });
});
`;
  }

  /**
   * Generate input fixtures
   */
  private generateInputFixtures(spec: SpecYAML): string {
    const fixtures: Record<string, any> = {};

    for (const actor of spec.actors) {
      // FIXED (Bug #41): Validate actor.id before using as object key
      if (!actor.id || typeof actor.id !== 'string') {
        throw new Error(`Actor must have id field (string) for fixture generation, got ${typeof actor.id}`);
      }

      fixtures[actor.id] = {
        description: `Input fixture for ${actor.id}`,
        data: {
          // TODO: Generate realistic fixture data based on actor
          sample: 'Add realistic input data here'
        }
      };
    }

    return JSON.stringify(fixtures, null, 2);
  }

  /**
   * Generate Vitest config
   */
  private generateVitestConfig(spec: SpecYAML): string {
    // FIXED (Bug #42): Validate timeout and maxAttempts before using in config
    const testTimeout = spec.actors[0]?.timeout;
    let validatedTimeout = 300000; // Default 5 minutes
    if (testTimeout !== undefined) {
      if (typeof testTimeout !== 'number' || !Number.isFinite(testTimeout) || testTimeout <= 0) {
        throw new Error(`spec.actors[0].timeout must be a positive finite number for vitest config, got ${typeof testTimeout === 'number' ? testTimeout : typeof testTimeout}`);
      }
      validatedTimeout = testTimeout;
    }

    const maxAttempts = spec.recovery?.retry?.maxAttempts;
    let validatedRetry = 0; // Default no retries
    if (maxAttempts !== undefined) {
      if (!Number.isInteger(maxAttempts) || maxAttempts < 0) {
        throw new Error(`spec.recovery.retry.maxAttempts must be a non-negative integer for vitest config, got ${typeof maxAttempts === 'number' ? maxAttempts : typeof maxAttempts}`);
      }
      validatedRetry = maxAttempts;
    }

    return `/**
 * Vitest Configuration
 * Generated by AutomatosX
 */

import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    // Global test configuration
    globals: true,
    environment: 'node',

    // Test file patterns
    include: ['tests/**/*.test.ts'],

    // Coverage configuration
    coverage: {
      provider: 'v8',
      reporter: ['text', 'json', 'html'],
      exclude: [
        'node_modules/**',
        'tests/**',
        'dist/**'
      ]
    },

    // Timeouts
    testTimeout: ${validatedTimeout},
    hookTimeout: 30000,

    // Retry configuration
    retry: ${validatedRetry},

    // Parallel execution
    threads: true,
    maxThreads: 4,

    // Reporter
    reporter: ['verbose', 'html'],

    // Setup files
    setupFiles: []
  }
});
`;
  }
}

/**
 * Default singleton instance
 */
let defaultTestGenerator: TestGenerator | null = null;

/**
 * Get default test generator instance (singleton)
 */
export function getDefaultTestGenerator(): TestGenerator {
  if (!defaultTestGenerator) {
    defaultTestGenerator = new TestGenerator();
  }
  return defaultTestGenerator;
}

/**
 * Convenience function: generate tests from spec
 */
export function generateTests(spec: SpecYAML, basePath: string): Array<{ path: string; content: string }> {
  return getDefaultTestGenerator().generate(spec, basePath);
}
