/**
 * Enhanced Init Command - Claude Code Quality
 *
 * Generates comprehensive AX.MD with:
 * - Multi-paragraph descriptions
 * - Categorized real commands
 * - File structure documentation
 * - Architecture flow diagrams
 * - No placeholders
 *
 * @since v8.5.0
 */

import type { CommandModule } from 'yargs';
import { writeFile, readFile, access, rename } from 'node:fs/promises';
import { constants } from 'node:fs';
import { join } from 'path';
import chalk from 'chalk';
import { logger } from '../../utils/logger.js';
import { printError } from '../../utils/error-formatter.js';
import {
  detectProjectInfo,
  type ProjectInfo,
  type CategorizedScripts,
  type FileStructure
} from './project-detector.js';
import {
  parseAXMD,
  detectDetailedChanges,
  formatChangeSummary
} from './init-parser.js';

interface InitOptions {
  force?: boolean;
}

/**
 * Generate enhanced AX.MD content (Claude Code quality)
 */
function generateAXMD(info: ProjectInfo): string {
  const today = new Date().toISOString().split('T')[0];

  return `# Project Context for ${info.name}

> Last updated: ${today}
> Project: ${info.name}${info.version ? ` (v${info.version})` : ''}

## Project Overview

${generateProjectOverview(info)}

## Architecture

${generateArchitecture(info)}

## File Structure

${generateFileStructure(info)}

${generateAgentRules(info)}

${generateCodingConventions(info)}

${generateCriticalGuardrails(info)}

${generateCommands(info)}

${generateUsefulLinks(info)}

---

**Generated by \`ax init\` • Run regularly to keep up-to-date**
`;
}

/**
 * Generate comprehensive project overview
 */
function generateProjectOverview(info: ProjectInfo): string {
  const sections: string[] = [];

  // Multi-paragraph description from README
  if (info.detailedDescription) {
    sections.push(info.detailedDescription);
  } else if (info.description) {
    sections.push(`**${info.description}**`);
  } else {
    sections.push(`**${info.framework || 'Node.js'} project${info.hasTypeScript ? ' with TypeScript' : ''}**`);
  }

  // Key info
  const keyInfo: string[] = [];
  keyInfo.push(`**Version:** ${info.version || 'Not specified'}`);
  keyInfo.push(`**Language:** ${info.language}`);
  if (info.framework) keyInfo.push(`**Framework:** ${info.framework}`);
  if (info.buildTool) keyInfo.push(`**Build Tool:** ${info.buildTool}`);
  if (info.testFramework) keyInfo.push(`**Test Framework:** ${info.testFramework}`);
  if (info.isMonorepo) keyInfo.push(`**Type:** Monorepo`);

  sections.push('\n' + keyInfo.join('  \n'));

  // Stack
  sections.push(`\n**Stack:** ${info.stack}`);

  // Team size (only if detected)
  if (info.teamSize) {
    sections.push(`\n**Team:** ${info.teamSize}`);
  }

  return sections.join('\n');
}

/**
 * Generate architecture section
 */
function generateArchitecture(info: ProjectInfo): string {
  const sections: string[] = [];

  // Architecture type
  sections.push(`**Type:** ${detectArchitectureType(info)}`);

  // Flow diagram
  if (info.architectureFlow) {
    sections.push('\n**Flow:**\n```');
    sections.push(info.architectureFlow.trim());
    sections.push('```');
  }

  // Key components
  if (info.keyComponents && info.keyComponents.length > 0) {
    sections.push('\n**Key Components:**');
    for (const comp of info.keyComponents) {
      if (comp.purpose) {
        sections.push(`- \`${comp.path}\` - ${comp.purpose}`);
      } else {
        sections.push(`- \`${comp.path}\``);
      }
    }
  }

  return sections.join('\n');
}

/**
 * Detect architecture type
 */
function detectArchitectureType(info: ProjectInfo): string {
  if (info.dependencies.includes('next') || info.dependencies.includes('nuxt')) {
    return 'Full-stack framework (SSR/SSG)';
  }
  if (info.dependencies.includes('express') || info.dependencies.includes('fastify')) {
    if (info.framework === 'React' || info.framework === 'Vue') {
      return 'Client-server architecture';
    }
    return 'REST API server';
  }
  if (info.dependencies.includes('apollo-server') || info.dependencies.includes('graphql')) {
    return 'GraphQL API server';
  }
  if (info.framework === 'React' || info.framework === 'Vue') {
    return 'Single Page Application (SPA)';
  }
  if (info.dependencies.some(d => d.includes('commander') || d.includes('yargs'))) {
    return 'Command-line interface (CLI)';
  }
  return 'Node.js application';
}

/**
 * Generate file structure documentation
 */
function generateFileStructure(info: ProjectInfo): string {
  if (!info.fileStructure || info.fileStructure.directories.length === 0) {
    return '';  // Omit if no structure detected
  }

  const sections: string[] = [];

  // Entry point
  if (info.fileStructure.entryPoint) {
    sections.push(`**Entry Point:** \`${info.fileStructure.entryPoint}\``);
  }

  // Directory structure
  sections.push('\n**Directories:**');
  for (const dir of info.fileStructure.directories) {
    if (dir.purpose) {
      sections.push(`- \`${dir.path}/\` - ${dir.purpose} (${dir.fileCount} files)`);
    } else {
      sections.push(`- \`${dir.path}/\` - ${dir.fileCount} files`);
    }
  }

  // Total
  sections.push(`\n**Total Files:** ${info.fileStructure.totalFiles}`);

  return sections.join('\n');
}

/**
 * Generate agent delegation rules
 */
function generateAgentRules(info: ProjectInfo): string {
  const rules: string[] = ['## Agent Delegation Rules', ''];

  // Development section
  rules.push('### Development');

  if (info.framework === 'React' || info.framework === 'Vue' || info.framework === 'Next.js') {
    rules.push(`- **Frontend/UI (${info.framework})** → @frontend (Frank)`);
  }

  if (info.dependencies.includes('express') || info.dependencies.includes('fastify') || info.dependencies.includes('koa')) {
    rules.push('- **Backend/API** → @backend (Bob) or @fullstack (Felix)');
  }

  if (info.hasTypeScript) {
    rules.push('- **TypeScript issues** → @fullstack (Felix)');
  }

  if (info.dependencies.some(d => d.includes('react-native') || d.includes('expo'))) {
    rules.push('- **Mobile** → @mobile (Maya)');
  }

  rules.push('- **Infrastructure/DevOps** → @devops (Oliver)');
  rules.push('');

  // Quality section
  rules.push('### Quality & Architecture');
  rules.push('- **Tests/QA** → @quality (Queenie)');
  rules.push('- **Security audits** → @security (Steve) - mandatory for: auth, payments, PII');
  rules.push('- **Architecture/ADR** → @architecture (Avery)');
  rules.push('');

  // Documentation section
  rules.push('### Documentation & Product');
  rules.push('- **Technical writing** → @writer (Wendy)');
  rules.push('- **Product management** → @product (Paris)');

  return rules.join('\n');
}

/**
 * Generate coding conventions
 */
function generateCodingConventions(info: ProjectInfo): string {
  const conventions: string[] = ['## Coding Conventions', ''];

  // Testing
  conventions.push('### Testing');
  if (info.testFramework) {
    conventions.push(`- **Framework:** ${info.testFramework}`);
    conventions.push('- **Coverage:** 80% minimum');
    conventions.push(`- **Run:** \`${info.packageManager} test\``);
  } else {
    conventions.push('- Run tests before pushing');
  }
  conventions.push('');

  // Code style
  conventions.push('### Code Style');
  if (info.linter) {
    conventions.push(`- **Linter:** ${info.linter}`);
  }
  if (info.formatter) {
    conventions.push(`- **Formatter:** ${info.formatter}`);
  }
  if (info.hasTypeScript) {
    conventions.push('- **TypeScript:** Strict mode enabled');
  }
  conventions.push('- **Indent:** 2 spaces');
  conventions.push('- **Max line:** 100 chars');
  conventions.push('');

  // Git workflow
  conventions.push('### Git Workflow');
  conventions.push('- **Branch naming:** `feature/description` or `fix/description`');
  conventions.push('- **Commits:** Conventional commits format (feat/fix/chore/docs)');
  conventions.push('- **PRs:** Review required before merge');

  return conventions.join('\n');
}

/**
 * Generate critical guardrails
 */
function generateCriticalGuardrails(info: ProjectInfo): string {
  const guardrails: string[] = ['## Critical Guardrails', ''];

  // Never
  guardrails.push('⚠️ **NEVER:**');
  guardrails.push('- Commit to main/production branches directly');
  guardrails.push('- Skip tests before pushing');
  guardrails.push('- Expose API keys or credentials in code');

  // Database-specific
  if (info.dependencies.includes('prisma') || info.dependencies.includes('typeorm')) {
    guardrails.push('- Modify database migrations without approval');
  }

  guardrails.push('');

  // Always
  guardrails.push('✅ **ALWAYS:**');
  guardrails.push(`- Run \`${info.packageManager} test\` before pushing`);

  if (info.linter) {
    guardrails.push(`- Run \`${info.packageManager} run lint\` to check code style`);
  }

  if (info.formatter) {
    guardrails.push(`- Format code with ${info.formatter} before committing`);
  }

  guardrails.push('- Document breaking changes');
  guardrails.push('- Add tests for new features');

  return guardrails.join('\n');
}

/**
 * Generate commands section with REAL commands (no placeholders!)
 */
function generateCommands(info: ProjectInfo): string {
  const sections: string[] = ['## Canonical Commands', ''];

  if (!info.categorizedScripts) {
    return sections.join('\n') + '```bash\n# No scripts detected\n```';
  }

  const categories = [
    { key: 'development', title: 'Development' },
    { key: 'building', title: 'Building' },
    { key: 'testing', title: 'Testing' },
    { key: 'quality', title: 'Quality Checks' },
    { key: 'deployment', title: 'Deployment' }
  ] as const;

  sections.push('```bash');

  for (const { key, title } of categories) {
    const scripts = info.categorizedScripts[key];
    if (scripts && scripts.length > 0) {
      sections.push(`# ${title}`);
      for (const script of scripts) {
        const cmd = `${info.packageManager} run ${script.name}`;
        const padding = ' '.repeat(Math.max(35 - cmd.length, 1));
        sections.push(`${cmd}${padding}# ${script.description}`);
      }
      sections.push('');
    }
  }

  // Other scripts
  const other = info.categorizedScripts.other;
  if (other && other.length > 0) {
    sections.push('# Other');
    for (const script of other) {
      const cmd = `${info.packageManager} run ${script.name}`;
      const padding = ' '.repeat(Math.max(35 - cmd.length, 1));
      sections.push(`${cmd}${padding}# ${script.description}`);
    }
  }

  sections.push('```');

  return sections.join('\n');
}

/**
 * Generate useful links
 */
function generateUsefulLinks(info: ProjectInfo): string {
  const links: string[] = ['## Useful Links', ''];

  if (info.repository) {
    links.push(`- [Repository](${info.repository})`);
  }

  if (info.fileStructure?.docsDirectory) {
    links.push(`- [Documentation](${info.fileStructure.docsDirectory}/)`);
  }

  return links.join('\n');
}

/**
 * Atomic write (temp file + rename for safety)
 */
async function atomicWrite(filePath: string, content: string): Promise<void> {
  const tempPath = `${filePath}.tmp`;
  await writeFile(tempPath, content, 'utf-8');
  await rename(tempPath, filePath);
}

export const initCommand: CommandModule<Record<string, unknown>, InitOptions> = {
  command: 'init',
  describe: 'Initialize AX.MD project context file',

  builder: (yargs) => {
    return yargs
      .option('force', {
        alias: 'f',
        describe: 'Regenerate AX.MD from scratch',
        type: 'boolean',
        default: false
      })
      .example([
        ['$0 init', 'Create or update AX.MD with current project info'],
        ['$0 init --force', 'Regenerate AX.MD from scratch']
      ]);
  },

  handler: async (argv) => {
    const projectDir = process.cwd();
    const axMdPath = join(projectDir, 'AX.MD');

    try {
      // Detect current project info (enhanced)
      const projectInfo = await detectProjectInfo(projectDir);

      // Check if AX.MD already exists
      const axMdExists = await access(axMdPath, constants.F_OK).then(() => true).catch(() => false);

      if (axMdExists && !argv.force) {
        // Claude Code behavior: UPDATE existing file intelligently
        const existingContent = await readFile(axMdPath, 'utf-8');
        const parsed = parseAXMD(existingContent);

        // Detect changes
        const changes = detectDetailedChanges(parsed, {
          version: projectInfo.version,
          dependencies: projectInfo.dependencies,
          scripts: projectInfo.scripts,
          framework: projectInfo.framework,
          architecture: detectArchitectureType(projectInfo),
          linter: projectInfo.linter,
          formatter: projectInfo.formatter,
          testFramework: projectInfo.testFramework
        });

        if (changes.length === 0) {
          // No changes detected
          console.log(chalk.green('✓ AX.MD is up to date'));
          logger.info('AX.MD unchanged', { projectName: projectInfo.name });
          return;
        }

        // Changes detected - update file
        // Generate new content
        const axMdContent = generateAXMD(projectInfo);

        // Atomic write
        await atomicWrite(axMdPath, axMdContent);

        // Format change summary
        const summary = formatChangeSummary(changes);

        // Claude Code style output
        console.log(chalk.green(`✓ Updated AX.MD ${summary}`));

        logger.info('AX.MD updated', {
          projectName: projectInfo.name,
          changes: changes.length,
          changeTypes: changes.map(c => c.type)
        });

      } else {
        // First time or --force: Create new AX.MD
        const axMdContent = generateAXMD(projectInfo);

        // Atomic write
        await atomicWrite(axMdPath, axMdContent);

        // Claude Code style output
        const projectType = projectInfo.framework || projectInfo.language;
        console.log(chalk.green(`✓ Created AX.MD (${projectType} project)`));

        logger.info('AX.MD created', {
          projectName: projectInfo.name,
          framework: projectInfo.framework,
          language: projectInfo.language,
          forced: argv.force
        });
      }

    } catch (error) {
      // Simple error message (Claude Code style)
      console.log(chalk.red('✗ Error with AX.MD'));
      logger.error('AX.MD initialization failed', { error });

      if (process.env.DEBUG || process.env.AUTOMATOSX_DEBUG) {
        printError(error);
      }

      process.exit(1);
    }
  }
};
