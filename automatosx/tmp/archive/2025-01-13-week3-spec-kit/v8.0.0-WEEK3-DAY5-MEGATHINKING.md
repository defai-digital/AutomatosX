# AutomatosX v8.0.0 - Week 3-4 Day 5 Megathinking: TestGenerator

**Date:** 2025-01-13
**Status:** Planning Phase
**Feature:** TestGenerator - Comprehensive test suite generation from workflows
**Estimated Effort:** 6-8 hours
**Priority:** P0 (Completes Spec-Kit auto-generation)

---

## üéØ MISSION

Implement **TestGenerator** to automatically generate comprehensive test suites (unit, integration, E2E) from workflow definitions, completing the Week 3-4 Spec-Kit auto-generation feature set.

**Success Criteria:**
- ‚úÖ Generate unit tests for each workflow step
- ‚úÖ Generate integration tests for phase execution
- ‚úÖ Generate end-to-end tests for full workflow
- ‚úÖ Support 3 test frameworks: Vitest, Jest, Mocha
- ‚úÖ Include mock configurations for external dependencies
- ‚úÖ Generate test fixtures and helper utilities
- ‚úÖ CLI command `ax gen tests <workflow.yaml>` functional
- ‚úÖ 100% test coverage for TestGenerator itself

---

## üìã CONTEXT

### What We've Built (Days 1-4)

**Day 1: PlanGenerator** - Execution plans with cost/time estimates
**Day 2: CostEstimator** - Detailed cost calculations
**Day 3: DAGGenerator** - Dependency graph visualization
**Day 4: ScaffoldGenerator** - Project structure generation

**Current Status:** 80% complete (4/5 generators)

### What's Missing: TestGenerator

According to the PRD (v8.0.0-spec-kit-prd.md:640-755), TestGenerator needs to:

1. **Generate unit tests** - Test each step independently
2. **Generate integration tests** - Test phase execution
3. **Generate E2E tests** - Test full workflow execution
4. **Support multiple frameworks** - Vitest, Jest, Mocha
5. **Mock external dependencies** - Providers, agents, file system
6. **Generate test fixtures** - Sample data for testing
7. **Include coverage configuration** - Coverage thresholds and reporting

### Why This Matters

**Problem:** Users need to manually write 50-100+ tests for complex workflows
**Solution:** Auto-generate comprehensive test suites in <20 seconds
**Impact:** 10x faster test creation, 100% coverage guarantee

---

## üèóÔ∏è ARCHITECTURE DESIGN

### Component Overview

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    TestGenerator                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                          ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ  TestAnalyzer    ‚îÇ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∂‚îÇ  TestBuilder     ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  (Analyze steps) ‚îÇ      ‚îÇ  (Generate code) ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ          ‚îÇ                          ‚îÇ                   ‚îÇ
‚îÇ          ‚ñº                          ‚ñº                   ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       ‚îÇ
‚îÇ  ‚îÇ  MockGenerator   ‚îÇ      ‚îÇ  FixtureBuilder  ‚îÇ       ‚îÇ
‚îÇ  ‚îÇ  (Create mocks)  ‚îÇ      ‚îÇ  (Test data)     ‚îÇ       ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       ‚îÇ
‚îÇ          ‚îÇ                          ‚îÇ                   ‚îÇ
‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                   ‚îÇ
‚îÇ                     ‚ñº                                    ‚îÇ
‚îÇ          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê                           ‚îÇ
‚îÇ          ‚îÇ   FileWriter     ‚îÇ                           ‚îÇ
‚îÇ          ‚îÇ  (Write tests)   ‚îÇ                           ‚îÇ
‚îÇ          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                      ‚îÇ
                      ‚ñº
              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
              ‚îÇ  Test Files  ‚îÇ
              ‚îÇ  - unit.test ‚îÇ
              ‚îÇ  - int.test  ‚îÇ
              ‚îÇ  - e2e.test  ‚îÇ
              ‚îÇ  - mocks/    ‚îÇ
              ‚îÇ  - fixtures/ ‚îÇ
              ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Core Classes

#### 1. TestGenerator (Main Orchestrator)

**Location:** `src/speckit/generators/TestGenerator.ts`

**Responsibilities:**
- Parse workflow definition
- Analyze steps and dependencies
- Coordinate test generation across types
- Write test files to disk
- Generate supporting files (mocks, fixtures, config)

**Interface:**
```typescript
export class TestGenerator {
  constructor(
    private workflowParser: WorkflowParser,
    private testAnalyzer: TestAnalyzer,
    private testBuilder: TestBuilder
  ) {}

  async generateTests(
    workflow: WorkflowDefinition,
    options: TestOptions
  ): Promise<TestResult>;

  private analyzeWorkflow(workflow: WorkflowDefinition): TestAnalysis;
  private generateUnitTests(analysis: TestAnalysis, options: TestOptions): string;
  private generateIntegrationTests(analysis: TestAnalysis, options: TestOptions): string;
  private generateE2ETests(analysis: TestAnalysis, options: TestOptions): string;
  private generateMocks(analysis: TestAnalysis, options: TestOptions): MockFile[];
  private generateFixtures(analysis: TestAnalysis, options: TestOptions): FixtureFile[];
}
```

#### 2. TestAnalyzer (Workflow Analysis)

**Location:** `src/speckit/utils/TestAnalyzer.ts`

**Responsibilities:**
- Extract testable units from workflow
- Identify dependencies between steps
- Determine required mocks
- Calculate test coverage needs

**Interface:**
```typescript
export class TestAnalyzer {
  analyze(workflow: WorkflowDefinition): TestAnalysis;

  private extractTestableSteps(steps: WorkflowStep[]): TestableStep[];
  private identifyPhases(steps: WorkflowStep[]): TestPhase[];
  private findDependencies(step: WorkflowStep): string[];
  private calculateCoverageNeeds(steps: WorkflowStep[]): CoverageRequirements;
}

export interface TestAnalysis {
  steps: TestableStep[];
  phases: TestPhase[];
  dependencies: Map<string, string[]>;
  requiredMocks: MockRequirement[];
  coverageNeeds: CoverageRequirements;
}

export interface TestableStep {
  id: string;
  name: string;
  agent: string;
  action: string;
  config: Record<string, unknown>;
  dependencies: string[];
  hasSideEffects: boolean;
  requiresMocks: string[];
}

export interface TestPhase {
  number: number;
  name: string;
  steps: string[];
  canParallelize: boolean;
}
```

#### 3. TestBuilder (Code Generation)

**Location:** `src/speckit/utils/TestBuilder.ts`

**Responsibilities:**
- Generate test code for each framework
- Build assertions and expectations
- Create setup/teardown code
- Format code with proper imports

**Interface:**
```typescript
export class TestBuilder {
  constructor(private framework: TestFramework) {}

  buildUnitTest(step: TestableStep, options: BuildOptions): string;
  buildIntegrationTest(phase: TestPhase, options: BuildOptions): string;
  buildE2ETest(workflow: WorkflowDefinition, options: BuildOptions): string;

  private buildImports(dependencies: string[]): string;
  private buildSetup(step: TestableStep): string;
  private buildAssertion(expectation: TestExpectation): string;
  private buildMockSetup(mocks: MockRequirement[]): string;
  private formatCode(code: string): string;
}

export type TestFramework = 'vitest' | 'jest' | 'mocha';

export interface BuildOptions {
  framework: TestFramework;
  includeMocks: boolean;
  includeFixtures: boolean;
  coverageThreshold: number;
}
```

#### 4. MockGenerator (Mock Creation)

**Location:** `src/speckit/utils/MockGenerator.ts`

**Responsibilities:**
- Generate mock implementations for agents
- Mock provider responses
- Mock file system operations
- Create spy/stub configurations

**Interface:**
```typescript
export class MockGenerator {
  generateAgentMock(agent: string, framework: TestFramework): string;
  generateProviderMock(provider: string, framework: TestFramework): string;
  generateDatabaseMock(framework: TestFramework): string;

  private buildViMock(name: string, methods: string[]): string;
  private buildJestMock(name: string, methods: string[]): string;
  private buildMochaMock(name: string, methods: string[]): string;
}

export interface MockRequirement {
  type: 'agent' | 'provider' | 'database' | 'filesystem';
  name: string;
  methods: string[];
}
```

#### 5. FixtureBuilder (Test Data)

**Location:** `src/speckit/utils/FixtureBuilder.ts`

**Responsibilities:**
- Generate sample workflow definitions
- Create sample step configurations
- Build expected output fixtures
- Generate edge case data

**Interface:**
```typescript
export class FixtureBuilder {
  buildWorkflowFixture(workflow: WorkflowDefinition): WorkflowFixture;
  buildStepFixture(step: WorkflowStep): StepFixture;
  buildErrorFixtures(): ErrorFixture[];
  buildEdgeCaseFixtures(): EdgeCaseFixture[];
}

export interface WorkflowFixture {
  name: string;
  definition: WorkflowDefinition;
  expectedOutput: unknown;
  expectedDuration: number;
  expectedCost: number;
}
```

---

## üìù TYPE DEFINITIONS

**File:** `src/speckit/types/speckit.types.ts` (extend existing)

```typescript
// ==================== TestGenerator Types ====================

export interface TestOptions extends BaseGeneratorOptions {
  framework?: TestFramework;
  includeUnit?: boolean;
  includeIntegration?: boolean;
  includeE2E?: boolean;
  includeMocks?: boolean;
  includeFixtures?: boolean;
  coverageThreshold?: number;
  outputPath?: string;
}

export type TestFramework = 'vitest' | 'jest' | 'mocha';

export interface TestResult {
  outputPath: string;
  createdFiles: string[];
  testCount: number;
  estimatedCoverage: number;
  summary: string;
}

export interface TestFile {
  path: string;
  content: string;
  testCount: number;
  framework: TestFramework;
}

export interface MockFile {
  path: string;
  content: string;
  mockType: 'agent' | 'provider' | 'database' | 'filesystem';
}

export interface FixtureFile {
  path: string;
  content: string;
  fixtureType: 'workflow' | 'step' | 'error' | 'edge-case';
}

export interface TestAnalysis {
  steps: TestableStep[];
  phases: TestPhase[];
  dependencies: Map<string, string[]>;
  requiredMocks: MockRequirement[];
  coverageNeeds: CoverageRequirements;
}

export interface TestableStep {
  id: string;
  name: string;
  agent: string;
  action: string;
  config: Record<string, unknown>;
  dependencies: string[];
  hasSideEffects: boolean;
  requiresMocks: string[];
  estimatedDuration: number;
}

export interface TestPhase {
  number: number;
  name: string;
  steps: string[];
  canParallelize: boolean;
  estimatedDuration: number;
}

export interface MockRequirement {
  type: 'agent' | 'provider' | 'database' | 'filesystem';
  name: string;
  methods: string[];
}

export interface CoverageRequirements {
  statements: number;
  branches: number;
  functions: number;
  lines: number;
}

export interface TestExpectation {
  type: 'success' | 'error' | 'timeout' | 'value' | 'type';
  value?: unknown;
  matcher: string;
  message?: string;
}
```

---

## üé® TEST GENERATION TEMPLATES

### 1. Unit Test Template (Vitest)

```typescript
// Template for step-level unit tests
export const VITEST_UNIT_TEMPLATE = `
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { WorkflowEngineV2 } from '../../../services/WorkflowEngineV2.js';
import type { WorkflowDefinition } from '../../../speckit/types/speckit.types.js';

describe('{{workflowName}} - Unit Tests', () => {
  let engine: WorkflowEngineV2;

  beforeEach(() => {
    // Setup test environment
    engine = new WorkflowEngineV2(/* mock dependencies */);
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  {{#each steps}}
  describe('Step: {{this.name}}', () => {
    it('should execute successfully with valid input', async () => {
      const result = await engine.executeStep('{{this.id}}', {{json this.config}});
      expect(result.success).toBe(true);
      expect(result.output).toBeDefined();
    });

    it('should handle errors gracefully', async () => {
      // Mock failure scenario
      const mockError = new Error('Simulated failure');
      vi.spyOn(engine, 'executeStep').mockRejectedValue(mockError);

      await expect(
        engine.executeStep('{{this.id}}', {})
      ).rejects.toThrow('Simulated failure');
    });

    it('should respect timeout configuration', async () => {
      const timeout = {{this.timeout}} || 30000;
      const startTime = Date.now();

      await engine.executeStep('{{this.id}}', { timeout });

      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(timeout + 1000); // 1s buffer
    });

    {{#if this.retryConfig}}
    it('should retry on transient failures', async () => {
      let attempts = 0;
      vi.spyOn(engine, 'executeStep').mockImplementation(async () => {
        attempts++;
        if (attempts <= {{this.retryConfig.maxRetries}}) {
          throw new Error('Transient error');
        }
        return { success: true, output: {} };
      });

      const result = await engine.executeStep('{{this.id}}', {});
      expect(attempts).toBe({{inc this.retryConfig.maxRetries}});
      expect(result.success).toBe(true);
    });
    {{/if}}

    {{#if this.dependencies}}
    it('should fail if dependencies are not satisfied', async () => {
      // Mock unsatisfied dependencies
      const dependencies = {{json this.dependencies}};

      await expect(
        engine.executeStep('{{this.id}}', { skipDependencyCheck: false })
      ).rejects.toThrow('Dependencies not satisfied');
    });
    {{/if}}
  });
  {{/each}}
});
`;
```

### 2. Integration Test Template (Vitest)

```typescript
export const VITEST_INTEGRATION_TEMPLATE = `
import { describe, it, expect, vi, beforeAll, afterAll } from 'vitest';
import { WorkflowEngineV2 } from '../../../services/WorkflowEngineV2.js';
import type { WorkflowDefinition } from '../../../speckit/types/speckit.types.js';

describe('{{workflowName}} - Integration Tests', () => {
  let engine: WorkflowEngineV2;

  beforeAll(async () => {
    // Setup integration test environment
    engine = new WorkflowEngineV2(/* real dependencies */);
  });

  afterAll(async () => {
    // Cleanup
    await engine.cleanup();
  });

  {{#each phases}}
  describe('Phase {{this.number}}: {{this.name}}', () => {
    it('should execute all steps in phase', async () => {
      const stepIds = {{json this.steps}};

      for (const stepId of stepIds) {
        const result = await engine.executeStep(stepId, {});
        expect(result.success).toBe(true);
      }
    });

    {{#if this.canParallelize}}
    it('should execute steps in parallel when possible', async () => {
      const stepIds = {{json this.steps}};
      const startTime = Date.now();

      const results = await Promise.all(
        stepIds.map(id => engine.executeStep(id, {}))
      );

      const duration = Date.now() - startTime;
      const sequentialDuration = {{this.estimatedDuration}};

      // Parallel execution should be faster
      expect(duration).toBeLessThan(sequentialDuration * 0.7);
      expect(results.every(r => r.success)).toBe(true);
    });
    {{/if}}

    it('should maintain correct execution order', async () => {
      const executionOrder: string[] = [];
      const originalExecute = engine.executeStep.bind(engine);

      vi.spyOn(engine, 'executeStep').mockImplementation(async (stepId, config) => {
        executionOrder.push(stepId);
        return originalExecute(stepId, config);
      });

      await engine.executePhase({{this.number}});

      const stepIds = {{json this.steps}};
      expect(executionOrder).toEqual(expect.arrayContaining(stepIds));
    });

    it('should handle phase-level errors appropriately', async () => {
      // Mock failure in middle of phase
      const failingStepId = {{json this.steps}}[1];

      vi.spyOn(engine, 'executeStep').mockImplementation(async (stepId) => {
        if (stepId === failingStepId) {
          throw new Error('Phase failure');
        }
        return { success: true, output: {} };
      });

      await expect(
        engine.executePhase({{this.number}})
      ).rejects.toThrow('Phase failure');
    });
  });
  {{/each}}
});
`;
```

### 3. E2E Test Template (Vitest)

```typescript
export const VITEST_E2E_TEMPLATE = `
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { WorkflowEngineV2 } from '../../../services/WorkflowEngineV2.js';
import { CheckpointServiceV2 } from '../../../services/CheckpointServiceV2.js';
import type { WorkflowDefinition } from '../../../speckit/types/speckit.types.js';

describe('{{workflowName}} - E2E Tests', () => {
  let engine: WorkflowEngineV2;
  let checkpointService: CheckpointServiceV2;

  beforeAll(async () => {
    // Setup E2E environment with real services
    checkpointService = new CheckpointServiceV2(/* real DB */);
    engine = new WorkflowEngineV2(/* real dependencies */, checkpointService);
  });

  afterAll(async () => {
    await engine.cleanup();
    await checkpointService.cleanup();
  });

  it('should execute complete workflow successfully', async () => {
    const workflowPath = 'workflows/{{kebabCase workflowName}}.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result.success).toBe(true);
    expect(result.completedSteps).toBe({{stepCount}});
    expect(result.failedSteps).toBe(0);
    expect(result.duration).toBeGreaterThan(0);
  });

  it('should create checkpoints at each phase', async () => {
    const workflowPath = 'workflows/{{kebabCase workflowName}}.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    const checkpoints = await checkpointService.listCheckpoints(result.executionId);
    expect(checkpoints.length).toBe({{phaseCount}});

    for (const checkpoint of checkpoints) {
      expect(checkpoint.phaseNumber).toBeGreaterThan(0);
      expect(checkpoint.completedSteps).toBeGreaterThan(0);
    }
  });

  it('should resume from checkpoint after failure', async () => {
    const workflowPath = 'workflows/{{kebabCase workflowName}}.yaml';

    // First run: simulate failure at step {{math stepCount "/" 2}}
    const failAtStep = {{math stepCount "/" 2}};
    let currentStep = 0;

    vi.spyOn(engine, 'executeStep').mockImplementation(async (stepId) => {
      currentStep++;
      if (currentStep === failAtStep) {
        throw new Error('Simulated mid-workflow failure');
      }
      return { success: true, output: {} };
    });

    await expect(
      engine.executeWorkflow(workflowPath)
    ).rejects.toThrow('Simulated mid-workflow failure');

    // Get checkpoint before failure
    const checkpoints = await checkpointService.listCheckpoints();
    const lastCheckpoint = checkpoints[checkpoints.length - 1];

    // Second run: resume from checkpoint
    vi.restoreAllMocks();
    const resumeResult = await engine.resumeWorkflow(lastCheckpoint.id);

    expect(resumeResult.success).toBe(true);
    expect(resumeResult.resumedFromStep).toBe(failAtStep - 1);
    expect(resumeResult.completedSteps).toBe({{stepCount}} - failAtStep + 1);
  });

  it('should respect workflow timeout', async () => {
    const workflowPath = 'workflows/{{kebabCase workflowName}}.yaml';
    const timeout = 5000; // 5 seconds

    const startTime = Date.now();

    await expect(
      engine.executeWorkflow(workflowPath, { timeout })
    ).rejects.toThrow('Workflow timeout');

    const duration = Date.now() - startTime;
    expect(duration).toBeGreaterThanOrEqual(timeout);
    expect(duration).toBeLessThan(timeout + 2000); // 2s buffer
  });

  it('should produce expected output structure', async () => {
    const workflowPath = 'workflows/{{kebabCase workflowName}}.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result).toMatchObject({
      success: true,
      executionId: expect.any(String),
      workflowName: '{{workflowName}}',
      startTime: expect.any(Date),
      endTime: expect.any(Date),
      duration: expect.any(Number),
      completedSteps: {{stepCount}},
      failedSteps: 0,
      output: expect.any(Object),
    });
  });

  it('should calculate accurate cost and duration', async () => {
    const workflowPath = 'workflows/{{kebabCase workflowName}}.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result.cost).toBeGreaterThan(0);
    expect(result.cost).toBeLessThan({{estimatedCost}} * 1.5); // Within 50% of estimate

    expect(result.duration).toBeGreaterThan(0);
    expect(result.duration).toBeLessThan({{estimatedDuration}} * 1.5); // Within 50% of estimate
  });
});
`;
```

### 4. Mock Template

```typescript
export const VITEST_MOCK_TEMPLATE = `
import { vi } from 'vitest';
import type { {{mockType}} } from '../../../types/{{mockType}}.types.js';

/**
 * Mock {{mockType}}: {{mockName}}
 * Generated by AutomatosX v8.0.0 TestGenerator
 */
export const mock{{pascalCase mockName}} = (): {{mockType}} => {
  return {
    {{#each methods}}
    {{this}}: vi.fn().mockResolvedValue({ success: true, output: {} }),
    {{/each}}
  } as unknown as {{mockType}};
};

/**
 * Mock {{mockType}} with custom behavior
 */
export const mock{{pascalCase mockName}}WithBehavior = (
  behavior: Partial<Record<keyof {{mockType}}, any>>
): {{mockType}} => {
  const baseMock = mock{{pascalCase mockName}}();

  Object.entries(behavior).forEach(([method, impl]) => {
    (baseMock as any)[method] = vi.fn().mockImplementation(impl);
  });

  return baseMock;
};
`;
```

---

## üîß IMPLEMENTATION PLAN

### Phase 1: Type Definitions & Core Structure (1 hour)

**Tasks:**
1. Extend `src/speckit/types/speckit.types.ts` with TestGenerator types
2. Create file structure:
   - `src/speckit/generators/TestGenerator.ts`
   - `src/speckit/utils/TestAnalyzer.ts`
   - `src/speckit/utils/TestBuilder.ts`
   - `src/speckit/utils/MockGenerator.ts`
   - `src/speckit/utils/FixtureBuilder.ts`

**Deliverable:** Type-safe skeleton with interfaces

### Phase 2: TestAnalyzer Implementation (1.5 hours)

**Tasks:**
1. Implement `TestAnalyzer.analyze()` - workflow analysis
2. Extract testable steps with dependency detection
3. Identify execution phases for integration tests
4. Determine required mocks based on agents/providers
5. Calculate coverage requirements

**Deliverable:** Working TestAnalyzer with complete analysis

### Phase 3: TestBuilder Implementation (2 hours)

**Tasks:**
1. Implement `TestBuilder` for Vitest (primary)
2. Generate unit test code from templates
3. Generate integration test code from templates
4. Generate E2E test code from templates
5. Add Jest adapter (80% code reuse from Vitest)
6. Add Mocha adapter (60% code reuse, different syntax)

**Deliverable:** TestBuilder supporting 3 frameworks

### Phase 4: MockGenerator & FixtureBuilder (1 hour)

**Tasks:**
1. Implement `MockGenerator` for agents, providers, database
2. Generate mock factory functions
3. Implement `FixtureBuilder` for workflow fixtures
4. Generate step fixtures and edge cases

**Deliverable:** Mock and fixture generation

### Phase 5: TestGenerator Main Class (1 hour)

**Tasks:**
1. Implement `TestGenerator.generateTests()` orchestrator
2. Coordinate analyzer ‚Üí builder ‚Üí writer pipeline
3. Write test files to disk with proper directory structure
4. Generate package.json test scripts
5. Generate vitest.config.ts or jest.config.js

**Deliverable:** Complete TestGenerator

### Phase 6: CLI Integration (0.5 hours)

**Tasks:**
1. Add `createTestsCommand()` to `src/cli/commands/gen.ts`
2. Register command with options parsing
3. Format CLI output with file tree and test count
4. Add examples to help text

**Deliverable:** `ax gen tests` command working

### Phase 7: Comprehensive Testing (2 hours)

**Tasks:**
1. Write unit tests for TestAnalyzer (8 tests)
2. Write unit tests for TestBuilder (12 tests)
3. Write unit tests for MockGenerator (4 tests)
4. Write unit tests for FixtureBuilder (3 tests)
5. Write integration tests for full pipeline (5 tests)
6. Test all 3 frameworks (Vitest, Jest, Mocha)

**Deliverable:** 32+ tests, 100% coverage

### Phase 8: Documentation & Polish (0.5 hours)

**Tasks:**
1. Create completion document `v8.0.0-WEEK3-DAY5-COMPLETE.md`
2. Add inline code documentation (JSDoc)
3. Update `automatosx/PRD/README.md` with TestGenerator status
4. Create example workflows with generated tests

**Deliverable:** Complete documentation

---

## üìä FILE STRUCTURE

```
src/speckit/
‚îú‚îÄ‚îÄ generators/
‚îÇ   ‚îú‚îÄ‚îÄ PlanGenerator.ts              ‚úÖ Day 1
‚îÇ   ‚îú‚îÄ‚îÄ DAGGenerator.ts               ‚úÖ Day 3
‚îÇ   ‚îú‚îÄ‚îÄ ScaffoldGenerator.ts          ‚úÖ Day 4
‚îÇ   ‚îî‚îÄ‚îÄ TestGenerator.ts              ‚è≥ Day 5 (NEW - 350 lines)
‚îÇ
‚îú‚îÄ‚îÄ utils/
‚îÇ   ‚îú‚îÄ‚îÄ CostEstimator.ts              ‚úÖ Day 2
‚îÇ   ‚îú‚îÄ‚îÄ DependencyGraph.ts            ‚úÖ Day 3
‚îÇ   ‚îú‚îÄ‚îÄ TemplateRegistry.ts           ‚úÖ Day 4
‚îÇ   ‚îú‚îÄ‚îÄ StructureBuilder.ts           ‚úÖ Day 4
‚îÇ   ‚îú‚îÄ‚îÄ TemplateRenderer.ts           ‚úÖ Day 4
‚îÇ   ‚îú‚îÄ‚îÄ FileWriter.ts                 ‚úÖ Day 4
‚îÇ   ‚îú‚îÄ‚îÄ TestAnalyzer.ts               ‚è≥ Day 5 (NEW - 200 lines)
‚îÇ   ‚îú‚îÄ‚îÄ TestBuilder.ts                ‚è≥ Day 5 (NEW - 300 lines)
‚îÇ   ‚îú‚îÄ‚îÄ MockGenerator.ts              ‚è≥ Day 5 (NEW - 150 lines)
‚îÇ   ‚îî‚îÄ‚îÄ FixtureBuilder.ts             ‚è≥ Day 5 (NEW - 120 lines)
‚îÇ
‚îú‚îÄ‚îÄ types/
‚îÇ   ‚îî‚îÄ‚îÄ speckit.types.ts              ‚è≥ Day 5 (+150 lines)
‚îÇ
‚îî‚îÄ‚îÄ __tests__/
    ‚îú‚îÄ‚îÄ PlanGenerator.test.ts         ‚úÖ Day 1
    ‚îú‚îÄ‚îÄ CostEstimator.test.ts         ‚úÖ Day 2
    ‚îú‚îÄ‚îÄ DAGGenerator.test.ts          ‚úÖ Day 3
    ‚îú‚îÄ‚îÄ ScaffoldGenerator.test.ts     ‚úÖ Day 4
    ‚îî‚îÄ‚îÄ TestGenerator.test.ts         ‚è≥ Day 5 (NEW - 400 lines)

src/cli/commands/
‚îî‚îÄ‚îÄ gen.ts                            ‚è≥ Day 5 (+80 lines for tests command)

automatosx/tmp/
‚îî‚îÄ‚îÄ v8.0.0-WEEK3-DAY5-COMPLETE.md     ‚è≥ Day 5 (NEW)
```

**Total New Code:**
- TestGenerator.ts: 350 lines
- TestAnalyzer.ts: 200 lines
- TestBuilder.ts: 300 lines
- MockGenerator.ts: 150 lines
- FixtureBuilder.ts: 120 lines
- TestGenerator.test.ts: 400 lines
- Type definitions: +150 lines
- CLI integration: +80 lines

**Total:** ~1,750 lines of production code + tests

---

## üß™ TESTING STRATEGY

### Unit Tests (32 tests)

**TestAnalyzer Tests (8):**
```typescript
describe('TestAnalyzer', () => {
  it('should extract testable steps from workflow');
  it('should identify execution phases');
  it('should detect step dependencies');
  it('should determine required mocks for agents');
  it('should determine required mocks for providers');
  it('should calculate coverage requirements');
  it('should handle workflows with no dependencies');
  it('should handle complex dependency graphs');
});
```

**TestBuilder Tests (12):**
```typescript
describe('TestBuilder', () => {
  describe('Unit Tests', () => {
    it('should generate Vitest unit test');
    it('should generate Jest unit test');
    it('should generate Mocha unit test');
    it('should include retry logic tests when configured');
  });

  describe('Integration Tests', () => {
    it('should generate Vitest integration test');
    it('should generate Jest integration test');
    it('should handle parallel execution tests');
  });

  describe('E2E Tests', () => {
    it('should generate Vitest E2E test');
    it('should include checkpoint/resume tests');
    it('should include timeout tests');
    it('should include cost/duration validation');
  });

  it('should format code with proper imports');
  it('should handle edge cases in code generation');
});
```

**MockGenerator Tests (4):**
```typescript
describe('MockGenerator', () => {
  it('should generate agent mocks for Vitest');
  it('should generate provider mocks for Jest');
  it('should generate database mocks');
  it('should generate custom behavior mocks');
});
```

**FixtureBuilder Tests (3):**
```typescript
describe('FixtureBuilder', () => {
  it('should build workflow fixtures');
  it('should build step fixtures');
  it('should build error fixtures');
});
```

**TestGenerator Tests (5):**
```typescript
describe('TestGenerator', () => {
  it('should generate complete test suite');
  it('should respect framework option');
  it('should write tests to disk');
  it('should generate mocks when requested');
  it('should generate fixtures when requested');
});
```

### Integration Tests (5)

```typescript
describe('TestGenerator Integration', () => {
  it('should generate tests for simple workflow', async () => {
    const workflow = {
      name: 'Simple Test',
      steps: [{ id: 'step-1', name: 'Test Step', agent: 'backend', action: 'test', config: {} }]
    };

    const result = await testGenerator.generateTests(workflow, {
      framework: 'vitest',
      outputPath: './test-output'
    });

    expect(result.testCount).toBe(9); // 3 unit + 3 int + 3 e2e
    expect(result.createdFiles).toContain('unit.test.ts');
    expect(result.createdFiles).toContain('integration.test.ts');
    expect(result.createdFiles).toContain('e2e.test.ts');
  });

  it('should generate tests for complex workflow with dependencies');
  it('should generate mocks for all agents');
  it('should generate fixtures for all steps');
  it('should support all three frameworks (Vitest, Jest, Mocha)');
});
```

---

## üéØ CLI OUTPUT DESIGN

```bash
$ ax gen tests workflows/security-audit.yaml --framework vitest --output tests/workflows

‚úì Loaded workflow: Security Audit (v1.0.0)
‚úì Analyzing workflow structure...
‚úì Generating test suite...

‚úÖ Test Suite Generated Successfully!

üìä Summary:
   Framework: Vitest
   Output Path: tests/workflows/security-audit/

üì¶ Generated Files:

tests/workflows/security-audit/
‚îú‚îÄ‚îÄ üìÑ unit.test.ts (45 tests)
‚îÇ   ‚îú‚îÄ Step: Scan Dependencies (5 tests)
‚îÇ   ‚îú‚îÄ Step: Analyze Code (5 tests)
‚îÇ   ‚îú‚îÄ Step: Check Secrets (5 tests)
‚îÇ   ‚îî‚îÄ ... (6 more steps)
‚îÇ
‚îú‚îÄ‚îÄ üìÑ integration.test.ts (12 tests)
‚îÇ   ‚îú‚îÄ Phase 1: Setup (3 tests)
‚îÇ   ‚îú‚îÄ Phase 2: Scanning (3 tests)
‚îÇ   ‚îî‚îÄ ... (2 more phases)
‚îÇ
‚îú‚îÄ‚îÄ üìÑ e2e.test.ts (6 tests)
‚îÇ   ‚îú‚îÄ Full workflow execution
‚îÇ   ‚îú‚îÄ Checkpoint/resume
‚îÇ   ‚îú‚îÄ Timeout handling
‚îÇ   ‚îî‚îÄ Cost/duration validation
‚îÇ
‚îú‚îÄ‚îÄ üìÇ mocks/
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ securityAgent.mock.ts
‚îÇ   ‚îú‚îÄ‚îÄ üìÑ qualityAgent.mock.ts
‚îÇ   ‚îî‚îÄ‚îÄ üìÑ providerRouter.mock.ts
‚îÇ
‚îî‚îÄ‚îÄ üìÇ fixtures/
    ‚îú‚îÄ‚îÄ üìÑ workflow.fixture.ts
    ‚îú‚îÄ‚îÄ üìÑ steps.fixture.ts
    ‚îî‚îÄ‚îÄ üìÑ errors.fixture.ts

üìà Test Coverage:
   Total Tests: 63
   Unit Tests: 45
   Integration Tests: 12
   E2E Tests: 6
   Estimated Coverage: 95%

üí° Next Steps:
   1. Review: tests/workflows/security-audit/
   2. Run: npm test -- tests/workflows/security-audit/
   3. Adjust: Customize mocks and fixtures as needed
```

---

## üö® EDGE CASES & ERROR HANDLING

### Edge Cases

1. **Empty Workflow**
   - Workflow with no steps ‚Üí Generate minimal test file with skip message

2. **Single Step Workflow**
   - Generate unit tests only, skip integration/phase tests

3. **Circular Dependencies**
   - Detect cycles in analyzer ‚Üí Throw error with helpful message

4. **Unknown Agent**
   - Agent not in registry ‚Üí Generate generic mock with warning

5. **Framework Not Installed**
   - Check package.json ‚Üí Warn user to install framework first

### Error Handling

```typescript
export class TestGeneratorError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'TestGeneratorError';
  }
}

// Error codes:
// - INVALID_WORKFLOW: Workflow validation failed
// - CIRCULAR_DEPENDENCY: Circular dependency detected
// - UNKNOWN_FRAMEWORK: Unsupported test framework
// - ANALYSIS_FAILED: Workflow analysis failed
// - GENERATION_FAILED: Test code generation failed
// - WRITE_FAILED: File write operation failed
```

---

## üìà SUCCESS METRICS

### Quality Metrics

- ‚úÖ Generated tests are syntactically valid (100%)
- ‚úÖ Generated tests execute without errors (>95%)
- ‚úÖ Coverage estimation accuracy within ¬±10%
- ‚úÖ All 3 frameworks supported (Vitest, Jest, Mocha)

### Performance Metrics

- ‚úÖ Test generation completes in <20 seconds
- ‚úÖ Generated test files are <2000 lines each
- ‚úÖ Mock generation is <2 seconds

### Usability Metrics

- ‚úÖ CLI output is clear and actionable
- ‚úÖ Generated code follows best practices
- ‚úÖ Test files are readable and well-organized

---

## üéâ DELIVERABLES CHECKLIST

### Code Files
- [ ] `src/speckit/generators/TestGenerator.ts` (350 lines)
- [ ] `src/speckit/utils/TestAnalyzer.ts` (200 lines)
- [ ] `src/speckit/utils/TestBuilder.ts` (300 lines)
- [ ] `src/speckit/utils/MockGenerator.ts` (150 lines)
- [ ] `src/speckit/utils/FixtureBuilder.ts` (120 lines)
- [ ] `src/speckit/types/speckit.types.ts` (+150 lines)
- [ ] `src/cli/commands/gen.ts` (+80 lines)

### Test Files
- [ ] `src/speckit/__tests__/TestGenerator.test.ts` (400 lines)
- [ ] All 32 unit tests passing
- [ ] All 5 integration tests passing

### Documentation
- [ ] `automatosx/tmp/v8.0.0-WEEK3-DAY5-COMPLETE.md`
- [ ] JSDoc comments for all public APIs
- [ ] CLI help text and examples

### Integration
- [ ] CLI command `ax gen tests` functional
- [ ] All 3 frameworks (Vitest, Jest, Mocha) working
- [ ] Example workflows with generated tests

---

## üî• RISKS & MITIGATION

### Risk 1: Test Template Complexity

**Risk:** Templates become too complex to maintain
**Mitigation:**
- Keep templates simple with Handlebars
- Use composition over monolithic templates
- Extract common patterns into helpers

### Risk 2: Framework Differences

**Risk:** Significant differences between Vitest/Jest/Mocha
**Mitigation:**
- Start with Vitest (primary)
- Abstract common patterns
- Use adapters for framework-specific syntax

### Risk 3: Mock Accuracy

**Risk:** Generated mocks don't match actual interfaces
**Mitigation:**
- Use TypeScript type checking
- Generate mocks from AgentRegistry metadata
- Include validation in tests

---

## üí° FUTURE ENHANCEMENTS (P2)

**Not in scope for Day 5, but nice to have:**

1. **Visual Test Reports**
   - Generate HTML coverage reports
   - Test result dashboards

2. **Performance Tests**
   - Generate load/stress tests
   - Benchmark generation

3. **Mutation Testing**
   - Generate mutation test configurations
   - Code mutation strategies

4. **Snapshot Testing**
   - Generate snapshot tests for outputs
   - Visual regression tests

5. **Custom Test Templates**
   - User-provided templates
   - Template marketplace

---

## üéØ CONCLUSION

**Objective:** Complete Week 3-4 Spec-Kit implementation with TestGenerator

**Effort:** 6-8 hours
- Type definitions: 1 hour
- TestAnalyzer: 1.5 hours
- TestBuilder: 2 hours
- MockGenerator & FixtureBuilder: 1 hour
- TestGenerator main: 1 hour
- CLI integration: 0.5 hours
- Testing: 2 hours
- Documentation: 0.5 hours

**Deliverables:**
- 1,750 lines of production code
- 32+ tests with 100% coverage
- CLI command `ax gen tests` functional
- 3 framework support (Vitest, Jest, Mocha)

**Impact:**
- 10x faster test creation
- 100% coverage guarantee
- Completes Spec-Kit auto-generation (5/5 generators)

**Confidence:** 95%

**Ready to implement Day 5.**

---

**Document Version:** 1.0
**Date:** 2025-01-13
**Status:** Ready for Implementation
**Next:** Begin Phase 1 - Type Definitions
