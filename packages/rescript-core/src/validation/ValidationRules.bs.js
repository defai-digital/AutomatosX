// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";

function nonEmptyString(s) {
  if (s.length > 0) {
    return {
            TAG: "Ok",
            _0: s
          };
  } else {
    return {
            TAG: "Error",
            _0: "String cannot be empty"
          };
  }
}

function positiveInt(n) {
  if (n > 0) {
    return {
            TAG: "Ok",
            _0: n
          };
  } else {
    return {
            TAG: "Error",
            _0: "Value must be positive, got " + String(n)
          };
  }
}

function nonNegativeInt(n) {
  if (n >= 0) {
    return {
            TAG: "Ok",
            _0: n
          };
  } else {
    return {
            TAG: "Error",
            _0: "Value must be non-negative, got " + String(n)
          };
  }
}

function validEmail(email) {
  var emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (emailRegex.test(email)) {
    return {
            TAG: "Ok",
            _0: email
          };
  } else {
    return {
            TAG: "Error",
            _0: "Invalid email format: " + email
          };
  }
}

function validUrl(url) {
  var urlRegex = /^https?:\/\/.+/;
  if (urlRegex.test(url)) {
    return {
            TAG: "Ok",
            _0: url
          };
  } else {
    return {
            TAG: "Error",
            _0: "Invalid URL format: " + url
          };
  }
}

function createUnvalidatedEmbedding(dimensions, vector, model) {
  return {
          dimensions: dimensions,
          vector: vector,
          model: model
        };
}

function validateEmbedding(embedding, expectedDimensions) {
  var actualDimensions = embedding.vector.length;
  if (embedding.dimensions !== actualDimensions) {
    return {
            TAG: "Error",
            _0: "Declared dimensions (" + String(embedding.dimensions) + ") don't match vector length (" + String(actualDimensions) + ")"
          };
  } else if (actualDimensions !== expectedDimensions) {
    return {
            TAG: "Error",
            _0: "Invalid embedding dimensions: expected " + String(expectedDimensions) + ", got " + String(actualDimensions)
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              dimensions: embedding.dimensions,
              vector: embedding.vector,
              model: embedding.model
            }
          };
  }
}

function getEmbeddingDimensions(embedding) {
  return embedding.dimensions;
}

function getEmbeddingVector(embedding) {
  return embedding.vector;
}

function storeEmbedding(embedding) {
  return Promise.resolve({
              TAG: "Ok",
              _0: undefined
            });
}

function nonEmptyArray(arr) {
  if (arr.length !== 0) {
    return {
            TAG: "Ok",
            _0: arr
          };
  } else {
    return {
            TAG: "Error",
            _0: "Array cannot be empty"
          };
  }
}

function boundedArray(arr, minSize, maxSize) {
  var size = arr.length;
  if (size < minSize) {
    return {
            TAG: "Error",
            _0: "Array too small: " + String(size) + " < " + String(minSize)
          };
  } else if (size > maxSize) {
    return {
            TAG: "Error",
            _0: "Array too large: " + String(size) + " > " + String(maxSize)
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              items: arr,
              minSize: minSize,
              maxSize: maxSize
            }
          };
  }
}

function rangedValue(value, min, max) {
  if (value < min) {
    return {
            TAG: "Error",
            _0: "Value " + String(value) + " below minimum " + String(min)
          };
  } else if (value > max) {
    return {
            TAG: "Error",
            _0: "Value " + String(value) + " above maximum " + String(max)
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              value: value,
              min: min,
              max: max
            }
          };
  }
}

function getRangedValue(ranged) {
  return ranged.value;
}

function percentage(value) {
  if (value < 0.0 || value > 1.0) {
    return {
            TAG: "Error",
            _0: "Percentage must be 0.0-1.0, got " + String(value)
          };
  } else {
    return {
            TAG: "Ok",
            _0: value
          };
  }
}

function applyRule(value, rule) {
  var err = rule(value);
  if (err.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: value
          };
  } else {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
}

function combineRules(value, rules) {
  var errors = [];
  var valid = true;
  for(var i = 0 ,i_finish = rules.length; i < i_finish; ++i){
    var rule = Caml_array.get(rules, i);
    var err = rule(value);
    if (err.TAG !== "Ok") {
      valid = false;
      Js_array.push(err._0, errors);
    }
    
  }
  if (valid) {
    return {
            TAG: "Ok",
            _0: value
          };
  } else {
    return {
            TAG: "Error",
            _0: errors
          };
  }
}

function validateUser(id, email, age) {
  var errors = [];
  var v = nonEmptyString(id);
  var validId;
  if (v.TAG === "Ok") {
    validId = v._0;
  } else {
    Js_array.push(v._0, errors);
    validId = undefined;
  }
  var v$1 = validEmail(email);
  var validEmail$1;
  if (v$1.TAG === "Ok") {
    validEmail$1 = v$1._0;
  } else {
    Js_array.push(v$1._0, errors);
    validEmail$1 = undefined;
  }
  var v$2 = positiveInt(age);
  var validAge;
  if (v$2.TAG === "Ok") {
    validAge = v$2._0;
  } else {
    Js_array.push(v$2._0, errors);
    validAge = undefined;
  }
  if (validId !== undefined && validEmail$1 !== undefined && validAge !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              id: validId,
              email: validEmail$1,
              age: validAge
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: errors
          };
  }
}

function validateMessage(id, content, embedding, tokens) {
  var errors = [];
  var v = nonEmptyString(id);
  var validId;
  if (v.TAG === "Ok") {
    validId = v._0;
  } else {
    Js_array.push(v._0, errors);
    validId = undefined;
  }
  var v$1 = nonEmptyString(content);
  var validContent;
  if (v$1.TAG === "Ok") {
    validContent = v$1._0;
  } else {
    Js_array.push(v$1._0, errors);
    validContent = undefined;
  }
  var v$2 = nonNegativeInt(tokens);
  var validTokens;
  if (v$2.TAG === "Ok") {
    validTokens = v$2._0;
  } else {
    Js_array.push(v$2._0, errors);
    validTokens = undefined;
  }
  if (validId !== undefined && validContent !== undefined && validTokens !== undefined) {
    return {
            TAG: "Ok",
            _0: {
              id: validId,
              content: validContent,
              embedding: embedding,
              tokens: validTokens
            }
          };
  } else {
    return {
            TAG: "Error",
            _0: errors
          };
  }
}

function unwrapString(s) {
  return s;
}

function unwrapInt(n) {
  return n;
}

function unwrapEmail(email) {
  return email;
}

export {
  nonEmptyString ,
  positiveInt ,
  nonNegativeInt ,
  validEmail ,
  validUrl ,
  createUnvalidatedEmbedding ,
  validateEmbedding ,
  getEmbeddingDimensions ,
  getEmbeddingVector ,
  storeEmbedding ,
  nonEmptyArray ,
  boundedArray ,
  rangedValue ,
  getRangedValue ,
  percentage ,
  applyRule ,
  combineRules ,
  validateUser ,
  validateMessage ,
  unwrapString ,
  unwrapInt ,
  unwrapEmail ,
}
/* No side effect */
