// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";

function acquireResource(acquire, cleanup) {
  var err = acquire();
  if (err.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
  var value = err._0;
  var now = Date.now() | 0;
  return {
          TAG: "Ok",
          _0: {
            value: value,
            cleanup: (function () {
                cleanup(value);
              }),
            isReleased: {
              contents: false
            },
            acquiredAt: now
          }
        };
}

function releaseResource(resource) {
  if (!resource.isReleased.contents) {
    resource.cleanup();
    resource.isReleased.contents = true;
    return ;
  }
  
}

function isResourceActive(resource) {
  return !resource.isReleased.contents;
}

function getResourceAge(resource) {
  var now = Date.now() | 0;
  return now - resource.acquiredAt | 0;
}

function withResource(acquire, cleanup, use) {
  var err = acquireResource(acquire, cleanup);
  if (err.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
  var resource = err._0;
  var result = use(resource.value);
  releaseResource(resource);
  return result;
}

function withResources2(acquire1, cleanup1, acquire2, cleanup2, use) {
  return withResource(acquire1, cleanup1, (function (r1) {
                return withResource(acquire2, cleanup2, (function (r2) {
                              return use(r1, r2);
                            }));
              }));
}

function withResources3(acquire1, cleanup1, acquire2, cleanup2, acquire3, cleanup3, use) {
  return withResources2(acquire1, cleanup1, acquire2, cleanup2, (function (r1, r2) {
                return withResource(acquire3, cleanup3, (function (r3) {
                              return use(r1, r2, r3);
                            }));
              }));
}

function createPool(maxSizeOpt, factory, cleanup) {
  var maxSize = maxSizeOpt !== undefined ? maxSizeOpt : 10;
  return {
          available: {
            contents: []
          },
          inUse: {
            contents: []
          },
          maxSize: maxSize,
          factory: factory,
          cleanup: cleanup
        };
}

function borrowFromPool(pool) {
  var resource = Belt_Array.get(pool.available.contents, 0);
  if (resource !== undefined) {
    pool.available.contents = Belt_Array.sliceToEnd(pool.available.contents, 1);
    pool.inUse.contents = Belt_Array.concat(pool.inUse.contents, [resource]);
    resource.isReleased.contents = false;
    return {
            TAG: "Ok",
            _0: resource
          };
  }
  var totalSize = pool.available.contents.length + pool.inUse.contents.length | 0;
  if (totalSize >= pool.maxSize) {
    return {
            TAG: "Error",
            _0: "Resource pool exhausted (max: " + String(pool.maxSize) + ")"
          };
  }
  var err = acquireResource(pool.factory, pool.cleanup);
  if (err.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
  var resource$1 = err._0;
  pool.inUse.contents = Belt_Array.concat(pool.inUse.contents, [resource$1]);
  return {
          TAG: "Ok",
          _0: resource$1
        };
}

function returnToPool(pool, resource) {
  pool.inUse.contents = Belt_Array.keep(pool.inUse.contents, (function (r) {
          return r !== resource;
        }));
  if (!resource.isReleased.contents) {
    pool.available.contents = Belt_Array.concat(pool.available.contents, [resource]);
    return ;
  }
  
}

function withPooledResource(pool, use) {
  var err = borrowFromPool(pool);
  if (err.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: err._0
          };
  }
  var resource = err._0;
  var result = use(resource.value);
  returnToPool(pool, resource);
  return result;
}

function drainPool(pool) {
  Belt_Array.forEach(pool.available.contents, (function (resource) {
          releaseResource(resource);
        }));
  pool.available.contents = [];
  Belt_Array.forEach(pool.inUse.contents, (function (resource) {
          releaseResource(resource);
        }));
  pool.inUse.contents = [];
}

function getPoolStats(pool) {
  var available = pool.available.contents.length;
  var inUse = pool.inUse.contents.length;
  var total = available + inUse | 0;
  var utilization = pool.maxSize > 0 ? inUse / pool.maxSize * 100.0 : 0.0;
  return {
          available: available,
          inUse: inUse,
          total: total,
          capacity: pool.maxSize,
          utilizationPercent: utilization
        };
}

function createFileResource(path) {
  return {
          TAG: "Ok",
          _0: {
            path: path,
            fd: 1
          }
        };
}

function cleanupFileResource(file) {
  console.log("Closing file:", file.path);
}

function createDbConnection(connString) {
  return {
          TAG: "Ok",
          _0: {
            connectionString: connString,
            isConnected: {
              contents: true
            }
          }
        };
}

function cleanupDbConnection(conn) {
  if (conn.isConnected.contents) {
    console.log("Closing database connection");
    conn.isConnected.contents = false;
    return ;
  }
  
}

function createSocket(host, port) {
  return {
          TAG: "Ok",
          _0: {
            host: host,
            port: port,
            isOpen: {
              contents: true
            }
          }
        };
}

function cleanupSocket(socket) {
  if (socket.isOpen.contents) {
    console.log("Closing socket:", socket.host + ":" + String(socket.port));
    socket.isOpen.contents = false;
    return ;
  }
  
}

function withResourceAsync(acquire, cleanup, use) {
  var __x = acquire();
  return Js_promise.then_((function (acquireResult) {
                if (acquireResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: acquireResult._0
                            });
                }
                var value = acquireResult._0;
                var __x = use(value);
                return Js_promise.then_((function (useResult) {
                              var __x = cleanup(value);
                              return Js_promise.then_((function () {
                                            return Promise.resolve(useResult);
                                          }), __x);
                            }), __x);
              }), __x);
}

export {
  acquireResource ,
  releaseResource ,
  isResourceActive ,
  getResourceAge ,
  withResource ,
  withResources2 ,
  withResources3 ,
  createPool ,
  borrowFromPool ,
  returnToPool ,
  withPooledResource ,
  drainPool ,
  getPoolStats ,
  createFileResource ,
  cleanupFileResource ,
  createDbConnection ,
  cleanupDbConnection ,
  createSocket ,
  cleanupSocket ,
  withResourceAsync ,
}
/* No side effect */
