import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { WorkflowEngineV2 } from '../../../services/WorkflowEngineV2.js';
import { CheckpointServiceV2 } from '../../../services/CheckpointServiceV2.js';

/**
 * End-to-End Tests for Test Workflow
 * Generated by AutomatosX v8.0.0 - 2025-11-14T03:07:09.880Z
 */

describe('Test Workflow - E2E Tests', () => {
  let engine: WorkflowEngineV2;
  let checkpointService: CheckpointServiceV2;

  beforeAll(async () => {
    checkpointService = new CheckpointServiceV2();
    engine = new WorkflowEngineV2(checkpointService);
  });

  afterAll(async () => {
    await engine.cleanup();
    await checkpointService.cleanup();
  });

  it('should execute complete workflow successfully', async () => {
    const workflowPath = 'workflows/test-workflow.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result.success).toBe(true);
    expect(result.completedSteps).toBe(2);
    expect(result.failedSteps).toBe(0);
    expect(result.duration).toBeGreaterThan(0);
  });

  it('should create checkpoints at each phase', async () => {
    const workflowPath = 'workflows/test-workflow.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    const checkpoints = await checkpointService.listCheckpoints(result.executionId);
    expect(checkpoints.length).toBe(2);

    for (const checkpoint of checkpoints) {
      expect(checkpoint.phaseNumber).toBeGreaterThan(0);
      expect(checkpoint.completedSteps).toBeGreaterThan(0);
    }
  });

  it('should resume from checkpoint after failure', async () => {
    const workflowPath = 'workflows/test-workflow.yaml';
    const failAtStep = Math.floor(2 / 2);

    // Simulate failure mid-workflow
    const result = await engine.executeWorkflow(workflowPath, {
      failAt: failAtStep
    });

    expect(result.success).toBe(false);

    // Get last checkpoint
    const checkpoints = await checkpointService.listCheckpoints(result.executionId);
    const lastCheckpoint = checkpoints[checkpoints.length - 1];

    // Resume from checkpoint
    const resumeResult = await engine.resumeWorkflow(lastCheckpoint.id);

    expect(resumeResult.success).toBe(true);
    expect(resumeResult.resumedFromStep).toBeDefined();
  });

  it('should respect workflow timeout', async () => {
    const workflowPath = 'workflows/test-workflow.yaml';
    const timeout = 5000;

    const startTime = Date.now();

    await expect(
      engine.executeWorkflow(workflowPath, { timeout })
    ).rejects.toThrow('timeout');

    const duration = Date.now() - startTime;
    expect(duration).toBeGreaterThanOrEqual(timeout);
  });

  it('should produce expected output structure', async () => {
    const workflowPath = 'workflows/test-workflow.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result).toMatchObject({
      success: true,
      executionId: expect.any(String),
      workflowName: 'Test Workflow',
      startTime: expect.any(Date),
      endTime: expect.any(Date),
      duration: expect.any(Number),
      completedSteps: 2,
      failedSteps: 0,
      output: expect.any(Object),
    });
  });

  it('should calculate accurate cost and duration', async () => {
    const workflowPath = 'workflows/test-workflow.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result.cost).toBeGreaterThan(0);
    expect(result.cost).toBeLessThan(0.52 * 1.5);

    expect(result.duration).toBeGreaterThan(0);
    expect(result.duration).toBeLessThan(22500 * 1.5);
  });
});
