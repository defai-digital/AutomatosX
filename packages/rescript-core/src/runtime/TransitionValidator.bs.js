// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as StateMachine from "./StateMachine.bs.js";

function validateSourceState(fromState, $$event) {
  switch (fromState) {
    case "Bootstrapping" :
        if (typeof $$event !== "object" && $$event === "DependenciesReady") {
          return "Valid";
        } else {
          return {
                  TAG: "Invalid",
                  _0: "Bootstrapping state only accepts DependenciesReady event"
                };
        }
    case "Idle" :
        if (typeof $$event !== "object" || $$event.TAG !== "TaskSubmitted") {
          return {
                  TAG: "Invalid",
                  _0: "Idle state only accepts TaskSubmitted events"
                };
        } else {
          return "Valid";
        }
    case "Preparing" :
        if (typeof $$event !== "object") {
          if ($$event === "DependenciesReady") {
            return "Valid";
          } else {
            return {
                    TAG: "Invalid",
                    _0: "Preparing state only accepts DependenciesReady, CancelRequest, or Timeout"
                  };
          }
        }
        switch ($$event.TAG) {
          case "Timeout" :
          case "CancelRequest" :
              return "Valid";
          default:
            return {
                    TAG: "Invalid",
                    _0: "Preparing state only accepts DependenciesReady, CancelRequest, or Timeout"
                  };
        }
    case "WaitingOnDependency" :
        if (typeof $$event !== "object") {
          if ($$event === "TelemetryFlushed") {
            return {
                    TAG: "Invalid",
                    _0: "WaitingOnDependency state only accepts DependenciesReady, RetryTrigger, CancelRequest, or Timeout"
                  };
          } else {
            return "Valid";
          }
        }
        switch ($$event.TAG) {
          case "TaskSubmitted" :
          case "RuleViolation" :
              return {
                      TAG: "Invalid",
                      _0: "WaitingOnDependency state only accepts DependenciesReady, RetryTrigger, CancelRequest, or Timeout"
                    };
          default:
            return "Valid";
        }
    case "Executing" :
        if (typeof $$event === "object") {
          if ($$event.TAG === "TaskSubmitted") {
            return {
                    TAG: "Invalid",
                    _0: "Executing state only accepts TelemetryFlushed, RuleViolation, Timeout, or CancelRequest"
                  };
          } else {
            return "Valid";
          }
        }
        switch ($$event) {
          case "DependenciesReady" :
          case "RetryTrigger" :
              return {
                      TAG: "Invalid",
                      _0: "Executing state only accepts TelemetryFlushed, RuleViolation, Timeout, or CancelRequest"
                    };
          default:
            return "Valid";
        }
    case "Completed" :
        if (typeof $$event !== "object" && $$event === "TelemetryFlushed") {
          return "Valid";
        } else {
          return {
                  TAG: "Invalid",
                  _0: "Completed state only accepts TelemetryFlushed"
                };
        }
    case "Failed" :
        if (typeof $$event !== "object" && $$event === "RetryTrigger") {
          return "Valid";
        } else {
          return {
                  TAG: "Invalid",
                  _0: "Failed state only accepts RetryTrigger"
                };
        }
    case "Canceled" :
        if (typeof $$event !== "object" && $$event === "RetryTrigger") {
          return "Valid";
        } else {
          return {
                  TAG: "Invalid",
                  _0: "Canceled state only accepts RetryTrigger"
                };
        }
    
  }
}

function validateContext($$event, context) {
  if (typeof $$event === "object") {
    if ($$event.TAG === "CancelRequest" && !context.cancellationRequested) {
      return {
              TAG: "Invalid",
              _0: "CancelRequest event requires context.cancellationRequested = true"
            };
    } else {
      return "Valid";
    }
  }
  switch ($$event) {
    case "DependenciesReady" :
        if (context.dependenciesReady) {
          return "Valid";
        } else {
          return {
                  TAG: "Invalid",
                  _0: "DependenciesReady event requires context.dependenciesReady = true"
                };
        }
    default:
      return "Valid";
  }
}

function validateGuardVerdict(fromState, toState, context) {
  if (fromState !== "Preparing") {
    return "Valid";
  }
  if (toState !== "Executing") {
    return "Valid";
  }
  var reason = context.guardVerdict;
  if (typeof reason !== "object") {
    return "Valid";
  } else {
    return {
            TAG: "Invalid",
            _0: "Guard verdict blocked transition: " + reason._0
          };
  }
}

var PreConditionValidator = {
  validateSourceState: validateSourceState,
  validateContext: validateContext,
  validateGuardVerdict: validateGuardVerdict
};

function validateDestinationState(fromState, toState, $$event) {
  switch (fromState) {
    case "Bootstrapping" :
        if (toState === "Idle" && typeof $$event !== "object" && $$event === "DependenciesReady") {
          return "Valid";
        }
        break;
    case "Idle" :
        if (toState === "Preparing" && typeof $$event === "object" && $$event.TAG === "TaskSubmitted") {
          return "Valid";
        }
        break;
    case "Preparing" :
        switch (toState) {
          case "Executing" :
              if (typeof $$event !== "object" && $$event === "DependenciesReady") {
                return "Valid";
              }
              break;
          case "Failed" :
              if (typeof $$event === "object" && $$event.TAG === "Timeout") {
                return "Valid";
              }
              break;
          case "Canceled" :
              if (typeof $$event === "object" && $$event.TAG === "CancelRequest") {
                return "Valid";
              }
              break;
          default:
            
        }
        break;
    case "WaitingOnDependency" :
        switch (toState) {
          case "Preparing" :
              if (typeof $$event !== "object") {
                switch ($$event) {
                  case "DependenciesReady" :
                  case "RetryTrigger" :
                      return "Valid";
                  default:
                    
                }
              }
              break;
          case "Failed" :
              if (typeof $$event === "object" && $$event.TAG === "Timeout") {
                return "Valid";
              }
              break;
          case "Canceled" :
              if (typeof $$event === "object" && $$event.TAG === "CancelRequest") {
                return "Valid";
              }
              break;
          default:
            
        }
        break;
    case "Executing" :
        switch (toState) {
          case "Executing" :
              if (typeof $$event !== "object" && $$event === "TelemetryFlushed") {
                return "Valid";
              }
              break;
          case "Completed" :
              if (typeof $$event !== "object" && $$event === "TelemetryFlushed") {
                return "Valid";
              }
              break;
          case "Failed" :
              if (typeof $$event === "object") {
                switch ($$event.TAG) {
                  case "RuleViolation" :
                  case "Timeout" :
                      return "Valid";
                  default:
                    
                }
              }
              break;
          case "Canceled" :
              if (typeof $$event === "object" && $$event.TAG === "CancelRequest") {
                return "Valid";
              }
              break;
          default:
            
        }
        break;
    case "Completed" :
        if (toState === "Idle" && typeof $$event !== "object" && $$event === "TelemetryFlushed") {
          return "Valid";
        }
        break;
    case "Failed" :
        if (toState === "Preparing" && typeof $$event !== "object" && $$event === "RetryTrigger") {
          return "Valid";
        }
        break;
    case "Canceled" :
        if (toState === "Idle" && typeof $$event !== "object" && $$event === "RetryTrigger") {
          return "Valid";
        }
        break;
    
  }
  var fromStr = StateMachine.State.toString(fromState);
  var toStr = StateMachine.State.toString(toState);
  return {
          TAG: "Invalid",
          _0: "Invalid transition from " + fromStr + " to " + toStr
        };
}

function validateEffects(_fromState, toState, effects) {
  var hasRollback = Belt_Array.some(effects, (function (effect) {
          if (typeof effect !== "object" || effect.TAG !== "PerformRollback") {
            return false;
          } else {
            return true;
          }
        }));
  if (!hasRollback) {
    return "Valid";
  }
  switch (toState) {
    case "Failed" :
    case "Canceled" :
        return "Valid";
    default:
      return {
              TAG: "Invalid",
              _0: "PerformRollback effect should only be used when transitioning to Failed or Canceled"
            };
  }
}

var PostConditionValidator = {
  validateDestinationState: validateDestinationState,
  validateEffects: validateEffects
};

function determineRollbackStrategy(fromState, toState, $$event) {
  switch (toState) {
    case "Failed" :
        if (typeof $$event !== "object") {
          return {
                  TAG: "StateRollback",
                  _0: "Idle"
                };
        }
        switch ($$event.TAG) {
          case "RuleViolation" :
              return {
                      TAG: "CompensateWithEffects",
                      _0: [
                        {
                          TAG: "PerformRollback",
                          _0: $$event._0
                        },
                        {
                          TAG: "EmitTelemetry",
                          _0: "rule.violation"
                        }
                      ]
                    };
          case "Timeout" :
              return {
                      TAG: "FullRollback",
                      _0: fromState,
                      _1: [{
                          TAG: "PerformRollback",
                          _0: "timeout:" + String($$event._0)
                        }]
                    };
          default:
            return {
                    TAG: "StateRollback",
                    _0: "Idle"
                  };
        }
    case "Canceled" :
        if (typeof $$event !== "object" || $$event.TAG !== "CancelRequest") {
          return "NoRollback";
        } else {
          return {
                  TAG: "CompensateWithEffects",
                  _0: [
                    {
                      TAG: "RecordCancellation",
                      _0: $$event._0.requestedBy
                    },
                    {
                      TAG: "EmitTelemetry",
                      _0: "task.canceled"
                    }
                  ]
                };
        }
    default:
      return "NoRollback";
  }
}

function determineRecoveryAction(error, validationCtx) {
  if (validationCtx.attemptCount >= 3) {
    return "AbortTransition";
  }
  var match = error.fromState;
  switch (match) {
    case "Preparing" :
        return {
                TAG: "FallbackToState",
                _0: "WaitingOnDependency"
              };
    case "Executing" :
        var strategy = determineRollbackStrategy(error.fromState, error.toState, error.event);
        return {
                TAG: "ExecuteRollback",
                _0: strategy
              };
    default:
      return {
              TAG: "RetryTransition",
              _0: validationCtx.attemptCount + 1 | 0
            };
  }
}

function executeRollback(strategy) {
  if (typeof strategy !== "object") {
    return [
            "Idle",
            []
          ];
  }
  switch (strategy.TAG) {
    case "StateRollback" :
        return [
                strategy._0,
                []
              ];
    case "CompensateWithEffects" :
        return [
                "Idle",
                strategy._0
              ];
    case "FullRollback" :
        return [
                strategy._0,
                strategy._1
              ];
    
  }
}

var ErrorRecovery = {
  determineRollbackStrategy: determineRollbackStrategy,
  determineRecoveryAction: determineRecoveryAction,
  executeRollback: executeRollback
};

function validateTransition(fromState, toState, $$event, context, effects) {
  var sourceValid = validateSourceState(fromState, $$event);
  if (typeof sourceValid === "object") {
    return sourceValid;
  }
  var contextValid = validateContext($$event, context);
  if (typeof contextValid === "object") {
    return contextValid;
  }
  var guardValid = validateGuardVerdict(fromState, toState, context);
  if (typeof guardValid === "object") {
    return guardValid;
  }
  var destValid = validateDestinationState(fromState, toState, $$event);
  if (typeof destValid !== "object") {
    return validateEffects(fromState, toState, effects);
  } else {
    return destValid;
  }
}

function validateWithRecovery(fromState, toState, $$event, context, effects, validationCtx) {
  var result = validateTransition(fromState, toState, $$event, context, effects);
  if (typeof result !== "object") {
    return [
            "Valid",
            undefined
          ];
  }
  var reason = result._0;
  var error_timestamp = Date.now();
  var error = {
    fromState: fromState,
    toState: toState,
    event: $$event,
    reason: reason,
    timestamp: error_timestamp
  };
  var recoveryAction = determineRecoveryAction(error, validationCtx);
  return [
          {
            TAG: "Invalid",
            _0: reason
          },
          recoveryAction
        ];
}

var TransitionValidation = {
  validateTransition: validateTransition,
  validateWithRecovery: validateWithRecovery
};

function createValidationContext(context, previousState, attemptCountOpt, lastError, param) {
  var attemptCount = attemptCountOpt !== undefined ? attemptCountOpt : 0;
  return {
          context: context,
          previousState: previousState,
          attemptCount: attemptCount,
          lastError: lastError
        };
}

export {
  PreConditionValidator ,
  PostConditionValidator ,
  ErrorRecovery ,
  TransitionValidation ,
  validateTransition ,
  validateWithRecovery ,
  determineRollbackStrategy ,
  executeRollback ,
  createValidationContext ,
}
/* No side effect */
