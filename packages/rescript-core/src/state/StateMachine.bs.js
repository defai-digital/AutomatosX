// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Core__Option from "@rescript/core/src/Core__Option.bs.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function createEvent(id, data, metadata, param) {
  return {
          id: id,
          timestamp: Date.now(),
          data: data,
          metadata: metadata
        };
}

var defaultConfig = {
  maxHistorySize: 100,
  enableLogging: false,
  strict: true
};

function create(initialState, transitions, config, param) {
  var machineConfig = config !== undefined ? config : defaultConfig;
  return {
          currentState: initialState,
          transitions: transitions,
          history: [],
          config: machineConfig
        };
}

function statesEqual(s1, s2) {
  if (typeof s1 !== "object") {
    if (typeof s2 !== "object") {
      return true;
    } else {
      return false;
    }
  }
  switch (s1.TAG) {
    case "Running" :
        if (typeof s2 !== "object" || s2.TAG !== "Running") {
          return false;
        } else {
          return true;
        }
    case "Paused" :
        if (typeof s2 !== "object" || s2.TAG !== "Paused") {
          return false;
        } else {
          return true;
        }
    case "Completed" :
        if (typeof s2 !== "object" || s2.TAG !== "Completed") {
          return false;
        } else {
          return true;
        }
    case "Failed" :
        if (typeof s2 !== "object" || s2.TAG !== "Failed") {
          return false;
        } else {
          return true;
        }
    
  }
}

function findTransition(machine, eventData) {
  return machine.transitions.find(function (t) {
              if (statesEqual(t.from, machine.currentState)) {
                return Caml_obj.equal(t.event, eventData);
              } else {
                return false;
              }
            });
}

function getStateData(state) {
  if (typeof state !== "object" || state.TAG === "Failed") {
    return ;
  } else {
    return Caml_option.some(state._0);
  }
}

function checkGuard(guard, state) {
  var match = getStateData(state);
  if (guard !== undefined) {
    if (match !== undefined) {
      if (guard(Caml_option.valFromOption(match))) {
        return {
                TAG: "Ok",
                _0: undefined
              };
      } else {
        return {
                TAG: "Error",
                _0: "Guard condition not satisfied"
              };
      }
    } else {
      return {
              TAG: "Error",
              _0: "Cannot evaluate guard: state has no data"
            };
    }
  } else {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
}

async function executeAction(action, state) {
  var match = getStateData(state);
  if (action === undefined) {
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  if (match === undefined) {
    return {
            TAG: "Error",
            _0: "Cannot execute action: state has no data"
          };
  }
  try {
    await action(Caml_option.valFromOption(match));
    return {
            TAG: "Ok",
            _0: undefined
          };
  }
  catch (raw_e){
    var e = Caml_js_exceptions.internalToOCamlException(raw_e);
    if (e.RE_EXN_ID !== Js_exn.$$Error) {
      return {
              TAG: "Error",
              _0: "Unknown error in action"
            };
    }
    var msg = e._1.message;
    var message = msg !== undefined ? msg : "Unknown error in action";
    return {
            TAG: "Error",
            _0: message
          };
  }
}

function addToHistory(machine, from, to, $$event, success, error) {
  var entry_timestamp = Date.now();
  var entry = {
    from: from,
    to: to,
    event: $$event,
    timestamp: entry_timestamp,
    success: success,
    error: error
  };
  machine.history = machine.history.concat([entry]);
  if (machine.history.length > machine.config.maxHistorySize) {
    machine.history = machine.history.slice(machine.history.length - machine.config.maxHistorySize | 0);
    return ;
  }
  
}

async function transition(machine, $$event) {
  var currentState = machine.currentState;
  var matchingTransition = findTransition(machine, $$event.data);
  if (matchingTransition === undefined) {
    if (machine.config.strict) {
      addToHistory(machine, currentState, currentState, $$event, false, "No matching transition");
      return {
              TAG: "Error",
              _0: "No transition from " + currentState + " for event"
            };
    } else {
      return {
              TAG: "Ok",
              _0: currentState
            };
    }
  }
  var guardResult = checkGuard(matchingTransition.guard, currentState);
  if (guardResult.TAG === "Ok") {
    var actionResult = await executeAction(matchingTransition.action, matchingTransition.to);
    if (actionResult.TAG === "Ok") {
      machine.currentState = matchingTransition.to;
      addToHistory(machine, currentState, matchingTransition.to, $$event, true, undefined);
      if (machine.config.enableLogging) {
        console.log("State transition: " + currentState + " -> " + matchingTransition.to);
      }
      return {
              TAG: "Ok",
              _0: matchingTransition.to
            };
    }
    var reason = actionResult._0;
    addToHistory(machine, currentState, currentState, $$event, false, "Action failed: " + reason);
    return {
            TAG: "Error",
            _0: "Action failed: " + reason
          };
  }
  var reason$1 = guardResult._0;
  addToHistory(machine, currentState, currentState, $$event, false, "Guard blocked: " + reason$1);
  return {
          TAG: "Error",
          _0: "Guard blocked: " + reason$1
        };
}

function getCurrentState(machine) {
  return machine.currentState;
}

function getHistory(machine) {
  return machine.history;
}

function getHistoryLength(machine) {
  return machine.history.length;
}

function isIdle(machine) {
  var match = machine.currentState;
  if (typeof match !== "object") {
    return true;
  } else {
    return false;
  }
}

function isRunning(machine) {
  var match = machine.currentState;
  if (typeof match !== "object" || match.TAG !== "Running") {
    return false;
  } else {
    return true;
  }
}

function isPaused(machine) {
  var match = machine.currentState;
  if (typeof match !== "object" || match.TAG !== "Paused") {
    return false;
  } else {
    return true;
  }
}

function isCompleted(machine) {
  var match = machine.currentState;
  if (typeof match !== "object" || match.TAG !== "Completed") {
    return false;
  } else {
    return true;
  }
}

function isFailed(machine) {
  var match = machine.currentState;
  if (typeof match !== "object" || match.TAG !== "Failed") {
    return false;
  } else {
    return true;
  }
}

function getFailureReason(machine) {
  var reason = machine.currentState;
  if (typeof reason !== "object" || reason.TAG !== "Failed") {
    return ;
  } else {
    return reason._0;
  }
}

function reset(machine, initialState) {
  machine.currentState = initialState;
  machine.history = [];
}

function canTransition(machine, eventData) {
  var matchingTransition = findTransition(machine, eventData);
  if (matchingTransition === undefined) {
    return false;
  }
  var guardResult = checkGuard(matchingTransition.guard, machine.currentState);
  if (guardResult.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function getPossibleTransitions(machine) {
  return machine.transitions.filter(function (t) {
              return statesEqual(t.from, machine.currentState);
            });
}

function getStatistics(machine) {
  var total = machine.history.length;
  var successful = machine.history.filter(function (entry) {
        return entry.success;
      }).length;
  var failed = total - successful | 0;
  var guardBlocked = machine.history.filter(function (entry) {
        if (!entry.success && Core__Option.isSome(entry.error)) {
          return Core__Option.getExn(entry.error, undefined).includes("Guard blocked");
        } else {
          return false;
        }
      }).length;
  var actionFailed = machine.history.filter(function (entry) {
        if (!entry.success && Core__Option.isSome(entry.error)) {
          return Core__Option.getExn(entry.error, undefined).includes("Action failed");
        } else {
          return false;
        }
      }).length;
  return {
          totalTransitions: total,
          successfulTransitions: successful,
          failedTransitions: failed,
          guardBlockedTransitions: guardBlocked,
          actionFailedTransitions: actionFailed
        };
}

export {
  createEvent ,
  defaultConfig ,
  create ,
  statesEqual ,
  findTransition ,
  getStateData ,
  checkGuard ,
  executeAction ,
  addToHistory ,
  transition ,
  getCurrentState ,
  getHistory ,
  getHistoryLength ,
  isIdle ,
  isRunning ,
  isPaused ,
  isCompleted ,
  isFailed ,
  getFailureReason ,
  reset ,
  canTransition ,
  getPossibleTransitions ,
  getStatistics ,
}
/* No side effect */
