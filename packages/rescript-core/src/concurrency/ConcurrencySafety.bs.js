// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function createMutex(initialValue) {
  return {
          value: {
            contents: initialValue
          },
          state: {
            contents: "Unlocked"
          },
          waitQueue: {
            contents: []
          }
        };
}

function tryLock(mutex) {
  var match = mutex.state.contents;
  if (typeof match === "object") {
    return false;
  }
  mutex.state.contents = {
    TAG: "Locked",
    _0: Date.now() | 0
  };
  return true;
}

function lock(mutex, timeoutMsOpt) {
  var timeoutMs = timeoutMsOpt !== undefined ? timeoutMsOpt : 5000;
  var startTime = Date.now() | 0;
  var tryAcquire = function () {
    if (tryLock(mutex)) {
      return Promise.resolve({
                  TAG: "Ok",
                  _0: undefined
                });
    }
    var elapsed = (Date.now() | 0) - startTime | 0;
    if (elapsed >= timeoutMs) {
      return Promise.resolve({
                  TAG: "Error",
                  _0: "Lock timeout after " + String(timeoutMs) + "ms"
                });
    } else {
      return new Promise((function (resolve, param) {
                    setTimeout((function () {
                            ((function (__x) {
                                    return Js_promise.then_((function (result) {
                                                  resolve(result);
                                                  return Promise.resolve();
                                                }), __x);
                                  })(tryAcquire()));
                          }), 10);
                  }));
    }
  };
  return tryAcquire();
}

function unlock(mutex) {
  var match = mutex.state.contents;
  if (typeof match !== "object") {
    return ;
  }
  mutex.state.contents = "Unlocked";
  if (mutex.waitQueue.contents.length === 0) {
    return ;
  }
  var callback = Belt_Array.get(mutex.waitQueue.contents, 0);
  if (callback !== undefined) {
    mutex.waitQueue.contents = Belt_Array.sliceToEnd(mutex.waitQueue.contents, 1);
    return callback();
  }
  
}

function isLocked(mutex) {
  var match = mutex.state.contents;
  if (typeof match !== "object") {
    return false;
  } else {
    return true;
  }
}

function getValue(mutex) {
  return mutex.value.contents;
}

function atomicRead(mutex) {
  var __x = lock(mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                var value = mutex.value.contents;
                unlock(mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: value
                          });
              }), __x);
}

function atomicWrite(mutex, newValue) {
  var __x = lock(mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                mutex.value.contents = newValue;
                unlock(mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: undefined
                          });
              }), __x);
}

function atomicUpdate(mutex, fn) {
  var __x = lock(mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                var oldValue = mutex.value.contents;
                var newValue = fn(oldValue);
                mutex.value.contents = newValue;
                unlock(mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: newValue
                          });
              }), __x);
}

function atomicCAS(mutex, expected, newValue) {
  var __x = lock(mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                var current = mutex.value.contents;
                var success = Caml_obj.equal(current, expected);
                if (success) {
                  mutex.value.contents = newValue;
                }
                unlock(mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: success
                          });
              }), __x);
}

function createSafeCache(maxSizeOpt) {
  var maxSize = maxSizeOpt !== undefined ? maxSizeOpt : 1000;
  return {
          data: {
            contents: {}
          },
          mutex: {
            value: {
              contents: undefined
            },
            state: {
              contents: "Unlocked"
            },
            waitQueue: {
              contents: []
            }
          },
          maxSize: maxSize
        };
}

function cacheGet(cache, key) {
  var __x = lock(cache.mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                var value = Js_dict.get(cache.data.contents, key);
                unlock(cache.mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: value
                          });
              }), __x);
}

function cacheSet(cache, key, value) {
  var __x = lock(cache.mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                var currentSize = Object.keys(cache.data.contents).length;
                var keyExists = Belt_Option.isSome(Js_dict.get(cache.data.contents, key));
                if (currentSize >= cache.maxSize && !keyExists) {
                  var oldestKey = Belt_Array.get(Object.keys(cache.data.contents), 0);
                  if (oldestKey !== undefined) {
                    Js_dict.unsafeDeleteKey(cache.data.contents, oldestKey);
                  }
                  
                }
                cache.data.contents[key] = value;
                unlock(cache.mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: undefined
                          });
              }), __x);
}

function cacheDelete(cache, key) {
  var __x = lock(cache.mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                Js_dict.unsafeDeleteKey(cache.data.contents, key);
                unlock(cache.mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: undefined
                          });
              }), __x);
}

function cacheClear(cache) {
  var __x = lock(cache.mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                cache.data.contents = {};
                unlock(cache.mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: undefined
                          });
              }), __x);
}

function cacheSize(cache) {
  var __x = lock(cache.mutex, undefined);
  return Js_promise.then_((function (lockResult) {
                if (lockResult.TAG !== "Ok") {
                  return Promise.resolve({
                              TAG: "Error",
                              _0: lockResult._0
                            });
                }
                var size = Object.keys(cache.data.contents).length;
                unlock(cache.mutex);
                return Promise.resolve({
                            TAG: "Ok",
                            _0: size
                          });
              }), __x);
}

function sequential(operations) {
  var results = {
    contents: []
  };
  var executeNext = function (index) {
    if (index >= operations.length) {
      return Promise.resolve(results.contents);
    }
    var operation = Belt_Array.get(operations, index);
    if (operation !== undefined) {
      var __x = operation();
      return Js_promise.then_((function (result) {
                    results.contents = Belt_Array.concat(results.contents, [result]);
                    return executeNext(index + 1 | 0);
                  }), __x);
    } else {
      return Promise.resolve(results.contents);
    }
  };
  return executeNext(0);
}

function sequentialResults(operations) {
  var results = {
    contents: []
  };
  var executeNext = function (index) {
    if (index >= operations.length) {
      return Promise.resolve({
                  TAG: "Ok",
                  _0: results.contents
                });
    }
    var operation = Belt_Array.get(operations, index);
    if (operation !== undefined) {
      var __x = operation();
      return Js_promise.then_((function (result) {
                    if (result.TAG !== "Ok") {
                      return Promise.resolve({
                                  TAG: "Error",
                                  _0: result._0
                                });
                    }
                    results.contents = Belt_Array.concat(results.contents, [result._0]);
                    return executeNext(index + 1 | 0);
                  }), __x);
    } else {
      return Promise.resolve({
                  TAG: "Ok",
                  _0: results.contents
                });
    }
  };
  return executeNext(0);
}

function createDebounceState() {
  return {
          timeoutId: {
            contents: undefined
          },
          lastArgs: {
            contents: undefined
          }
        };
}

function debounce(state, fn, args, delayMs) {
  var id = state.timeoutId.contents;
  if (id !== undefined) {
    clearTimeout(Caml_option.valFromOption(id));
  }
  var newId = setTimeout((function () {
          fn(args);
          state.timeoutId.contents = undefined;
          state.lastArgs.contents = undefined;
        }), delayMs);
  state.timeoutId.contents = Caml_option.some(newId);
  state.lastArgs.contents = Caml_option.some(args);
}

function createThrottleState() {
  return {
          lastExecuted: {
            contents: 0
          },
          isThrottled: {
            contents: false
          }
        };
}

function throttle(state, fn, args, intervalMs) {
  var now = Date.now() | 0;
  var timeSinceLastExecution = now - state.lastExecuted.contents | 0;
  if (timeSinceLastExecution >= intervalMs && !state.isThrottled.contents) {
    fn(args);
    state.lastExecuted.contents = now;
    state.isThrottled.contents = true;
    setTimeout((function () {
            state.isThrottled.contents = false;
          }), intervalMs);
    return ;
  }
  
}

export {
  createMutex ,
  tryLock ,
  lock ,
  unlock ,
  isLocked ,
  getValue ,
  atomicRead ,
  atomicWrite ,
  atomicUpdate ,
  atomicCAS ,
  createSafeCache ,
  cacheGet ,
  cacheSet ,
  cacheDelete ,
  cacheClear ,
  cacheSize ,
  sequential ,
  sequentialResults ,
  createDebounceState ,
  debounce ,
  createThrottleState ,
  throttle ,
}
/* No side effect */
