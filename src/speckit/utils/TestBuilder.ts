/**
 * Test Builder
 *
 * Week 3-4 Implementation - Day 5
 * Builds test code from templates for different frameworks
 */

import Handlebars from 'handlebars';
import type {
  WorkflowDefinition,
  TestableStep,
  TestPhase,
  TestFramework,
  TestFile,
} from '../types/speckit.types.js';

/**
 * Test Builder
 *
 * Generates test code using Handlebars templates.
 * Supports Vitest, Jest, and Mocha frameworks.
 */
export class TestBuilder {
  private templates: Map<string, HandlebarsTemplateDelegate>;

  constructor(private framework: TestFramework = 'vitest') {
    this.templates = new Map();
    this.registerTemplates();
    this.registerHelpers();
  }

  /**
   * Build unit test file
   */
  buildUnitTests(
    workflow: WorkflowDefinition,
    steps: TestableStep[]
  ): TestFile {
    const template = this.templates.get(`${this.framework}-unit`);
    if (!template) {
      throw new Error(`Template not found for ${this.framework} unit tests`);
    }

    const content = template({
      workflowName: workflow.name,
      workflowVersion: workflow.version,
      steps,
      stepCount: steps.length,
      timestamp: new Date().toISOString(),
    });

    const testCount = steps.length * 3; // 3 tests per step (success, error, timeout)

    return {
      path: `tests/${this.kebabCase(workflow.name)}/unit.test.ts`,
      content,
      testCount,
      framework: this.framework,
      type: 'unit' as const,
      target: workflow.name,
    };
  }

  /**
   * Build integration test file
   */
  buildIntegrationTests(
    workflow: WorkflowDefinition,
    phases: TestPhase[]
  ): TestFile {
    const template = this.templates.get(`${this.framework}-integration`);
    if (!template) {
      throw new Error(`Template not found for ${this.framework} integration tests`);
    }

    const content = template({
      workflowName: workflow.name,
      workflowVersion: workflow.version,
      phases,
      phaseCount: phases.length,
      timestamp: new Date().toISOString(),
    });

    const testCount = phases.length * 3; // 3 tests per phase

    return {
      path: `tests/${this.kebabCase(workflow.name)}/integration.test.ts`,
      content,
      testCount,
      framework: this.framework,
      type: 'integration' as const,
      target: workflow.name,
    };
  }

  /**
   * Build E2E test file
   */
  buildE2ETests(
    workflow: WorkflowDefinition,
    steps: TestableStep[],
    phases: TestPhase[]
  ): TestFile {
    const template = this.templates.get(`${this.framework}-e2e`);
    if (!template) {
      throw new Error(`Template not found for ${this.framework} E2E tests`);
    }

    const totalDuration = steps.reduce((sum, s) => sum + s.estimatedDuration, 0);
    const estimatedCost = 0.52; // Placeholder - would calculate based on providers

    const content = template({
      workflowName: workflow.name,
      workflowVersion: workflow.version,
      stepCount: steps.length,
      phaseCount: phases.length,
      estimatedDuration: totalDuration,
      estimatedCost,
      kebabCaseName: this.kebabCase(workflow.name),
      timestamp: new Date().toISOString(),
    });

    const testCount = 6; // Fixed number of E2E tests

    return {
      path: `tests/${this.kebabCase(workflow.name)}/e2e.test.ts`,
      content,
      testCount,
      framework: this.framework,
      type: 'e2e' as const,
      target: workflow.name,
    };
  }

  /**
   * Register Handlebars templates
   */
  private registerTemplates(): void {
    // Vitest Unit Test Template
    this.templates.set('vitest-unit', Handlebars.compile(`import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { WorkflowEngineV2 } from '../../../services/WorkflowEngineV2.js';
import type { WorkflowDefinition } from '../../../speckit/types/speckit.types.js';

/**
 * Unit Tests for {{workflowName}}
 * Generated by AutomatosX v8.0.0 - {{timestamp}}
 */

describe('{{workflowName}} - Unit Tests', () => {
  let engine: WorkflowEngineV2;

  beforeEach(() => {
    // Setup test environment
    engine = new WorkflowEngineV2();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

{{#each steps}}
  describe('Step: {{this.name}}', () => {
    it('should execute successfully with valid input', async () => {
      const result = await engine.executeStep('{{this.id}}', {{json this.config}});
      expect(result.success).toBe(true);
      expect(result.output).toBeDefined();
    });

    it('should handle errors gracefully', async () => {
      const mockError = new Error('Simulated failure');
      vi.spyOn(engine, 'executeStep').mockRejectedValue(mockError);

      await expect(
        engine.executeStep('{{this.id}}', {})
      ).rejects.toThrow('Simulated failure');
    });

    it('should respect timeout configuration', async () => {
      const timeout = {{#if this.timeout}}{{this.timeout}}{{else}}30000{{/if}};
      const startTime = Date.now();

      await engine.executeStep('{{this.id}}', { timeout });

      const duration = Date.now() - startTime;
      expect(duration).toBeLessThan(timeout + 1000);
    });
{{#if this.retryConfig}}

    it('should retry on transient failures', async () => {
      let attempts = 0;
      vi.spyOn(engine, 'executeStep').mockImplementation(async () => {
        attempts++;
        if (attempts <= {{this.retryConfig.maxRetries}}) {
          throw new Error('Transient error');
        }
        return { success: true, output: {} };
      });

      const result = await engine.executeStep('{{this.id}}', {});
      expect(attempts).toBe({{inc this.retryConfig.maxRetries}});
      expect(result.success).toBe(true);
    });
{{/if}}
  });

{{/each}}
});
`));

    // Vitest Integration Test Template
    this.templates.set('vitest-integration', Handlebars.compile(`import { describe, it, expect, vi, beforeAll, afterAll } from 'vitest';
import { WorkflowEngineV2 } from '../../../services/WorkflowEngineV2.js';

/**
 * Integration Tests for {{workflowName}}
 * Generated by AutomatosX v8.0.0 - {{timestamp}}
 */

describe('{{workflowName}} - Integration Tests', () => {
  let engine: WorkflowEngineV2;

  beforeAll(async () => {
    engine = new WorkflowEngineV2();
  });

  afterAll(async () => {
    await engine.cleanup();
  });

{{#each phases}}
  describe('Phase {{this.number}}: {{this.name}}', () => {
    it('should execute all steps in phase', async () => {
      const stepIds = {{json this.steps}};

      for (const stepId of stepIds) {
        const result = await engine.executeStep(stepId, {});
        expect(result.success).toBe(true);
      }
    });

{{#if this.canParallelize}}
    it('should execute steps in parallel when possible', async () => {
      const stepIds = {{json this.steps}};
      const startTime = Date.now();

      const results = await Promise.all(
        stepIds.map(id => engine.executeStep(id, {}))
      );

      const duration = Date.now() - startTime;
      const sequentialDuration = {{this.estimatedDuration}};

      expect(duration).toBeLessThan(sequentialDuration * 0.7);
      expect(results.every(r => r.success)).toBe(true);
    });
{{/if}}

    it('should maintain correct execution order', async () => {
      const executionOrder: string[] = [];
      const originalExecute = engine.executeStep.bind(engine);

      vi.spyOn(engine, 'executeStep').mockImplementation(async (stepId, config) => {
        executionOrder.push(stepId);
        return originalExecute(stepId, config);
      });

      await engine.executePhase({{this.number}});

      const stepIds = {{json this.steps}};
      expect(executionOrder).toEqual(expect.arrayContaining(stepIds));
    });
  });

{{/each}}
});
`));

    // Vitest E2E Test Template
    this.templates.set('vitest-e2e', Handlebars.compile(`import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { WorkflowEngineV2 } from '../../../services/WorkflowEngineV2.js';
import { CheckpointServiceV2 } from '../../../services/CheckpointServiceV2.js';

/**
 * End-to-End Tests for {{workflowName}}
 * Generated by AutomatosX v8.0.0 - {{timestamp}}
 */

describe('{{workflowName}} - E2E Tests', () => {
  let engine: WorkflowEngineV2;
  let checkpointService: CheckpointServiceV2;

  beforeAll(async () => {
    checkpointService = new CheckpointServiceV2();
    engine = new WorkflowEngineV2(checkpointService);
  });

  afterAll(async () => {
    await engine.cleanup();
    await checkpointService.cleanup();
  });

  it('should execute complete workflow successfully', async () => {
    const workflowPath = 'workflows/{{kebabCaseName}}.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result.success).toBe(true);
    expect(result.completedSteps).toBe({{stepCount}});
    expect(result.failedSteps).toBe(0);
    expect(result.duration).toBeGreaterThan(0);
  });

  it('should create checkpoints at each phase', async () => {
    const workflowPath = 'workflows/{{kebabCaseName}}.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    const checkpoints = await checkpointService.listCheckpoints(result.executionId);
    expect(checkpoints.length).toBe({{phaseCount}});

    for (const checkpoint of checkpoints) {
      expect(checkpoint.phaseNumber).toBeGreaterThan(0);
      expect(checkpoint.completedSteps).toBeGreaterThan(0);
    }
  });

  it('should resume from checkpoint after failure', async () => {
    const workflowPath = 'workflows/{{kebabCaseName}}.yaml';
    const failAtStep = Math.floor({{stepCount}} / 2);

    // Simulate failure mid-workflow
    const result = await engine.executeWorkflow(workflowPath, {
      failAt: failAtStep
    });

    expect(result.success).toBe(false);

    // Get last checkpoint
    const checkpoints = await checkpointService.listCheckpoints(result.executionId);
    const lastCheckpoint = checkpoints[checkpoints.length - 1];

    // Resume from checkpoint
    const resumeResult = await engine.resumeWorkflow(lastCheckpoint.id);

    expect(resumeResult.success).toBe(true);
    expect(resumeResult.resumedFromStep).toBeDefined();
  });

  it('should respect workflow timeout', async () => {
    const workflowPath = 'workflows/{{kebabCaseName}}.yaml';
    const timeout = 5000;

    const startTime = Date.now();

    await expect(
      engine.executeWorkflow(workflowPath, { timeout })
    ).rejects.toThrow('timeout');

    const duration = Date.now() - startTime;
    expect(duration).toBeGreaterThanOrEqual(timeout);
  });

  it('should produce expected output structure', async () => {
    const workflowPath = 'workflows/{{kebabCaseName}}.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result).toMatchObject({
      success: true,
      executionId: expect.any(String),
      workflowName: '{{workflowName}}',
      startTime: expect.any(Date),
      endTime: expect.any(Date),
      duration: expect.any(Number),
      completedSteps: {{stepCount}},
      failedSteps: 0,
      output: expect.any(Object),
    });
  });

  it('should calculate accurate cost and duration', async () => {
    const workflowPath = 'workflows/{{kebabCaseName}}.yaml';
    const result = await engine.executeWorkflow(workflowPath);

    expect(result.cost).toBeGreaterThan(0);
    expect(result.cost).toBeLessThan({{estimatedCost}} * 1.5);

    expect(result.duration).toBeGreaterThan(0);
    expect(result.duration).toBeLessThan({{estimatedDuration}} * 1.5);
  });
});
`));
  }

  /**
   * Register Handlebars helpers
   */
  private registerHelpers(): void {
    // JSON helper
    Handlebars.registerHelper('json', function(context) {
      return JSON.stringify(context, null, 2);
    });

    // Increment helper
    Handlebars.registerHelper('inc', function(value: number) {
      return value + 1;
    });

    // Kebab-case helper
    Handlebars.registerHelper('kebabCase', (str: string) => {
      return this.kebabCase(str);
    });
  }

  /**
   * Convert string to kebab-case
   */
  private kebabCase(str: string): string {
    return str
      .replace(/([a-z])([A-Z])/g, '$1-$2')
      .replace(/[\s_]+/g, '-')
      .toLowerCase();
  }
}
