// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

function createManifest(taskId, manifestVersion, dependencies, metadata, signature, param) {
  return {
          taskId: taskId,
          manifestVersion: manifestVersion,
          dependencies: dependencies,
          metadata: metadata,
          signature: signature
        };
}

function validateSchema(manifest) {
  if (manifest.taskId.length === 0) {
    return {
            TAG: "Invalid",
            _0: "taskId cannot be empty"
          };
  }
  if (manifest.manifestVersion.length === 0) {
    return {
            TAG: "Invalid",
            _0: "manifestVersion cannot be empty"
          };
  }
  if (manifest.dependencies.length === 0) {
    return {
            TAG: "Invalid",
            _0: "dependencies array cannot be empty"
          };
  }
  var hasEmptyDep = Belt_Array.some(manifest.dependencies, (function (dep) {
          return dep.length === 0;
        }));
  if (hasEmptyDep) {
    return {
            TAG: "Invalid",
            _0: "dependencies cannot contain empty strings"
          };
  } else {
    return "Valid";
  }
}

function manifestToCanonicalString(manifest) {
  var depsStr = Belt_Array.joinWith(manifest.dependencies, ",", (function (x) {
          return x;
        }));
  var dict = manifest.metadata;
  var metadataStr;
  if (dict !== undefined) {
    var pairs = Belt_Array.map(Js_dict.entries(dict), (function (param) {
            return param[0];
          }));
    metadataStr = Belt_Array.joinWith(pairs, ",", (function (x) {
            return x;
          }));
  } else {
    metadataStr = "";
  }
  return manifest.taskId + ":" + manifest.manifestVersion + ":" + depsStr + ":" + metadataStr;
}

function verifySignature(manifest, secretKey, hmacVerifier) {
  var sig = manifest.signature;
  if (sig === undefined) {
    return "MissingSignature";
  }
  if (sig.length === 0) {
    return {
            TAG: "InvalidFormat",
            _0: "signature cannot be empty"
          };
  }
  var canonical = manifestToCanonicalString(manifest);
  var isValid = hmacVerifier(canonical, secretKey, sig);
  if (isValid) {
    return "Verified";
  } else {
    return "SignatureMismatch";
  }
}

function validateManifest(manifest, secretKey, hmacVerifier) {
  var reason = validateSchema(manifest);
  if (typeof reason === "object") {
    return {
            TAG: "Error",
            _0: "Schema validation failed: " + reason._0
          };
  }
  var reason$1 = verifySignature(manifest, secretKey, hmacVerifier);
  if (typeof reason$1 === "object") {
    return {
            TAG: "Error",
            _0: "Signature verification failed: " + reason$1._0
          };
  }
  switch (reason$1) {
    case "Verified" :
        return {
                TAG: "Ok",
                _0: manifest
              };
    case "SignatureMismatch" :
        return {
                TAG: "Error",
                _0: "Signature verification failed: signature mismatch"
              };
    case "MissingSignature" :
        return {
                TAG: "Error",
                _0: "Signature verification failed: missing signature"
              };
    
  }
}

function validationResultToString(result) {
  if (typeof result !== "object") {
    return "Valid";
  } else {
    return "Invalid(" + result._0 + ")";
  }
}

function signatureResultToString(result) {
  if (typeof result === "object") {
    return "InvalidFormat(" + result._0 + ")";
  }
  switch (result) {
    case "Verified" :
        return "Verified";
    case "SignatureMismatch" :
        return "SignatureMismatch";
    case "MissingSignature" :
        return "MissingSignature";
    
  }
}

function getErrorMessage(result) {
  if (result.TAG === "Ok") {
    return ;
  } else {
    return result._0;
  }
}

function isValid(result) {
  if (typeof result !== "object") {
    return true;
  } else {
    return false;
  }
}

function isVerified(result) {
  if (typeof result !== "object" && result === "Verified") {
    return true;
  } else {
    return false;
  }
}

export {
  createManifest ,
  validateSchema ,
  manifestToCanonicalString ,
  verifySignature ,
  validateManifest ,
  validationResultToString ,
  signatureResultToString ,
  getErrorMessage ,
  isValid ,
  isVerified ,
}
/* No side effect */
