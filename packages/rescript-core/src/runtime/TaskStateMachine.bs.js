// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Js_null_undefined from "rescript/lib/es6/js_null_undefined.js";

function toString(state) {
  switch (state) {
    case "Bootstrapping" :
        return "BOOTSTRAPPING";
    case "Idle" :
        return "IDLE";
    case "Preparing" :
        return "PREPARING";
    case "WaitingOnDependency" :
        return "WAITING_ON_DEP";
    case "Executing" :
        return "EXECUTING";
    case "Completed" :
        return "COMPLETED";
    case "Failed" :
        return "FAILED";
    case "Canceled" :
        return "CANCELED";
    
  }
}

var State = {
  toString: toString
};

function toString$1(verdict) {
  if (typeof verdict !== "object") {
    return "ALLOWED";
  } else {
    return "BLOCKED:" + verdict._0;
  }
}

var GuardVerdict = {
  toString: toString$1
};

function toString$2($$event) {
  if (typeof $$event !== "object") {
    switch ($$event) {
      case "DependenciesReady" :
          return "DEPS_READY";
      case "RetryTrigger" :
          return "RETRY_TRIGGER";
      case "TelemetryFlushed" :
          return "TELEMETRY_FLUSHED";
      
    }
  } else {
    switch ($$event.TAG) {
      case "TaskSubmitted" :
          var payload = $$event._0;
          return "TASK_SUBMITTED:" + payload.taskId + "@" + payload.manifestVersion;
      case "RuleViolation" :
          return "RULE_VIOLATION:" + $$event._0;
      case "Timeout" :
          return "TIMEOUT:" + String($$event._0);
      case "CancelRequest" :
          return "CANCEL_REQUEST:" + $$event._0.requestedBy;
      
    }
  }
}

var $$Event = {
  toString: toString$2
};

function toString$3(effect) {
  if (typeof effect !== "object") {
    switch (effect) {
      case "EvaluateGuards" :
          return "EvaluateGuards";
      case "EnterWaitState" :
          return "EnterWaitState";
      case "ScheduleRetry" :
          return "ScheduleRetry";
      case "FlushTelemetryBuffer" :
          return "FlushTelemetryBuffer";
      
    }
  } else {
    switch (effect.TAG) {
      case "HydratePlan" :
          return "HydratePlan(" + effect._0 + ")";
      case "StartExecution" :
          return "StartExecution(" + effect._0 + ")";
      case "EmitTelemetry" :
          return "EmitTelemetry(" + effect._0 + ")";
      case "PerformRollback" :
          return "PerformRollback(" + effect._0 + ")";
      case "RecordCancellation" :
          return "RecordCancellation(" + effect._0 + ")";
      
    }
  }
}

var Effect = {
  toString: toString$3
};

var Context = {};

var emptyEffects = [];

function makeContext(dependenciesReady, guardVerdict, telemetryPending, cancellationRequested, param) {
  var deps = dependenciesReady !== undefined ? dependenciesReady : false;
  var guards = guardVerdict !== undefined ? guardVerdict : "Allowed";
  var telemetry = telemetryPending !== undefined ? telemetryPending : false;
  var cancellation = cancellationRequested !== undefined ? cancellationRequested : false;
  return {
          dependenciesReady: deps,
          guardVerdict: guards,
          telemetryPending: telemetry,
          cancellationRequested: cancellation
        };
}

function allowGuards() {
  return "Allowed";
}

function blockGuards(reason) {
  return {
          TAG: "Blocked",
          _0: reason
        };
}

function transitioned(fromState, toState, $$event, effects) {
  return {
          status: "Transitioned",
          fromState: fromState,
          toState: toState,
          event: $$event,
          effects: effects,
          reason: undefined
        };
}

function rejected(state, $$event, reason) {
  return {
          status: "Rejected",
          fromState: state,
          toState: state,
          event: $$event,
          effects: emptyEffects,
          reason: reason
        };
}

function deferred(state, $$event, reason) {
  return {
          status: "Deferred",
          fromState: state,
          toState: state,
          event: $$event,
          effects: [{
              TAG: "EmitTelemetry",
              _0: "transition.deferred"
            }],
          reason: reason
        };
}

function transition(state, $$event, context) {
  switch (state) {
    case "Bootstrapping" :
        if (typeof $$event !== "object" && $$event === "DependenciesReady") {
          return transitioned("Bootstrapping", "Idle", $$event, [{
                        TAG: "EmitTelemetry",
                        _0: "runtime.bootstrapped"
                      }]);
        } else {
          return rejected("Bootstrapping", $$event, "Runtime must finish bootstrapping before processing events.");
        }
    case "Idle" :
        if (typeof $$event !== "object" || $$event.TAG !== "TaskSubmitted") {
          return rejected("Idle", $$event, "Idle state only accepts task submissions.");
        } else {
          return transitioned("Idle", "Preparing", $$event, [
                      {
                        TAG: "HydratePlan",
                        _0: $$event._0.taskId
                      },
                      {
                        TAG: "EmitTelemetry",
                        _0: "task.accepted"
                      }
                    ]);
        }
    case "Preparing" :
        if (typeof $$event !== "object") {
          if ($$event !== "DependenciesReady") {
            return rejected("Preparing", $$event, "Preparing state only responds to deps/cancel/timeouts.");
          }
          if (!context.dependenciesReady) {
            return deferred("Preparing", $$event, "Dependencies not confirmed by controller.");
          }
          var reason = context.guardVerdict;
          if (typeof reason !== "object") {
            return transitioned("Preparing", "Executing", $$event, [
                        "EvaluateGuards",
                        {
                          TAG: "StartExecution",
                          _0: "plan"
                        }
                      ]);
          } else {
            return rejected("Preparing", $$event, "Guard blocked transition: " + reason._0);
          }
        } else {
          switch ($$event.TAG) {
            case "Timeout" :
                return transitioned("Preparing", "Failed", $$event, [{
                              TAG: "PerformRollback",
                              _0: "timeout:" + String($$event._0)
                            }]);
            case "CancelRequest" :
                if (context.cancellationRequested) {
                  return transitioned("Preparing", "Canceled", $$event, [{
                                TAG: "RecordCancellation",
                                _0: $$event._0.requestedBy
                              }]);
                } else {
                  return rejected("Preparing", $$event, "Cancellation request not acknowledged.");
                }
            default:
              return rejected("Preparing", $$event, "Preparing state only responds to deps/cancel/timeouts.");
          }
        }
    case "WaitingOnDependency" :
        if (typeof $$event !== "object") {
          switch ($$event) {
            case "DependenciesReady" :
                if (context.dependenciesReady) {
                  return transitioned("WaitingOnDependency", "Preparing", $$event, [{
                                TAG: "EmitTelemetry",
                                _0: "dependencies.ready"
                              }]);
                } else {
                  return deferred("WaitingOnDependency", $$event, "Dependency graph not ready; remaining in wait state.");
                }
            case "RetryTrigger" :
                return transitioned("WaitingOnDependency", "Preparing", $$event, ["ScheduleRetry"]);
            default:
              return rejected("WaitingOnDependency", $$event, "Waiting state expects dependency updates, retries, or cancellation.");
          }
        } else {
          switch ($$event.TAG) {
            case "Timeout" :
                return transitioned("WaitingOnDependency", "Failed", $$event, [{
                              TAG: "PerformRollback",
                              _0: "wait-timeout:" + String($$event._0)
                            }]);
            case "CancelRequest" :
                return transitioned("WaitingOnDependency", "Canceled", $$event, [{
                              TAG: "RecordCancellation",
                              _0: $$event._0.requestedBy
                            }]);
            default:
              return rejected("WaitingOnDependency", $$event, "Waiting state expects dependency updates, retries, or cancellation.");
          }
        }
    case "Executing" :
        if (typeof $$event !== "object") {
          if ($$event !== "TelemetryFlushed") {
            return rejected("Executing", $$event, "Executing state ignores unrelated events.");
          }
          var nextState = context.telemetryPending ? "Executing" : "Completed";
          return transitioned("Executing", nextState, $$event, ["FlushTelemetryBuffer"]);
        } else {
          switch ($$event.TAG) {
            case "RuleViolation" :
                return transitioned("Executing", "Failed", $$event, [{
                              TAG: "PerformRollback",
                              _0: $$event._0
                            }]);
            case "Timeout" :
                return transitioned("Executing", "Failed", $$event, [{
                              TAG: "PerformRollback",
                              _0: "execution-timeout:" + String($$event._0)
                            }]);
            case "CancelRequest" :
                return transitioned("Executing", "Canceled", $$event, [
                            {
                              TAG: "RecordCancellation",
                              _0: $$event._0.requestedBy
                            },
                            {
                              TAG: "PerformRollback",
                              _0: "canceled"
                            }
                          ]);
            default:
              return rejected("Executing", $$event, "Executing state ignores unrelated events.");
          }
        }
    case "Completed" :
        if (typeof $$event !== "object" && $$event === "TelemetryFlushed") {
          return transitioned("Completed", "Idle", $$event, [{
                        TAG: "EmitTelemetry",
                        _0: "task.completed"
                      }]);
        } else {
          return rejected("Completed", $$event, "Completed tasks await telemetry flush only.");
        }
    case "Failed" :
        if (typeof $$event !== "object" && $$event === "RetryTrigger") {
          return transitioned("Failed", "Preparing", $$event, ["ScheduleRetry"]);
        } else {
          return rejected("Failed", $$event, "Failed state only responds to retry triggers.");
        }
    case "Canceled" :
        if (typeof $$event !== "object" && $$event === "RetryTrigger") {
          return transitioned("Canceled", "Idle", $$event, [{
                        TAG: "EmitTelemetry",
                        _0: "task.canceled.retry"
                      }]);
        } else {
          return rejected("Canceled", $$event, "Canceled state only allows retries into idle.");
        }
    
  }
}

function statusToString(status) {
  switch (status) {
    case "Transitioned" :
        return "transitioned";
    case "Rejected" :
        return "rejected";
    case "Deferred" :
        return "deferred";
    
  }
}

function serializeOutcome(outcome) {
  return {
          status: statusToString(outcome.status),
          fromState: toString(outcome.fromState),
          toState: toString(outcome.toState),
          event: toString$2(outcome.event),
          effects: Belt_Array.map(outcome.effects, toString$3),
          reason: Js_null_undefined.fromOption(outcome.reason)
        };
}

var defaultContext = {
  dependenciesReady: false,
  guardVerdict: "Allowed",
  telemetryPending: false,
  cancellationRequested: false
};

export {
  State ,
  GuardVerdict ,
  $$Event ,
  Effect ,
  Context ,
  emptyEffects ,
  defaultContext ,
  makeContext ,
  allowGuards ,
  blockGuards ,
  transitioned ,
  rejected ,
  deferred ,
  transition ,
  statusToString ,
  serializeOutcome ,
}
/* No side effect */
