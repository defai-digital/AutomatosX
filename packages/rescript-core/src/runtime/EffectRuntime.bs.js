// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";

var defaultContext = {
  taskId: undefined,
  workingDirectory: ".",
  telemetryEndpoint: undefined,
  retryPolicy: {
    maxRetries: 3,
    backoffMs: 1000.0,
    maxBackoffMs: 60000.0
  }
};

function calculateBackoff(attempt, policy) {
  var exponentialBackoff = policy.backoffMs * Math.pow(2.0, attempt);
  var cappedBackoff = Math.min(exponentialBackoff, policy.maxBackoffMs);
  var jitter = cappedBackoff * 0.1 * Math.random();
  return cappedBackoff + jitter;
}

function executePlanHydration(_taskId, _context) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve("Success");
                      }), 10);
              }));
}

function executeGuardEvaluation(_context) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve("Success");
                      }), 5);
              }));
}

function executeTaskExecution(_taskId, _context) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve("Success");
                      }), 20);
              }));
}

function executeWaitState(_context) {
  return Promise.resolve("Success");
}

function executeTelemetryEmission(_label, context) {
  return new Promise((function (resolve, param) {
                var _endpoint = context.telemetryEndpoint;
                if (_endpoint !== undefined) {
                  setTimeout((function () {
                          resolve("Success");
                        }), 15);
                  return ;
                } else {
                  return resolve("Success");
                }
              }));
}

function executeRetryScheduling(context) {
  var backoff = calculateBackoff(1, context.retryPolicy);
  return Promise.resolve({
              TAG: "Deferred",
              _0: backoff
            });
}

function executeRollback(_reason, _context) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve("Success");
                      }), 30);
              }));
}

function executeCancellationRecording(_actor, _context) {
  return Promise.resolve("Success");
}

function executeTelemetryFlush(_context) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve("Success");
                      }), 25);
              }));
}

var EffectExecutor = {
  executePlanHydration: executePlanHydration,
  executeGuardEvaluation: executeGuardEvaluation,
  executeTaskExecution: executeTaskExecution,
  executeWaitState: executeWaitState,
  executeTelemetryEmission: executeTelemetryEmission,
  executeRetryScheduling: executeRetryScheduling,
  executeRollback: executeRollback,
  executeCancellationRecording: executeCancellationRecording,
  executeTelemetryFlush: executeTelemetryFlush
};

async function executeEffect(effect, _taskContext, execContext) {
  try {
    if (typeof effect !== "object") {
      switch (effect) {
        case "EvaluateGuards" :
            return await executeGuardEvaluation(execContext);
        case "EnterWaitState" :
            return await Promise.resolve("Success");
        case "ScheduleRetry" :
            return await executeRetryScheduling(execContext);
        case "FlushTelemetryBuffer" :
            return await executeTelemetryFlush(execContext);
        
      }
    } else {
      switch (effect.TAG) {
        case "HydratePlan" :
            return await executePlanHydration(effect._0, execContext);
        case "StartExecution" :
            return await executeTaskExecution(effect._0, execContext);
        case "EmitTelemetry" :
            return await executeTelemetryEmission(effect._0, execContext);
        case "PerformRollback" :
            return await executeRollback(effect._0, execContext);
        case "RecordCancellation" :
            return await Promise.resolve("Success");
        
      }
    }
  }
  catch (exn){
    return {
            TAG: "Failure",
            _0: "Effect execution failed due to uncaught exception"
          };
  }
}

async function executeEffectList(effects, taskContext, execContext) {
  var results = [];
  for(var i = 0 ,i_finish = effects.length; i < i_finish; ++i){
    var effect = Belt_Array.getExn(effects, i);
    var result = await executeEffect(effect, taskContext, execContext);
    results.push(result);
  }
  return results;
}

async function executeEffectListConcurrent(effects, taskContext, execContext) {
  var promises = Belt_Array.map(effects, (function (effect) {
          return executeEffect(effect, taskContext, execContext);
        }));
  return await Promise.all(promises);
}

var AsyncEffectHandler = {
  executeEffect: executeEffect,
  executeEffectList: executeEffectList,
  executeEffectListConcurrent: executeEffectListConcurrent
};

function createRuntime(context) {
  return {
          executionContext: context,
          pendingEffects: [],
          executedEffects: []
        };
}

function queueEffects(runtime, effects) {
  return {
          executionContext: runtime.executionContext,
          pendingEffects: Belt_Array.concat(runtime.pendingEffects, effects),
          executedEffects: runtime.executedEffects
        };
}

async function executePendingEffects(runtime, taskContext, concurrent) {
  if (runtime.pendingEffects.length === 0) {
    return runtime;
  }
  var results = concurrent ? await executeEffectListConcurrent(runtime.pendingEffects, taskContext, runtime.executionContext) : await executeEffectList(runtime.pendingEffects, taskContext, runtime.executionContext);
  var executed = Belt_Array.mapWithIndex(runtime.pendingEffects, (function (i, effect) {
          var result = Belt_Array.getExn(results, i);
          return [
                  effect,
                  result
                ];
        }));
  return {
          executionContext: runtime.executionContext,
          pendingEffects: [],
          executedEffects: Belt_Array.concat(runtime.executedEffects, executed)
        };
}

function getStats(runtime) {
  var total = runtime.executedEffects.length;
  var successful = Belt_Array.keep(runtime.executedEffects, (function (param) {
          var tmp = param[1];
          if (typeof tmp !== "object") {
            return true;
          } else {
            return false;
          }
        })).length;
  var failed = Belt_Array.keep(runtime.executedEffects, (function (param) {
          var tmp = param[1];
          if (typeof tmp !== "object" || tmp.TAG !== "Failure") {
            return false;
          } else {
            return true;
          }
        })).length;
  return [
          total,
          successful,
          failed
        ];
}

function allEffectsSucceeded(runtime) {
  var match = getStats(runtime);
  return match[0] === match[1];
}

function getFailedEffects(runtime) {
  return Belt_Array.keepMap(runtime.executedEffects, (function (param) {
                var result = param[1];
                if (typeof result !== "object" || result.TAG !== "Failure") {
                  return ;
                } else {
                  return [
                          param[0],
                          result._0
                        ];
                }
              }));
}

var EffectRuntime = {
  createRuntime: createRuntime,
  queueEffects: queueEffects,
  executePendingEffects: executePendingEffects,
  getStats: getStats,
  allEffectsSucceeded: allEffectsSucceeded,
  getFailedEffects: getFailedEffects
};

var defaultExecutionContext = defaultContext;

var createEffectRuntime = createRuntime;

var getRuntimeStats = getStats;

var checkAllSucceeded = allEffectsSucceeded;

var calculateRetryBackoff = calculateBackoff;

export {
  defaultContext ,
  calculateBackoff ,
  EffectExecutor ,
  AsyncEffectHandler ,
  EffectRuntime ,
  defaultExecutionContext ,
  createEffectRuntime ,
  queueEffects ,
  executePendingEffects ,
  getRuntimeStats ,
  checkAllSucceeded ,
  getFailedEffects ,
  executeEffect ,
  executeEffectList ,
  executeEffectListConcurrent ,
  calculateRetryBackoff ,
}
/* No side effect */
