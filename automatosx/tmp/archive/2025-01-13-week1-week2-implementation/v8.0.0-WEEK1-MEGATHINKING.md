# AutomatosX v8.0.0 - Week 1 Interactive CLI Mode Megathinking

**Date:** 2025-01-13
**Phase:** Week 1 (Days 1-5) - Interactive CLI Core Infrastructure
**Status:** üéØ Ready for Implementation
**Complexity:** Medium (5 new files, ~1,100 lines of code)
**Dependencies:** Existing ProviderRouterV2, AgentRegistry, ConversationDAO, MessageDAO

---

## Executive Summary

Week 1 focuses on building the **core REPL infrastructure** for Interactive CLI Mode - the foundation that transforms AutomatosX from an experts-only command-line tool into a ChatGPT-style conversational interface. This week delivers a working REPL with 13 slash commands, token-by-token streaming, and proper session management.

**Week 1 Deliverables:**
- ‚úÖ REPLSession with readline interface and input routing
- ‚úÖ SlashCommandRegistry with 13 built-in commands
- ‚úÖ StreamingHandler for token-by-token response display
- ‚úÖ Graceful shutdown (CTRL+C, CTRL+D)
- ‚úÖ 40+ unit tests with >80% coverage

**Success Criteria:**
- Launch REPL: `ax cli`
- Support all 13 slash commands
- Streaming responses <200ms latency
- Clean error handling and recovery

---

## Architecture Deep Dive

### Component Hierarchy

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                  CLI Entry Point                         ‚îÇ
‚îÇ              src/cli/commands/cli.ts                     ‚îÇ
‚îÇ                 (ax cli command)                         ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                     ‚îÇ
                     ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              REPLSession (Orchestrator)                  ‚îÇ
‚îÇ        src/cli/interactive/REPLSession.ts                ‚îÇ
‚îÇ  - Initialize readline                                   ‚îÇ
‚îÇ  - Display welcome screen                                ‚îÇ
‚îÇ  - Handle input routing                                  ‚îÇ
‚îÇ  - Manage session lifecycle                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ                      ‚îÇ
        ‚ñº                      ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ   Slash      ‚îÇ      ‚îÇ   Natural Language   ‚îÇ
‚îÇ  Commands    ‚îÇ      ‚îÇ      Router          ‚îÇ
‚îÇ              ‚îÇ      ‚îÇ   (Week 2 - Stub)    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
       ‚îÇ
       ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ          SlashCommandRegistry                            ‚îÇ
‚îÇ   src/cli/interactive/SlashCommandRegistry.ts            ‚îÇ
‚îÇ  - Register 13 commands                                  ‚îÇ
‚îÇ  - Parse command + arguments                             ‚îÇ
‚îÇ  - Execute commands                                      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ       Individual Slash Commands (13 total)               ‚îÇ
‚îÇ   src/cli/interactive/commands/                          ‚îÇ
‚îÇ  - HelpCommand, AgentsCommand, AgentCommand              ‚îÇ
‚îÇ  - MemoryCommand, WorkflowCommand, ContextCommand        ‚îÇ
‚îÇ  - ClearCommand, HistoryCommand, SaveCommand             ‚îÇ
‚îÇ  - LoadCommand, ConfigCommand, StatusCommand             ‚îÇ
‚îÇ  - ExitCommand                                           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
        ‚îÇ
        ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              StreamingHandler                            ‚îÇ
‚îÇ     src/cli/interactive/StreamingHandler.ts              ‚îÇ
‚îÇ  - Loading spinners                                      ‚îÇ
‚îÇ  - Token-by-token streaming                              ‚îÇ
‚îÇ  - Color-coded output                                    ‚îÇ
‚îÇ  - Error/success formatting                              ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Data Flow: User Input to Response

```
User Input: "find authentication logic"
    ‚îÇ
    ‚ñº
REPLSession.handleInput(input)
    ‚îÇ
    ‚îú‚îÄ Starts with '/' ? ‚îÄ‚îÄYES‚îÄ‚îÄ‚ñ∂ SlashCommandRegistry.execute()
    ‚îÇ                              ‚îÇ
    ‚îÇ                              ‚ñº
    ‚îÇ                         Parse command name + args
    ‚îÇ                              ‚îÇ
    ‚îÇ                              ‚ñº
    ‚îÇ                         Find matching SlashCommand
    ‚îÇ                              ‚îÇ
    ‚îÇ                              ‚ñº
    ‚îÇ                         command.execute(args)
    ‚îÇ                              ‚îÇ
    ‚îÇ                              ‚ñº
    ‚îÇ                         StreamingHandler.display()
    ‚îÇ
    ‚îî‚îÄ NO (Natural Language) ‚îÄ‚îÄ‚ñ∂ NaturalLanguageRouter.route()
                                  ‚îÇ
                                  ‚ñº
                            [Week 2 Implementation]
```

### Session Lifecycle

```
1. User runs: ax cli
    ‚Üì
2. REPLSession.start()
    ‚Üì
3. Display welcome screen
    ‚Üì
4. Show prompt: "> "
    ‚Üì
5. Wait for user input (readline)
    ‚Üì
6. Input received ‚Üí handleInput()
    ‚Üì
7. Route to slash command or NL router
    ‚Üì
8. Execute and stream response
    ‚Üì
9. Return to prompt (loop)
    ‚Üì
10. User presses CTRL+C or types /exit
    ‚Üì
11. REPLSession.stop()
    ‚Üì
12. Graceful shutdown
```

---

## Implementation Plan - Day by Day

### **Day 1: REPLSession Foundation**

**Goal:** Create REPLSession with basic readline interface and input routing

**Tasks:**
1. Create `src/cli/interactive/REPLSession.ts` (120 lines)
2. Implement `start()`, `stop()`, `handleInput()` methods
3. Initialize readline interface with basic autocomplete
4. Handle CTRL+C and CTRL+D gracefully
5. Route input to slash commands vs natural language (stub NL router)

**Code Outline:**
```typescript
// src/cli/interactive/REPLSession.ts
import * as readline from 'readline';
import chalk from 'chalk';
import { SlashCommandRegistry } from './SlashCommandRegistry.js';
import { StreamingHandler } from './StreamingHandler.js';

export class REPLSession {
  private rl: readline.Interface;
  private registry: SlashCommandRegistry;
  private streaming: StreamingHandler;
  private isProcessing: boolean = false;
  private isRunning: boolean = false;

  constructor() {
    this.registry = new SlashCommandRegistry();
    this.streaming = new StreamingHandler();
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: chalk.cyan('> '),
      completer: this.autocomplete.bind(this),
    });
  }

  async start(): Promise<void> {
    this.isRunning = true;
    this.displayWelcome();
    this.setupEventHandlers();
    this.rl.prompt();

    return new Promise((resolve) => {
      this.rl.on('close', () => {
        resolve();
      });
    });
  }

  async stop(): Promise<void> {
    if (!this.isRunning) return;
    this.isRunning = false;
    console.log(chalk.yellow('\nüëã Goodbye!\n'));
    this.rl.close();
  }

  private setupEventHandlers(): void {
    this.rl.on('line', async (input: string) => {
      if (this.isProcessing) return;
      await this.handleInput(input.trim());
      this.rl.prompt();
    });

    this.rl.on('SIGINT', () => {
      this.stop();
    });

    process.on('SIGTERM', () => {
      this.stop();
    });
  }

  private async handleInput(input: string): Promise<void> {
    if (!input) return;

    this.isProcessing = true;

    try {
      if (input.startsWith('/')) {
        // Slash command
        await this.registry.execute(input);
      } else {
        // Natural language (Week 2)
        console.log(chalk.gray('Natural language routing coming in Week 2...'));
      }
    } catch (error) {
      this.streaming.displayError(error as Error);
    } finally {
      this.isProcessing = false;
    }
  }

  private autocomplete(line: string): [string[], string] {
    const commands = this.registry.list().map(cmd => `/${cmd.name}`);
    const hits = commands.filter(c => c.startsWith(line));
    return [hits.length ? hits : commands, line];
  }

  private displayWelcome(): void {
    console.log(chalk.bold.cyan('\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó'));
    console.log(chalk.bold.cyan('‚ïë       AutomatosX Interactive CLI Mode v8.0.0     ‚ïë'));
    console.log(chalk.bold.cyan('‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n'));
    console.log(chalk.white('Type /help for available commands or ask me anything!\n'));
  }
}
```

**Tests:**
```typescript
// src/cli/interactive/__tests__/REPLSession.test.ts
describe('REPLSession', () => {
  it('should initialize readline interface');
  it('should route slash commands to registry');
  it('should handle CTRL+C gracefully');
  it('should handle CTRL+D (EOF) gracefully');
  it('should provide autocomplete suggestions');
  it('should ignore empty input');
  it('should trim whitespace from input');
  it('should prevent concurrent input processing');
});
```

**Deliverable:** Working REPL that launches and handles basic input routing

---

### **Day 2: CLI Command Integration**

**Goal:** Wire up REPL to main CLI and add basic testing

**Tasks:**
1. Create CLI command handler in `src/cli/commands/cli.ts` (30 lines)
2. Register `ax cli` command in `src/cli/index.ts`
3. Add integration test for REPL startup
4. Test autocomplete functionality
5. Test graceful shutdown

**Code Outline:**
```typescript
// src/cli/commands/cli.ts
import { Command } from 'commander';
import { REPLSession } from '../interactive/REPLSession.js';

export function createCLICommand(): Command {
  const cmd = new Command('cli');

  cmd
    .description('Launch interactive CLI mode')
    .alias('repl')
    .action(async () => {
      const session = new REPLSession();
      await session.start();
    });

  return cmd;
}
```

**Tests:**
```typescript
// src/cli/__tests__/cli-command.test.ts
describe('CLI Command', () => {
  it('should launch REPL session');
  it('should support "repl" alias');
  it('should exit cleanly on CTRL+C');
});
```

**Deliverable:** `ax cli` launches interactive session

---

### **Day 3: SlashCommandRegistry + Core Commands (Part 1)**

**Goal:** Implement SlashCommandRegistry and first 7 slash commands

**Tasks:**
1. Create `src/cli/interactive/SlashCommandRegistry.ts` (150 lines)
2. Define `SlashCommand` interface
3. Implement registry with registration and execution
4. Implement 7 commands (Part 1):
   - `/help` - Show all commands
   - `/exit` - Exit REPL
   - `/clear` - Clear screen
   - `/config` - Show configuration
   - `/status` - System status
   - `/context` - Show current context (stub)
   - `/history` - Show history (stub)

**Code Outline:**
```typescript
// src/cli/interactive/SlashCommandRegistry.ts
import type { ConversationContext } from './ConversationContext.js';

export interface SlashCommand {
  name: string;
  description: string;
  usage: string;
  aliases?: string[];
  execute(args: string[], context?: ConversationContext): Promise<void>;
}

export class SlashCommandRegistry {
  private commands: Map<string, SlashCommand> = new Map();

  constructor() {
    this.registerBuiltinCommands();
  }

  register(command: SlashCommand): void {
    this.commands.set(command.name, command);
    command.aliases?.forEach(alias => {
      this.commands.set(alias, command);
    });
  }

  get(name: string): SlashCommand | undefined {
    return this.commands.get(name);
  }

  list(): SlashCommand[] {
    // Return unique commands (filter out aliases)
    const seen = new Set<SlashCommand>();
    return Array.from(this.commands.values()).filter(cmd => {
      if (seen.has(cmd)) return false;
      seen.add(cmd);
      return true;
    });
  }

  async execute(input: string, context?: ConversationContext): Promise<void> {
    const [commandName, ...args] = input.slice(1).split(/\s+/);
    const command = this.get(commandName);

    if (!command) {
      throw new Error(`Unknown command: /${commandName}. Type /help for available commands.`);
    }

    await command.execute(args, context);
  }

  private registerBuiltinCommands(): void {
    // Register all 13 builtin commands
    this.register(new HelpCommand(this));
    this.register(new ExitCommand());
    this.register(new ClearCommand());
    this.register(new ConfigCommand());
    this.register(new StatusCommand());
    this.register(new ContextCommand());
    this.register(new HistoryCommand());
    // Week 1: Implement these 7, stub the rest
  }
}
```

**Command Implementations:**

```typescript
// src/cli/interactive/commands/HelpCommand.ts
export class HelpCommand implements SlashCommand {
  name = 'help';
  description = 'Show available commands';
  usage = '/help';
  aliases = ['h', '?'];

  constructor(private registry: SlashCommandRegistry) {}

  async execute(): Promise<void> {
    console.log(chalk.bold.cyan('\nüìã Available Commands\n'));

    const commands = this.registry.list();
    commands.forEach(cmd => {
      const aliases = cmd.aliases ? ` (${cmd.aliases.join(', ')})` : '';
      console.log(chalk.cyan(`  /${cmd.name}${aliases}`));
      console.log(chalk.gray(`    ${cmd.description}`));
      console.log(chalk.gray(`    Usage: ${cmd.usage}\n`));
    });
  }
}

// src/cli/interactive/commands/ExitCommand.ts
export class ExitCommand implements SlashCommand {
  name = 'exit';
  description = 'Exit interactive CLI mode';
  usage = '/exit';
  aliases = ['quit', 'q'];

  async execute(): Promise<void> {
    process.exit(0);
  }
}

// src/cli/interactive/commands/ClearCommand.ts
export class ClearCommand implements SlashCommand {
  name = 'clear';
  description = 'Clear conversation screen';
  usage = '/clear';

  async execute(): Promise<void> {
    console.clear();
    console.log(chalk.green('‚úì Screen cleared\n'));
  }
}

// src/cli/interactive/commands/ConfigCommand.ts
import { getConfig } from '../../../config/index.js';

export class ConfigCommand implements SlashCommand {
  name = 'config';
  description = 'Show current configuration';
  usage = '/config [key]';

  async execute(args: string[]): Promise<void> {
    const config = getConfig();

    if (args.length > 0) {
      // Show specific key
      const key = args[0];
      const value = (config as any)[key];
      console.log(chalk.cyan(`\n${key}:`), JSON.stringify(value, null, 2), '\n');
    } else {
      // Show all config
      console.log(chalk.bold.cyan('\n‚öôÔ∏è  Configuration\n'));
      console.log(JSON.stringify(config, null, 2), '\n');
    }
  }
}

// src/cli/interactive/commands/StatusCommand.ts
export class StatusCommand implements SlashCommand {
  name = 'status';
  description = 'Show system status';
  usage = '/status';

  async execute(): Promise<void> {
    const memUsage = process.memoryUsage();
    const uptime = process.uptime();

    console.log(chalk.bold.cyan('\nüìä System Status\n'));
    console.log(chalk.white('  Memory Usage:'));
    console.log(chalk.gray(`    RSS: ${(memUsage.rss / 1024 / 1024).toFixed(2)} MB`));
    console.log(chalk.gray(`    Heap: ${(memUsage.heapUsed / 1024 / 1024).toFixed(2)} MB`));
    console.log(chalk.white('  Uptime:'), chalk.gray(`${uptime.toFixed(0)}s`));
    console.log();
  }
}

// src/cli/interactive/commands/ContextCommand.ts
export class ContextCommand implements SlashCommand {
  name = 'context';
  description = 'Show current conversation context';
  usage = '/context';

  async execute(_args: string[], context?: ConversationContext): Promise<void> {
    console.log(chalk.bold.cyan('\nüîç Current Context\n'));

    if (!context) {
      console.log(chalk.gray('  No context available (Week 2 feature)\n'));
      return;
    }

    console.log(chalk.white('  Session ID:'), chalk.gray(context.conversationId));
    console.log(chalk.white('  Message Count:'), chalk.gray(context.messageCount));
    console.log(chalk.white('  Active Agent:'), chalk.gray(context.activeAgent || 'none'));
    console.log();
  }
}

// src/cli/interactive/commands/HistoryCommand.ts
export class HistoryCommand implements SlashCommand {
  name = 'history';
  description = 'Show conversation history';
  usage = '/history [limit]';
  aliases = ['h'];

  async execute(args: string[]): Promise<void> {
    const limit = args.length > 0 ? parseInt(args[0], 10) : 10;

    console.log(chalk.bold.cyan(`\nüìú Last ${limit} Messages\n`));
    console.log(chalk.gray('  History retrieval coming in Week 2...\n'));
  }
}
```

**Tests:**
```typescript
// src/cli/interactive/__tests__/SlashCommandRegistry.test.ts
describe('SlashCommandRegistry', () => {
  it('should register and retrieve commands');
  it('should list all unique commands');
  it('should execute command by name');
  it('should execute command by alias');
  it('should throw error for unknown command');
  it('should parse command arguments correctly');
});

// src/cli/interactive/commands/__tests__/
describe('HelpCommand', () => { /* tests */ });
describe('ExitCommand', () => { /* tests */ });
describe('ClearCommand', () => { /* tests */ });
describe('ConfigCommand', () => { /* tests */ });
describe('StatusCommand', () => { /* tests */ });
describe('ContextCommand', () => { /* tests */ });
describe('HistoryCommand', () => { /* tests */ });
```

**Deliverable:** 7 core slash commands functional

---

### **Day 4: Remaining Slash Commands (Part 2)**

**Goal:** Implement remaining 6 slash commands

**Tasks:**
1. Implement `/agents` - List agents with filtering
2. Implement `/agent <name>` - Set active agent
3. Implement `/memory <query>` - Search memory
4. Implement `/workflow <path>` - Run workflow
5. Implement `/save <path>` - Export conversation (stub)
6. Implement `/load <path>` - Import conversation (stub)

**Code Outline:**

```typescript
// src/cli/interactive/commands/AgentsCommand.ts
import { AgentRegistry } from '../../../agents/AgentRegistry.js';

export class AgentsCommand implements SlashCommand {
  name = 'agents';
  description = 'List available agents';
  usage = '/agents [filter]';

  constructor(private registry: AgentRegistry) {}

  async execute(args: string[]): Promise<void> {
    const filter = args[0];
    const agents = this.registry.list();
    const filtered = filter
      ? agents.filter(a => a.name.toLowerCase().includes(filter.toLowerCase()))
      : agents;

    console.log(chalk.bold.cyan('\nü§ñ Available Agents\n'));

    if (filtered.length === 0) {
      console.log(chalk.yellow(`  No agents found matching "${filter}"\n`));
      return;
    }

    filtered.forEach(agent => {
      console.log(chalk.cyan(`  ${agent.name}`));
      console.log(chalk.gray(`    ${agent.description}`));
      console.log(chalk.gray(`    Specializations: ${agent.specializations.join(', ')}\n`));
    });
  }
}

// src/cli/interactive/commands/AgentCommand.ts
export class AgentCommand implements SlashCommand {
  name = 'agent';
  description = 'Set active agent for conversation';
  usage = '/agent <name>';

  constructor(private registry: AgentRegistry) {}

  async execute(args: string[], context?: ConversationContext): Promise<void> {
    if (args.length === 0) {
      console.log(chalk.yellow('\n‚ö†Ô∏è  Please specify an agent name\n'));
      console.log(chalk.gray('  Usage: /agent <name>\n'));
      return;
    }

    const agentName = args[0];
    const agent = this.registry.get(agentName);

    if (!agent) {
      console.log(chalk.red(`\n‚ùå Agent "${agentName}" not found\n`));
      return;
    }

    if (context) {
      context.activeAgent = agentName;
    }

    console.log(chalk.green(`\n‚úì Active agent set to: ${agentName}\n`));
  }
}

// src/cli/interactive/commands/MemoryCommand.ts
import { MemoryService } from '../../../memory/MemoryService.js';

export class MemoryCommand implements SlashCommand {
  name = 'memory';
  description = 'Search conversation memory';
  usage = '/memory <query>';
  aliases = ['m'];

  constructor(private memoryService: MemoryService) {}

  async execute(args: string[]): Promise<void> {
    if (args.length === 0) {
      console.log(chalk.yellow('\n‚ö†Ô∏è  Please provide a search query\n'));
      return;
    }

    const query = args.join(' ');
    console.log(chalk.cyan(`\nüîç Searching for: "${query}"\n`));

    try {
      const results = await this.memoryService.search(query, { limit: 10 });

      if (results.length === 0) {
        console.log(chalk.gray('  No results found\n'));
        return;
      }

      results.forEach((result, idx) => {
        console.log(chalk.white(`${idx + 1}. ${result.file}`));
        console.log(chalk.gray(`   ${result.content.slice(0, 100)}...`));
        console.log(chalk.gray(`   Score: ${result.score.toFixed(2)}\n`));
      });
    } catch (error) {
      console.log(chalk.red(`\n‚ùå Search failed: ${(error as Error).message}\n`));
    }
  }
}

// src/cli/interactive/commands/WorkflowCommand.ts
import { WorkflowEngineV2 } from '../../../services/WorkflowEngineV2.js';
import * as fs from 'fs/promises';
import * as yaml from 'yaml';

export class WorkflowCommand implements SlashCommand {
  name = 'workflow';
  description = 'Run a workflow file';
  usage = '/workflow <path>';
  aliases = ['w'];

  constructor(private engine: WorkflowEngineV2) {}

  async execute(args: string[]): Promise<void> {
    if (args.length === 0) {
      console.log(chalk.yellow('\n‚ö†Ô∏è  Please specify a workflow file\n'));
      return;
    }

    const workflowPath = args[0];

    try {
      const content = await fs.readFile(workflowPath, 'utf-8');
      const workflow = yaml.parse(content);

      console.log(chalk.cyan(`\n‚ñ∂Ô∏è  Running workflow: ${workflow.name}\n`));

      const result = await this.engine.execute(workflow);

      console.log(chalk.green(`\n‚úì Workflow completed`));
      console.log(chalk.gray(`  Duration: ${result.duration}ms`));
      console.log(chalk.gray(`  Steps: ${result.completedSteps}/${result.totalSteps}\n`));
    } catch (error) {
      console.log(chalk.red(`\n‚ùå Workflow failed: ${(error as Error).message}\n`));
    }
  }
}

// src/cli/interactive/commands/SaveCommand.ts
export class SaveCommand implements SlashCommand {
  name = 'save';
  description = 'Export conversation to file';
  usage = '/save <path>';

  async execute(args: string[]): Promise<void> {
    if (args.length === 0) {
      console.log(chalk.yellow('\n‚ö†Ô∏è  Please specify output path\n'));
      return;
    }

    console.log(chalk.gray('\nüíæ Save functionality coming in Week 2...\n'));
  }
}

// src/cli/interactive/commands/LoadCommand.ts
export class LoadCommand implements SlashCommand {
  name = 'load';
  description = 'Import conversation from file';
  usage = '/load <path>';

  async execute(args: string[]): Promise<void> {
    if (args.length === 0) {
      console.log(chalk.yellow('\n‚ö†Ô∏è  Please specify file path\n'));
      return;
    }

    console.log(chalk.gray('\nüìÇ Load functionality coming in Week 2...\n'));
  }
}
```

**Tests:**
```typescript
describe('AgentsCommand', () => {
  it('should list all agents');
  it('should filter agents by name');
  it('should handle empty filter');
});

describe('AgentCommand', () => {
  it('should set active agent');
  it('should error on unknown agent');
  it('should require agent name');
});

describe('MemoryCommand', () => {
  it('should search memory and display results');
  it('should handle no results');
  it('should require query');
});

describe('WorkflowCommand', () => {
  it('should run workflow file');
  it('should handle file not found');
  it('should display results');
});
```

**Deliverable:** All 13 slash commands implemented

---

### **Day 5: StreamingHandler + Polish**

**Goal:** Implement streaming output handler and polish REPL UX

**Tasks:**
1. Create `src/cli/interactive/StreamingHandler.ts` (100 lines)
2. Implement loading spinners with `ora`
3. Implement token-by-token streaming
4. Color-coded output (user, assistant, system, error)
5. Success/error formatting
6. Integration testing
7. Polish welcome screen
8. Add autocomplete improvements

**Code Outline:**

```typescript
// src/cli/interactive/StreamingHandler.ts
import chalk from 'chalk';
import ora, { Ora } from 'ora';

export class StreamingHandler {
  private spinner?: Ora;
  private currentLine: string = '';

  /**
   * Start loading indicator
   */
  startThinking(message: string = 'Thinking...'): void {
    this.spinner = ora({
      text: message,
      color: 'cyan',
    }).start();
  }

  /**
   * Stop loading indicator
   */
  stopThinking(): void {
    if (this.spinner) {
      this.spinner.stop();
      this.spinner = undefined;
    }
  }

  /**
   * Stream a single token without newline
   */
  streamToken(token: string): void {
    // Stop spinner if still active
    this.stopThinking();

    // Write token without newline
    process.stdout.write(chalk.white(token));
    this.currentLine += token;

    // Track line breaks
    if (token.includes('\n')) {
      this.currentLine = '';
    }
  }

  /**
   * Finish streaming and ensure newline
   */
  finishStream(): void {
    if (this.currentLine && !this.currentLine.endsWith('\n')) {
      process.stdout.write('\n');
    }
    this.currentLine = '';
  }

  /**
   * Display error message
   */
  displayError(error: Error): void {
    this.stopThinking();
    console.log(chalk.red('\n‚ùå Error: ') + error.message);
    if (error.stack) {
      console.log(chalk.gray(error.stack));
    }
    console.log();
  }

  /**
   * Display success message
   */
  displaySuccess(message: string): void {
    this.stopThinking();
    console.log(chalk.green('\n‚úÖ ' + message + '\n'));
  }

  /**
   * Display info message
   */
  displayInfo(message: string): void {
    console.log(chalk.cyan('\n‚ÑπÔ∏è  ' + message + '\n'));
  }

  /**
   * Display warning message
   */
  displayWarning(message: string): void {
    console.log(chalk.yellow('\n‚ö†Ô∏è  ' + message + '\n'));
  }

  /**
   * Display system message
   */
  displaySystem(message: string): void {
    console.log(chalk.gray('\n[System] ' + message + '\n'));
  }

  /**
   * Clear current line (for progress updates)
   */
  clearLine(): void {
    process.stdout.clearLine(0);
    process.stdout.cursorTo(0);
  }

  /**
   * Display progress bar
   */
  displayProgress(current: number, total: number, label: string = 'Progress'): void {
    const percentage = Math.round((current / total) * 100);
    const barLength = 30;
    const filled = Math.round((current / total) * barLength);
    const empty = barLength - filled;

    this.clearLine();
    const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty);
    process.stdout.write(
      chalk.cyan(`${label}: [${bar}] ${percentage}% (${current}/${total})`)
    );

    if (current >= total) {
      process.stdout.write('\n');
    }
  }
}
```

**Tests:**
```typescript
// src/cli/interactive/__tests__/StreamingHandler.test.ts
describe('StreamingHandler', () => {
  let handler: StreamingHandler;
  let stdoutSpy: jest.SpyInstance;

  beforeEach(() => {
    handler = new StreamingHandler();
    stdoutSpy = jest.spyOn(process.stdout, 'write').mockImplementation();
  });

  afterEach(() => {
    stdoutSpy.mockRestore();
  });

  it('should start and stop thinking indicator');
  it('should stream tokens without newlines');
  it('should handle line breaks correctly');
  it('should finish stream with newline');
  it('should display error in red');
  it('should display success in green');
  it('should display info in cyan');
  it('should display warning in yellow');
  it('should display system message in gray');
  it('should clear current line');
  it('should display progress bar');
});
```

**Integration Tests:**

```typescript
// src/__tests__/integration/interactive-cli.test.ts
describe('Interactive CLI Integration', () => {
  it('should launch REPL and handle slash commands', async () => {
    const session = new REPLSession();

    // Simulate user inputs
    await session.handleInput('/help');
    await session.handleInput('/agents');
    await session.handleInput('/status');
    await session.handleInput('/exit');

    // Verify commands executed
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Available Commands'));
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('Available Agents'));
    expect(consoleLogSpy).toHaveBeenCalledWith(expect.stringContaining('System Status'));
  });

  it('should handle errors gracefully', async () => {
    const session = new REPLSession();

    await session.handleInput('/unknown-command');

    expect(consoleErrorSpy).toHaveBeenCalledWith(expect.stringContaining('Unknown command'));
  });
});
```

**Deliverable:** Production-ready REPL with polished UX

---

## File Structure

```
src/cli/
‚îú‚îÄ‚îÄ commands/
‚îÇ   ‚îî‚îÄ‚îÄ cli.ts                         # NEW: ax cli command (30 lines)
‚îÇ
‚îú‚îÄ‚îÄ interactive/                       # NEW DIRECTORY
‚îÇ   ‚îú‚îÄ‚îÄ REPLSession.ts                 # NEW: REPL orchestrator (120 lines)
‚îÇ   ‚îú‚îÄ‚îÄ SlashCommandRegistry.ts        # NEW: Command registry (150 lines)
‚îÇ   ‚îú‚îÄ‚îÄ StreamingHandler.ts            # NEW: Streaming output (100 lines)
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ commands/                      # NEW DIRECTORY
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HelpCommand.ts             # NEW: /help (40 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ExitCommand.ts             # NEW: /exit (15 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ClearCommand.ts            # NEW: /clear (15 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AgentsCommand.ts           # NEW: /agents (50 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AgentCommand.ts            # NEW: /agent (40 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ MemoryCommand.ts           # NEW: /memory (60 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ WorkflowCommand.ts         # NEW: /workflow (70 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ContextCommand.ts          # NEW: /context (30 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ HistoryCommand.ts          # NEW: /history (30 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ConfigCommand.ts           # NEW: /config (40 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ StatusCommand.ts           # NEW: /status (35 lines)
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SaveCommand.ts             # NEW: /save (20 lines - stub)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoadCommand.ts             # NEW: /load (20 lines - stub)
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ __tests__/                     # NEW DIRECTORY
‚îÇ       ‚îú‚îÄ‚îÄ REPLSession.test.ts        # 8 tests
‚îÇ       ‚îú‚îÄ‚îÄ SlashCommandRegistry.test.ts # 6 tests
‚îÇ       ‚îú‚îÄ‚îÄ StreamingHandler.test.ts   # 11 tests
‚îÇ       ‚îî‚îÄ‚îÄ commands/
‚îÇ           ‚îú‚îÄ‚îÄ HelpCommand.test.ts    # 3 tests
‚îÇ           ‚îú‚îÄ‚îÄ AgentsCommand.test.ts  # 4 tests
‚îÇ           ‚îú‚îÄ‚îÄ AgentCommand.test.ts   # 4 tests
‚îÇ           ‚îú‚îÄ‚îÄ MemoryCommand.test.ts  # 4 tests
‚îÇ           ‚îú‚îÄ‚îÄ WorkflowCommand.test.ts # 4 tests
‚îÇ           ‚îî‚îÄ‚îÄ ... (6 more test files)
```

**Total New Code:**
- New Files: 18 (5 core + 13 commands)
- Total Lines: ~1,100
- Test Files: 16
- Test Count: 40+

---

## Dependencies

### NPM Packages to Install

```bash
npm install --save ora inquirer
npm install --save-dev @types/inquirer
```

| Package | Purpose | Version |
|---------|---------|---------|
| `readline` | Core REPL interface | Built-in Node.js |
| `ora` | Loading spinners | ^8.1.1 |
| `inquirer` | Interactive prompts (Week 2) | ^11.2.0 |
| `chalk` | Terminal colors | Already installed |

### Internal Dependencies (Already Available)

```typescript
// Existing services to import
import { AgentRegistry } from '../../agents/AgentRegistry.js';
import { WorkflowEngineV2 } from '../../services/WorkflowEngineV2.js';
import { MemoryService } from '../../memory/MemoryService.js';
import { getConfig } from '../../config/index.js';
```

---

## Testing Strategy

### Unit Test Coverage Targets

| Component | Tests | Coverage Target |
|-----------|-------|-----------------|
| REPLSession | 8 tests | >85% |
| SlashCommandRegistry | 6 tests | >90% |
| StreamingHandler | 11 tests | >80% |
| Individual Commands | 3-4 each (40 total) | >80% |

### Test Execution

```bash
# Run all interactive CLI tests
npm test -- src/cli/interactive/__tests__/

# Run specific test file
npm test -- src/cli/interactive/__tests__/REPLSession.test.ts

# Run with coverage
npm test -- src/cli/interactive/ --coverage
```

### Manual Testing Checklist (Day 5)

- [ ] Launch REPL: `ax cli`
- [ ] Welcome screen displays correctly
- [ ] Prompt shows: `> `
- [ ] Type `/help`, see all 13 commands
- [ ] Type `/agents`, see agent list
- [ ] Type `/agent security`, active agent set
- [ ] Type `/memory "test"`, see search results
- [ ] Type `/workflow <path>`, workflow runs
- [ ] Type `/config`, configuration displayed
- [ ] Type `/status`, system status shown
- [ ] Type `/context`, context displayed
- [ ] Type `/history`, history shown (stub message)
- [ ] Type `/clear`, screen clears
- [ ] Type `/save test.json`, stub message shown
- [ ] Type `/load test.json`, stub message shown
- [ ] Press TAB, autocomplete works
- [ ] Press UP/DOWN arrows, command history works
- [ ] Press CTRL+C, exits cleanly
- [ ] Type `/exit`, exits cleanly
- [ ] Type unknown command, error message shown
- [ ] Color coding correct (cyan, white, red, green, yellow)

---

## Success Criteria - Week 1 Gate

### Functional Requirements (Must Pass)

- ‚úÖ REPL launches with `ax cli` command
- ‚úÖ All 13 slash commands implemented and working
- ‚úÖ Input routing correct (slash vs natural language stub)
- ‚úÖ Graceful shutdown (CTRL+C, CTRL+D, `/exit`)
- ‚úÖ Autocomplete functional
- ‚úÖ Color-coded output working
- ‚úÖ No crashes on invalid input

### Quality Requirements (Must Pass)

- ‚úÖ >80% test coverage (40+ tests passing)
- ‚úÖ All unit tests passing
- ‚úÖ Integration tests passing
- ‚úÖ TypeScript compiles with no errors in new code
- ‚úÖ Manual testing checklist 100% complete

### Performance Requirements (Must Pass)

- ‚úÖ Input latency <200ms (keystroke to prompt return)
- ‚úÖ Command execution <500ms for slash commands
- ‚úÖ Memory usage <50MB additional for REPL session
- ‚úÖ No memory leaks during 100+ command session

### Non-Goals (Week 2)

- ‚ùå Natural language routing (stub only)
- ‚ùå Conversation context persistence
- ‚ùå AI provider streaming (stub only)
- ‚ùå Multi-turn conversation memory

---

## Risk Mitigation

### Risk 1: Readline Complexity

**Probability:** Low | **Impact:** Medium

**Mitigation:**
- Use built-in Node.js `readline` module (stable, well-documented)
- Extensive testing of edge cases (CTRL+C, CTRL+D, empty input)
- Graceful error handling for all input scenarios

### Risk 2: Command Discoverability

**Probability:** Medium | **Impact:** Medium

**Mitigation:**
- Prominent welcome screen with `/help` suggestion
- Autocomplete shows all commands on TAB
- `/help` command lists all commands with descriptions
- Aliases for common commands (`/h` for `/help`)

### Risk 3: Streaming Output Issues

**Probability:** Low | **Impact:** Low

**Mitigation:**
- Use proven `ora` library for spinners
- Batch tokens in small windows for smooth output
- Test with 1000+ token responses
- Separate concerns (StreamingHandler isolated)

### Risk 4: Test Coverage

**Probability:** Low | **Impact:** Low

**Mitigation:**
- Write tests alongside implementation (TDD approach)
- Use mocks for external services (AgentRegistry, MemoryService)
- Integration tests for full flow
- Manual testing checklist ensures UX quality

---

## Week 1 Deliverables Summary

### Code Deliverables

1. **REPLSession** (120 lines)
   - Readline interface with autocomplete
   - Input routing (slash vs NL)
   - Graceful shutdown handling
   - Welcome screen

2. **SlashCommandRegistry** (150 lines)
   - Command registration and lookup
   - Argument parsing
   - Execution orchestration

3. **StreamingHandler** (100 lines)
   - Loading spinners
   - Token-by-token streaming
   - Color-coded output
   - Progress bars

4. **13 Slash Commands** (~500 lines total)
   - HelpCommand, ExitCommand, ClearCommand
   - AgentsCommand, AgentCommand
   - MemoryCommand, WorkflowCommand
   - ContextCommand, HistoryCommand
   - ConfigCommand, StatusCommand
   - SaveCommand, LoadCommand

5. **CLI Command** (30 lines)
   - `ax cli` registration

### Test Deliverables

- **Unit Tests:** 40+ tests
- **Integration Tests:** 5+ tests
- **Coverage:** >80%

### Documentation Deliverables

- Code comments (JSDoc)
- Manual testing checklist
- Week 1 completion report

---

## Week 2 Preview

**Focus:** Context Management + Natural Language Routing

**New Components:**
- ConversationContext
- ContextManager (with DAO integration)
- NaturalLanguageRouter
- Pattern-based intent classification
- LLM fallback for complex queries

**Integration Points:**
- Wire NaturalLanguageRouter to REPLSession
- Integrate ContextManager with ConversationDAO/MessageDAO
- Add context to all slash commands
- Implement `/save` and `/load` fully

---

## Conclusion

Week 1 implementation delivers a **production-ready interactive REPL** with all core slash commands, streaming output, and graceful error handling. This foundation enables Week 2's context management and natural language routing to complete the Interactive CLI Mode feature.

**Confidence Level:** 95%

**Ready to Begin:** ‚úÖ Day 1 implementation

**Estimated Completion:** Day 5 (5 working days)

---

**Document Version:** 1.0
**Date:** 2025-01-13
**Author:** AutomatosX Engineering Team
**Next Review:** End of Week 1 (Day 5 completion)
