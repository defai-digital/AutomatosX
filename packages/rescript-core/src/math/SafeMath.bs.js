// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Float from "rescript/lib/es6/belt_Float.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Caml_int32 from "rescript/lib/es6/caml_int32.js";

function fromFloat(value, scaleOpt) {
  var scale = scaleOpt !== undefined ? scaleOpt : 4;
  var scaleFactor = Math.pow(10.0, scale);
  var scaled = Math.round(value * scaleFactor) | 0;
  return {
          value: scaled,
          scale: scale
        };
}

function toFloat(fp) {
  var scaleFactor = Math.pow(10.0, fp.scale);
  return fp.value / scaleFactor;
}

function fromInt(value, scaleOpt) {
  var scale = scaleOpt !== undefined ? scaleOpt : 4;
  var scaleFactor = Math.pow(10.0, scale) | 0;
  return {
          value: Math.imul(value, scaleFactor),
          scale: scale
        };
}

function toInt(fp) {
  var scaleFactor = Math.pow(10.0, fp.scale) | 0;
  return Caml_int32.div(fp.value, scaleFactor);
}

function fromString(str, scaleOpt) {
  var scale = scaleOpt !== undefined ? scaleOpt : 4;
  var value = Belt_Float.fromString(str);
  if (value !== undefined) {
    return {
            TAG: "Ok",
            _0: fromFloat(value, scale)
          };
  } else {
    return {
            TAG: "Error",
            _0: "Invalid number format: " + str
          };
  }
}

function toString(fp) {
  return String(toFloat(fp));
}

function add(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  }
  var sum = a.value + b.value | 0;
  if (sum > 2147483647 || sum < -2147483648) {
    return {
            TAG: "Error",
            _0: "Arithmetic overflow"
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              value: sum,
              scale: a.scale
            }
          };
  }
}

function subtract(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  }
  var diff = a.value - b.value | 0;
  return {
          TAG: "Ok",
          _0: {
            value: diff,
            scale: a.scale
          }
        };
}

function multiply(a, b) {
  var product = Math.imul(a.value, b.value);
  var scaleFactor = Math.pow(10.0, a.scale) | 0;
  var adjusted = Caml_int32.div(product, scaleFactor);
  return {
          TAG: "Ok",
          _0: {
            value: adjusted,
            scale: a.scale
          }
        };
}

function divide(a, b) {
  if (b.value === 0) {
    return {
            TAG: "Error",
            _0: "Division by zero"
          };
  }
  var scaleFactor = Math.pow(10.0, a.scale) | 0;
  var scaled = Math.imul(a.value, scaleFactor);
  var quotient = Caml_int32.div(scaled, b.value);
  return {
          TAG: "Ok",
          _0: {
            value: quotient,
            scale: a.scale
          }
        };
}

function negate(fp) {
  return {
          value: -fp.value | 0,
          scale: fp.scale
        };
}

function abs(fp) {
  return {
          value: Math.abs(fp.value),
          scale: fp.scale
        };
}

function equal(a, b) {
  if (a.scale === b.scale) {
    return a.value === b.value;
  } else {
    return false;
  }
}

function lessThan(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  } else {
    return {
            TAG: "Ok",
            _0: a.value < b.value
          };
  }
}

function lessThanOrEqual(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  } else {
    return {
            TAG: "Ok",
            _0: a.value <= b.value
          };
  }
}

function greaterThan(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  } else {
    return {
            TAG: "Ok",
            _0: a.value > b.value
          };
  }
}

function greaterThanOrEqual(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  } else {
    return {
            TAG: "Ok",
            _0: a.value >= b.value
          };
  }
}

function compare(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  } else if (a.value < b.value) {
    return {
            TAG: "Ok",
            _0: -1
          };
  } else if (a.value > b.value) {
    return {
            TAG: "Ok",
            _0: 1
          };
  } else {
    return {
            TAG: "Ok",
            _0: 0
          };
  }
}

function min(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  } else {
    return {
            TAG: "Ok",
            _0: a.value <= b.value ? a : b
          };
  }
}

function max(a, b) {
  if (a.scale !== b.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch: " + String(a.scale) + " != " + String(b.scale)
          };
  } else {
    return {
            TAG: "Ok",
            _0: a.value >= b.value ? a : b
          };
  }
}

function clamp(value, min, max) {
  if (value.scale !== min.scale || value.scale !== max.scale) {
    return {
            TAG: "Error",
            _0: "Scale mismatch in clamp"
          };
  }
  if (min.value > max.value) {
    return {
            TAG: "Error",
            _0: "Min must be <= max"
          };
  }
  var clamped = value.value < min.value ? min : (
      value.value > max.value ? max : value
    );
  return {
          TAG: "Ok",
          _0: clamped
        };
}

function sumArray(arr) {
  if (arr.length === 0) {
    return {
            TAG: "Ok",
            _0: {
              value: 0,
              scale: 4
            }
          };
  }
  var firstScale = Caml_array.get(arr, 0).scale;
  var sum = 0;
  var error;
  for(var i = 0 ,i_finish = arr.length; i < i_finish; ++i){
    if (Caml_array.get(arr, i).scale !== firstScale) {
      error = "Scale mismatch in array";
    } else {
      sum = sum + Caml_array.get(arr, i).value | 0;
    }
  }
  var err = error;
  if (err !== undefined) {
    return {
            TAG: "Error",
            _0: err
          };
  } else {
    return {
            TAG: "Ok",
            _0: {
              value: sum,
              scale: firstScale
            }
          };
  }
}

function average(arr) {
  var len = arr.length;
  if (len === 0) {
    return {
            TAG: "Error",
            _0: "Cannot average empty array"
          };
  }
  var sum = sumArray(arr);
  if (sum.TAG !== "Ok") {
    return {
            TAG: "Error",
            _0: sum._0
          };
  }
  var sum$1 = sum._0;
  var count = fromInt(len, sum$1.scale);
  return divide(sum$1, count);
}

function cosineSimilarity(a, b, scaleOpt) {
  var scale = scaleOpt !== undefined ? scaleOpt : 4;
  var lenA = a.length;
  var lenB = b.length;
  if (lenA !== lenB) {
    return {
            TAG: "Error",
            _0: "Vector length mismatch: " + String(lenA) + " != " + String(lenB)
          };
  }
  if (lenA === 0) {
    return {
            TAG: "Error",
            _0: "Cannot compute similarity of empty vectors"
          };
  }
  var dotProduct = 0.0;
  var normA = 0.0;
  var normB = 0.0;
  for(var i = 0; i < lenA; ++i){
    dotProduct = dotProduct + Caml_array.get(a, i) * Caml_array.get(b, i);
    normA = normA + Caml_array.get(a, i) * Caml_array.get(a, i);
    normB = normB + Caml_array.get(b, i) * Caml_array.get(b, i);
  }
  var normAProd = Math.sqrt(normA);
  var normBProd = Math.sqrt(normB);
  if (normAProd === 0.0 || normBProd === 0.0) {
    return {
            TAG: "Error",
            _0: "Cannot compute similarity of zero vector"
          };
  }
  var similarity = dotProduct / (normAProd * normBProd);
  return {
          TAG: "Ok",
          _0: fromFloat(similarity, scale)
        };
}

function dotProduct(a, b) {
  var lenA = a.length;
  var lenB = b.length;
  if (lenA !== lenB) {
    return {
            TAG: "Error",
            _0: "Vector length mismatch: " + String(lenA) + " != " + String(lenB)
          };
  }
  if (lenA === 0) {
    return {
            TAG: "Error",
            _0: "Cannot compute dot product of empty vectors"
          };
  }
  var firstScale = Caml_array.get(a, 0).scale;
  var result = {
    value: 0,
    scale: firstScale
  };
  var error;
  for(var i = 0; i < lenA; ++i){
    var product = multiply(Caml_array.get(a, i), Caml_array.get(b, i));
    if (product.TAG === "Ok") {
      var sum = add(result, product._0);
      if (sum.TAG === "Ok") {
        result = sum._0;
      } else {
        error = sum._0;
      }
    } else {
      error = product._0;
    }
  }
  var err = error;
  if (err !== undefined) {
    return {
            TAG: "Error",
            _0: err
          };
  } else {
    return {
            TAG: "Ok",
            _0: result
          };
  }
}

function euclideanDistance(a, b, scaleOpt) {
  var scale = scaleOpt !== undefined ? scaleOpt : 4;
  var lenA = a.length;
  var lenB = b.length;
  if (lenA !== lenB) {
    return {
            TAG: "Error",
            _0: "Vector length mismatch: " + String(lenA) + " != " + String(lenB)
          };
  }
  if (lenA === 0) {
    return {
            TAG: "Error",
            _0: "Cannot compute distance of empty vectors"
          };
  }
  var sumSquaredDiff = 0.0;
  for(var i = 0; i < lenA; ++i){
    var diff = Caml_array.get(a, i) - Caml_array.get(b, i);
    sumSquaredDiff = sumSquaredDiff + diff * diff;
  }
  var distance = Math.sqrt(sumSquaredDiff);
  return {
          TAG: "Ok",
          _0: fromFloat(distance, scale)
        };
}

function round(fp, decimals) {
  if (decimals >= fp.scale) {
    return fp;
  }
  var divisor = Math.pow(10.0, fp.scale - decimals | 0) | 0;
  var rounded = Math.imul(Caml_int32.div(fp.value + (divisor / 2 | 0) | 0, divisor), divisor);
  return {
          value: rounded,
          scale: fp.scale
        };
}

function floor(fp) {
  var scaleFactor = Math.pow(10.0, fp.scale) | 0;
  var floored = Math.imul(Caml_int32.div(fp.value, scaleFactor), scaleFactor);
  return {
          value: floored,
          scale: fp.scale
        };
}

function ceil(fp) {
  var scaleFactor = Math.pow(10.0, fp.scale) | 0;
  var ceiled = Math.imul(Caml_int32.div((fp.value + scaleFactor | 0) - 1 | 0, scaleFactor), scaleFactor);
  return {
          value: ceiled,
          scale: fp.scale
        };
}

var zero = {
  value: 0,
  scale: 4
};

var one = {
  value: 10000,
  scale: 4
};

var half = {
  value: 5000,
  scale: 4
};

var defaultScale = 4;

var defaultScaleFactor = 10000;

export {
  defaultScale ,
  defaultScaleFactor ,
  fromFloat ,
  toFloat ,
  fromInt ,
  toInt ,
  fromString ,
  toString ,
  add ,
  subtract ,
  multiply ,
  divide ,
  negate ,
  abs ,
  equal ,
  lessThan ,
  lessThanOrEqual ,
  greaterThan ,
  greaterThanOrEqual ,
  compare ,
  min ,
  max ,
  clamp ,
  sumArray ,
  average ,
  cosineSimilarity ,
  dotProduct ,
  euclideanDistance ,
  round ,
  floor ,
  ceil ,
  zero ,
  one ,
  half ,
}
/* No side effect */
