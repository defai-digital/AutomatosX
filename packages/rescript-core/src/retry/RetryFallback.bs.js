// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";

function getCurrentTime() {
  return Date.now();
}

function generateId(prefix) {
  var timestamp = Date.now();
  var random = Math.random();
  return prefix + "-" + String(timestamp) + "-" + String(random);
}

function calculateDelay(strategy, attemptNumber) {
  switch (strategy.TAG) {
    case "FixedDelay" :
        return strategy.delayMs;
    case "ExponentialBackoff" :
        var delay = strategy.initialDelayMs * Math.pow(strategy.multiplier, attemptNumber - 1 | 0);
        var delayInt = delay | 0;
        return Math.min(delayInt, strategy.maxDelayMs);
    case "LinearBackoff" :
        return strategy.initialDelayMs + Math.imul(strategy.incrementMs, attemptNumber - 1 | 0) | 0;
    case "RandomJitter" :
        var jitter = Math.random() * strategy.maxJitterMs | 0;
        return strategy.baseDelayMs + jitter | 0;
    
  }
}

function sleep(ms) {
  return new Promise((function (resolve, param) {
                setTimeout((function () {
                        resolve();
                      }), ms);
              }));
}

function defaultShouldRetry(_error) {
  return true;
}

function createCircuitBreakerConfig(failureThresholdOpt, successThresholdOpt, timeoutOpt, halfOpenMaxAttemptsOpt, param) {
  var failureThreshold = failureThresholdOpt !== undefined ? failureThresholdOpt : 5;
  var successThreshold = successThresholdOpt !== undefined ? successThresholdOpt : 2;
  var timeout = timeoutOpt !== undefined ? timeoutOpt : 60000;
  var halfOpenMaxAttempts = halfOpenMaxAttemptsOpt !== undefined ? halfOpenMaxAttemptsOpt : 3;
  return {
          failureThreshold: failureThreshold,
          successThreshold: successThreshold,
          timeout: timeout,
          halfOpenMaxAttempts: halfOpenMaxAttempts
        };
}

function createCircuitBreaker(id, config, param) {
  var defaultConfig = createCircuitBreakerConfig(undefined, undefined, undefined, undefined, undefined);
  var finalConfig = config !== undefined ? config : defaultConfig;
  var finalId = id !== undefined ? id : generateId("cb");
  return {
          id: finalId,
          state: "Closed",
          failureCount: 0,
          successCount: 0,
          lastFailureTime: undefined,
          config: finalConfig
        };
}

function recordSuccess(cb) {
  var match = cb.state;
  switch (match) {
    case "Closed" :
        return {
                id: cb.id,
                state: cb.state,
                failureCount: 0,
                successCount: 0,
                lastFailureTime: cb.lastFailureTime,
                config: cb.config
              };
    case "Open" :
        return cb;
    case "HalfOpen" :
        var newSuccessCount = cb.successCount + 1 | 0;
        if (newSuccessCount >= cb.config.successThreshold) {
          return {
                  id: cb.id,
                  state: "Closed",
                  failureCount: 0,
                  successCount: 0,
                  lastFailureTime: undefined,
                  config: cb.config
                };
        } else {
          return {
                  id: cb.id,
                  state: cb.state,
                  failureCount: cb.failureCount,
                  successCount: newSuccessCount,
                  lastFailureTime: cb.lastFailureTime,
                  config: cb.config
                };
        }
    
  }
}

function recordFailure(cb) {
  var now = Date.now();
  var match = cb.state;
  switch (match) {
    case "Closed" :
        var newFailureCount = cb.failureCount + 1 | 0;
        if (newFailureCount >= cb.config.failureThreshold) {
          return {
                  id: cb.id,
                  state: "Open",
                  failureCount: newFailureCount,
                  successCount: 0,
                  lastFailureTime: now,
                  config: cb.config
                };
        } else {
          return {
                  id: cb.id,
                  state: cb.state,
                  failureCount: newFailureCount,
                  successCount: cb.successCount,
                  lastFailureTime: now,
                  config: cb.config
                };
        }
    case "Open" :
        return {
                id: cb.id,
                state: cb.state,
                failureCount: cb.failureCount,
                successCount: cb.successCount,
                lastFailureTime: now,
                config: cb.config
              };
    case "HalfOpen" :
        return {
                id: cb.id,
                state: "Open",
                failureCount: cb.failureCount + 1 | 0,
                successCount: 0,
                lastFailureTime: now,
                config: cb.config
              };
    
  }
}

function shouldAttempt(cb) {
  var match = cb.state;
  switch (match) {
    case "Open" :
        var now = Date.now();
        var lastFailure = cb.lastFailureTime;
        if (lastFailure === undefined) {
          return [
                  true,
                  {
                    id: cb.id,
                    state: "HalfOpen",
                    failureCount: cb.failureCount,
                    successCount: 0,
                    lastFailureTime: cb.lastFailureTime,
                    config: cb.config
                  }
                ];
        }
        var elapsed = now - lastFailure;
        if (elapsed >= cb.config.timeout) {
          return [
                  true,
                  {
                    id: cb.id,
                    state: "HalfOpen",
                    failureCount: cb.failureCount,
                    successCount: 0,
                    lastFailureTime: cb.lastFailureTime,
                    config: cb.config
                  }
                ];
        } else {
          return [
                  false,
                  cb
                ];
        }
    case "Closed" :
    case "HalfOpen" :
        return [
                true,
                cb
              ];
    
  }
}

function getCircuitState(cb) {
  return cb.state;
}

function resetCircuitBreaker(cb) {
  return {
          id: cb.id,
          state: "Closed",
          failureCount: 0,
          successCount: 0,
          lastFailureTime: undefined,
          config: cb.config
        };
}

function createRetryConfig(maxAttemptsOpt, strategy, timeout, shouldRetry, param) {
  var maxAttempts = maxAttemptsOpt !== undefined ? maxAttemptsOpt : 3;
  return {
          maxAttempts: maxAttempts,
          strategy: strategy !== undefined ? strategy : ({
                TAG: "ExponentialBackoff",
                initialDelayMs: 100,
                maxDelayMs: 30000,
                multiplier: 2.0
              }),
          timeout: timeout,
          shouldRetry: shouldRetry
        };
}

async function retry(fn, config) {
  var startTime = Date.now();
  var attempts = [];
  var fn$1 = config.shouldRetry;
  var shouldRetryFn = fn$1 !== undefined ? fn$1 : defaultShouldRetry;
  var executeAttempt = async function (attemptNumber) {
    if (attemptNumber > config.maxAttempts) {
      var attempt = Belt_Array.get(attempts, attempts.length - 1 | 0);
      var lastError;
      if (attempt !== undefined) {
        var e = attempt.error;
        lastError = e !== undefined ? e : "Unknown error";
      } else {
        lastError = "Max attempts reached";
      }
      return {
              TAG: "Error",
              _0: "Max retry attempts (" + String(config.maxAttempts) + ") reached. Last error: " + lastError
            };
    }
    var attemptStart = Date.now();
    var result;
    try {
      result = await fn();
    }
    catch (raw_e){
      var e$1 = Caml_js_exceptions.internalToOCamlException(raw_e);
      if (e$1.RE_EXN_ID === Js_exn.$$Error) {
        var msg = e$1._1.message;
        result = msg !== undefined ? ({
              TAG: "Error",
              _0: msg
            }) : ({
              TAG: "Error",
              _0: "Unknown error"
            });
      } else {
        throw e$1;
      }
    }
    Date.now();
    var delayMs = attemptNumber < config.maxAttempts ? calculateDelay(config.strategy, attemptNumber) : 0;
    var tmp;
    tmp = result.TAG === "Ok" ? undefined : result._0;
    var attempt$1 = {
      attemptNumber: attemptNumber,
      timestamp: attemptStart,
      error: tmp,
      delayMs: delayMs
    };
    attempts.push(attempt$1);
    if (result.TAG === "Ok" || !(attemptNumber < config.maxAttempts && shouldRetryFn(result._0))) {
      return result;
    } else {
      if (delayMs > 0) {
        await sleep(delayMs);
      }
      return await executeAttempt(attemptNumber + 1 | 0);
    }
  };
  var result = await executeAttempt(1);
  var endTime = Date.now();
  return {
          result: result,
          attempts: attempts,
          totalDuration: endTime - startTime,
          usedFallback: false
        };
}

async function retryWithFallback(fn, config, fallback) {
  var execution = await retry(fn, config);
  var match = execution.result;
  if (match.TAG === "Ok") {
    return execution;
  }
  var fallbackResult;
  fallbackResult = fallback.TAG === "AlternativeFunction" ? fallback._0() : Promise.resolve({
          TAG: "Ok",
          _0: fallback._0
        });
  var finalResult = await fallbackResult;
  return {
          result: finalResult,
          attempts: execution.attempts,
          totalDuration: execution.totalDuration,
          usedFallback: true
        };
}

async function retryWithCircuitBreaker(fn, config, circuitBreaker) {
  var match = shouldAttempt(circuitBreaker);
  var updatedCb = match[1];
  if (match[0]) {
    var execution = await retry(fn, config);
    var match$1 = execution.result;
    var finalCb;
    finalCb = match$1.TAG === "Ok" ? recordSuccess(updatedCb) : recordFailure(updatedCb);
    return [
            execution,
            finalCb
          ];
  }
  var execution_result = {
    TAG: "Error",
    _0: "Circuit breaker is open"
  };
  var execution_attempts = [];
  var execution$1 = {
    result: execution_result,
    attempts: execution_attempts,
    totalDuration: 0.0,
    usedFallback: false
  };
  return [
          execution$1,
          updatedCb
        ];
}

async function retryBatch(fns, config) {
  var promises = Belt_Array.map(fns, (function (fn) {
          return retry(fn, config);
        }));
  return await Promise.all(promises);
}

function wasSuccessful(execution) {
  var match = execution.result;
  if (match.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function getAttemptCount(execution) {
  return execution.attempts.length;
}

function getTotalRetries(execution) {
  var count = execution.attempts.length;
  if (count > 0) {
    return count - 1 | 0;
  } else {
    return 0;
  }
}

function getAverageDelay(execution) {
  var attempts = execution.attempts;
  if (attempts.length === 0) {
    return 0.0;
  }
  var totalDelay = Belt_Array.reduce(attempts, 0, (function (acc, attempt) {
          return acc + attempt.delayMs | 0;
        }));
  return totalDelay / attempts.length;
}

function getLastError(execution) {
  var e = execution.result;
  if (e.TAG === "Ok") {
    return ;
  } else {
    return e._0;
  }
}

function classifyError(error) {
  var lowerError = error.toLowerCase();
  if (lowerError.includes("rate limit") || lowerError.includes("too many requests") || lowerError.includes("429")) {
    return "RateLimited";
  } else if (lowerError.includes("timeout") || lowerError.includes("timed out") || lowerError.includes("deadline")) {
    return "Timeout";
  } else if (lowerError.includes("network") || lowerError.includes("connection") || lowerError.includes("unavailable") || lowerError.includes("503") || lowerError.includes("502") || !(lowerError.includes("unauthorized") || lowerError.includes("forbidden") || lowerError.includes("401") || lowerError.includes("403") || lowerError.includes("invalid") || lowerError.includes("not found") || lowerError.includes("404"))) {
    return "Retryable";
  } else {
    return "NonRetryable";
  }
}

function isRetryable(error) {
  var match = classifyError(error);
  if (match === "NonRetryable") {
    return false;
  } else {
    return true;
  }
}

function fixedDelay(delayMs) {
  return {
          TAG: "FixedDelay",
          delayMs: delayMs
        };
}

function exponentialBackoff(initialDelayMsOpt, maxDelayMsOpt, multiplierOpt, param) {
  var initialDelayMs = initialDelayMsOpt !== undefined ? initialDelayMsOpt : 100;
  var maxDelayMs = maxDelayMsOpt !== undefined ? maxDelayMsOpt : 30000;
  var multiplier = multiplierOpt !== undefined ? multiplierOpt : 2.0;
  return {
          TAG: "ExponentialBackoff",
          initialDelayMs: initialDelayMs,
          maxDelayMs: maxDelayMs,
          multiplier: multiplier
        };
}

function linearBackoff(initialDelayMsOpt, incrementMsOpt, param) {
  var initialDelayMs = initialDelayMsOpt !== undefined ? initialDelayMsOpt : 100;
  var incrementMs = incrementMsOpt !== undefined ? incrementMsOpt : 100;
  return {
          TAG: "LinearBackoff",
          initialDelayMs: initialDelayMs,
          incrementMs: incrementMs
        };
}

function randomJitter(baseDelayMsOpt, maxJitterMsOpt, param) {
  var baseDelayMs = baseDelayMsOpt !== undefined ? baseDelayMsOpt : 100;
  var maxJitterMs = maxJitterMsOpt !== undefined ? maxJitterMsOpt : 1000;
  return {
          TAG: "RandomJitter",
          baseDelayMs: baseDelayMs,
          maxJitterMs: maxJitterMs
        };
}

export {
  getCurrentTime ,
  generateId ,
  calculateDelay ,
  sleep ,
  defaultShouldRetry ,
  createCircuitBreakerConfig ,
  createCircuitBreaker ,
  recordSuccess ,
  recordFailure ,
  shouldAttempt ,
  getCircuitState ,
  resetCircuitBreaker ,
  createRetryConfig ,
  retry ,
  retryWithFallback ,
  retryWithCircuitBreaker ,
  retryBatch ,
  wasSuccessful ,
  getAttemptCount ,
  getTotalRetries ,
  getAverageDelay ,
  getLastError ,
  classifyError ,
  isRetryable ,
  fixedDelay ,
  exponentialBackoff ,
  linearBackoff ,
  randomJitter ,
}
/* No side effect */
