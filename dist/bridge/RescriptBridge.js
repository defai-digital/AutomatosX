/**
 * ReScript-TypeScript Bridge
 *
 * Provides TypeScript-friendly utilities for working with ReScript types
 * generated by GenType, including Result, Option, and other common patterns.
 */
/**
 * Type guard for Result.Ok
 */
export function isOk(result) {
    return result.TAG === 'Ok';
}
/**
 * Type guard for Result.Error
 */
export function isError(result) {
    return result.TAG === 'Error';
}
// ============================================================================
// RESULT UTILITIES
// ============================================================================
/**
 * Unwrap a Result, throwing if it's an Error
 */
export function unwrap(result) {
    if (isOk(result)) {
        return result._0;
    }
    throw new Error(`Unwrap failed: ${String(result._0)}`);
}
/**
 * Unwrap a Result with a default value
 */
export function unwrapOr(result, defaultValue) {
    return isOk(result) ? result._0 : defaultValue;
}
/**
 * Get the Ok value or undefined
 */
export function getOk(result) {
    return isOk(result) ? result._0 : undefined;
}
/**
 * Get the Error value or undefined
 */
export function getError(result) {
    return isError(result) ? result._0 : undefined;
}
/**
 * Map over a Result's Ok value
 */
export function mapResult(result, fn) {
    if (isOk(result)) {
        return { TAG: 'Ok', _0: fn(result._0) };
    }
    return result;
}
/**
 * Map over a Result's Error value
 */
export function mapError(result, fn) {
    if (isError(result)) {
        return { TAG: 'Error', _0: fn(result._0) };
    }
    return result;
}
/**
 * Chain Result operations (flatMap)
 */
export function andThen(result, fn) {
    if (isOk(result)) {
        return fn(result._0);
    }
    return result;
}
/**
 * Provide an alternative Result if the first is Error
 */
export function orElse(result, fn) {
    if (isError(result)) {
        return fn(result._0);
    }
    return result;
}
/**
 * Match on a Result and return a value
 */
export function match(result, handlers) {
    return isOk(result) ? handlers.ok(result._0) : handlers.error(result._0);
}
/**
 * Convert a Result to a Promise
 */
export function toPromise(result) {
    if (isOk(result)) {
        return Promise.resolve(result._0);
    }
    return Promise.reject(result._0);
}
/**
 * Convert a Promise to a Result
 */
export async function fromPromise(promise) {
    try {
        const value = await promise;
        return { TAG: 'Ok', _0: value };
    }
    catch (error) {
        return { TAG: 'Error', _0: error instanceof Error ? error : new Error(String(error)) };
    }
}
/**
 * Create an Ok Result
 */
export function ok(value) {
    return { TAG: 'Ok', _0: value };
}
/**
 * Create an Error Result
 */
export function error(err) {
    return { TAG: 'Error', _0: err };
}
// ============================================================================
// OPTION UTILITIES
// ============================================================================
/**
 * Check if an Option has a value
 */
export function isSome(option) {
    return option !== undefined;
}
/**
 * Check if an Option is None
 */
export function isNone(option) {
    return option === undefined;
}
/**
 * Unwrap an Option, throwing if None
 */
export function unwrapOption(option) {
    if (isSome(option)) {
        return option;
    }
    throw new Error('Unwrap failed: Option is None');
}
/**
 * Unwrap an Option with a default value
 */
export function unwrapOptionOr(option, defaultValue) {
    return isSome(option) ? option : defaultValue;
}
/**
 * Map over an Option's value
 */
export function mapOption(option, fn) {
    return isSome(option) ? fn(option) : undefined;
}
/**
 * Chain Option operations (flatMap)
 */
export function andThenOption(option, fn) {
    return isSome(option) ? fn(option) : undefined;
}
/**
 * Provide an alternative Option if the first is None
 */
export function orElseOption(option, alternative) {
    return isSome(option) ? option : alternative();
}
/**
 * Match on an Option and return a value
 */
export function matchOption(option, handlers) {
    return isSome(option) ? handlers.some(option) : handlers.none();
}
/**
 * Convert an Option to a Result
 */
export function optionToResult(option, error) {
    return isSome(option) ? ok(option) : { TAG: 'Error', _0: error };
}
/**
 * Convert a Result to an Option (discards error)
 */
export function resultToOption(result) {
    return isOk(result) ? result._0 : undefined;
}
/**
 * Create Some Option
 */
export function some(value) {
    return value;
}
/**
 * Create None Option
 */
export function none() {
    return undefined;
}
// ============================================================================
// ARRAY UTILITIES
// ============================================================================
/**
 * Collect all Ok values from an array of Results
 */
export function collectOk(results) {
    return results.filter(isOk).map(r => r._0);
}
/**
 * Collect all Error values from an array of Results
 */
export function collectErrors(results) {
    return results.filter(isError).map(r => r._0);
}
/**
 * Convert an array of Results to a Result of array
 * Returns Error if any Result is Error, Ok with array otherwise
 */
export function sequenceResults(results) {
    const values = [];
    for (const result of results) {
        if (isError(result)) {
            return result;
        }
        values.push(result._0);
    }
    return ok(values);
}
/**
 * Collect all Some values from an array of Options
 */
export function collectSome(options) {
    return options.filter(isSome);
}
/**
 * Find the first Ok Result in an array
 */
export function findOk(results) {
    const okResult = results.find(isOk);
    return okResult ? okResult._0 : undefined;
}
/**
 * Find the first Some Option in an array
 */
export function findSome(options) {
    return options.find(isSome);
}
// ============================================================================
// VALIDATION UTILITIES
// ============================================================================
/**
 * Validate a value with a predicate
 */
export function validate(value, predicate, error) {
    return predicate(value) ? ok(value) : { TAG: 'Error', _0: error };
}
/**
 * Validate multiple conditions
 */
export function validateAll(value, validators) {
    const errors = validators
        .filter(v => !v.predicate(value))
        .map(v => v.error);
    return errors.length === 0 ? ok(value) : { TAG: 'Error', _0: errors };
}
// ============================================================================
// ASYNC UTILITIES
// ============================================================================
/**
 * Map over an async Result's Ok value
 */
export async function mapResultAsync(resultPromise, fn) {
    const result = await resultPromise;
    if (isOk(result)) {
        const mapped = await fn(result._0);
        return ok(mapped);
    }
    return result;
}
/**
 * Chain async Result operations
 */
export async function andThenAsync(resultPromise, fn) {
    const result = await resultPromise;
    if (isOk(result)) {
        return await fn(result._0);
    }
    return result;
}
/**
 * Run multiple async operations and collect Results
 */
export async function allResults(promises) {
    const results = await Promise.all(promises);
    return sequenceResults(results);
}
/**
 * Retry an async operation that returns a Result
 */
export async function retry(fn, options) {
    let lastResult = { TAG: 'Error', _0: 'No attempts made' };
    for (let attempt = 1; attempt <= options.maxAttempts; attempt++) {
        lastResult = await fn();
        if (isOk(lastResult)) {
            return lastResult;
        }
        if (attempt < options.maxAttempts) {
            if (options.onRetry) {
                options.onRetry(attempt, lastResult._0);
            }
            if (options.delayMs) {
                await new Promise(resolve => setTimeout(resolve, options.delayMs));
            }
        }
    }
    return lastResult;
}
//# sourceMappingURL=RescriptBridge.js.map