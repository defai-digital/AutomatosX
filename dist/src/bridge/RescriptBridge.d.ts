/**
 * ReScript-TypeScript Bridge
 *
 * Provides TypeScript-friendly utilities for working with ReScript types
 * generated by GenType, including Result, Option, and other common patterns.
 */
/**
 * ReScript Result type (generated by GenType)
 */
export type Result<T, E> = {
    TAG: 'Ok';
    _0: T;
} | {
    TAG: 'Error';
    _0: E;
};
/**
 * ReScript Option type representation
 */
export type Option<T> = T | undefined;
/**
 * Type guard for Result.Ok
 */
export declare function isOk<T, E>(result: Result<T, E>): result is {
    TAG: 'Ok';
    _0: T;
};
/**
 * Type guard for Result.Error
 */
export declare function isError<T, E>(result: Result<T, E>): result is {
    TAG: 'Error';
    _0: E;
};
/**
 * Unwrap a Result, throwing if it's an Error
 */
export declare function unwrap<T, E>(result: Result<T, E>): T;
/**
 * Unwrap a Result with a default value
 */
export declare function unwrapOr<T, E>(result: Result<T, E>, defaultValue: T): T;
/**
 * Get the Ok value or undefined
 */
export declare function getOk<T, E>(result: Result<T, E>): T | undefined;
/**
 * Get the Error value or undefined
 */
export declare function getError<T, E>(result: Result<T, E>): E | undefined;
/**
 * Map over a Result's Ok value
 */
export declare function mapResult<T, U, E>(result: Result<T, E>, fn: (value: T) => U): Result<U, E>;
/**
 * Map over a Result's Error value
 */
export declare function mapError<T, E, F>(result: Result<T, E>, fn: (error: E) => F): Result<T, F>;
/**
 * Chain Result operations (flatMap)
 */
export declare function andThen<T, U, E>(result: Result<T, E>, fn: (value: T) => Result<U, E>): Result<U, E>;
/**
 * Provide an alternative Result if the first is Error
 */
export declare function orElse<T, E, F>(result: Result<T, E>, fn: (error: E) => Result<T, F>): Result<T, F>;
/**
 * Match on a Result and return a value
 */
export declare function match<T, E, U>(result: Result<T, E>, handlers: {
    ok: (value: T) => U;
    error: (error: E) => U;
}): U;
/**
 * Convert a Result to a Promise
 */
export declare function toPromise<T, E>(result: Result<T, E>): Promise<T>;
/**
 * Convert a Promise to a Result
 */
export declare function fromPromise<T>(promise: Promise<T>): Promise<Result<T, Error>>;
/**
 * Create an Ok Result
 */
export declare function ok<T, E = never>(value: T): Result<T, E>;
/**
 * Create an Error Result
 */
export declare function error<T = never, E = unknown>(err: E): Result<T, E>;
/**
 * Check if an Option has a value
 */
export declare function isSome<T>(option: Option<T>): option is T;
/**
 * Check if an Option is None
 */
export declare function isNone<T>(option: Option<T>): option is undefined;
/**
 * Unwrap an Option, throwing if None
 */
export declare function unwrapOption<T>(option: Option<T>): T;
/**
 * Unwrap an Option with a default value
 */
export declare function unwrapOptionOr<T>(option: Option<T>, defaultValue: T): T;
/**
 * Map over an Option's value
 */
export declare function mapOption<T, U>(option: Option<T>, fn: (value: T) => U): Option<U>;
/**
 * Chain Option operations (flatMap)
 */
export declare function andThenOption<T, U>(option: Option<T>, fn: (value: T) => Option<U>): Option<U>;
/**
 * Provide an alternative Option if the first is None
 */
export declare function orElseOption<T>(option: Option<T>, alternative: () => Option<T>): Option<T>;
/**
 * Match on an Option and return a value
 */
export declare function matchOption<T, U>(option: Option<T>, handlers: {
    some: (value: T) => U;
    none: () => U;
}): U;
/**
 * Convert an Option to a Result
 */
export declare function optionToResult<T, E>(option: Option<T>, error: E): Result<T, E>;
/**
 * Convert a Result to an Option (discards error)
 */
export declare function resultToOption<T, E>(result: Result<T, E>): Option<T>;
/**
 * Create Some Option
 */
export declare function some<T>(value: T): Option<T>;
/**
 * Create None Option
 */
export declare function none<T>(): Option<T>;
/**
 * Collect all Ok values from an array of Results
 */
export declare function collectOk<T, E>(results: Array<Result<T, E>>): T[];
/**
 * Collect all Error values from an array of Results
 */
export declare function collectErrors<T, E>(results: Array<Result<T, E>>): E[];
/**
 * Convert an array of Results to a Result of array
 * Returns Error if any Result is Error, Ok with array otherwise
 */
export declare function sequenceResults<T, E>(results: Array<Result<T, E>>): Result<T[], E>;
/**
 * Collect all Some values from an array of Options
 */
export declare function collectSome<T>(options: Array<Option<T>>): T[];
/**
 * Find the first Ok Result in an array
 */
export declare function findOk<T, E>(results: Array<Result<T, E>>): Option<T>;
/**
 * Find the first Some Option in an array
 */
export declare function findSome<T>(options: Array<Option<T>>): Option<T>;
/**
 * Validate a value with a predicate
 */
export declare function validate<T>(value: T, predicate: (value: T) => boolean, error: string): Result<T, string>;
/**
 * Validate multiple conditions
 */
export declare function validateAll<T>(value: T, validators: Array<{
    predicate: (value: T) => boolean;
    error: string;
}>): Result<T, string[]>;
/**
 * Map over an async Result's Ok value
 */
export declare function mapResultAsync<T, U, E>(resultPromise: Promise<Result<T, E>>, fn: (value: T) => U | Promise<U>): Promise<Result<U, E>>;
/**
 * Chain async Result operations
 */
export declare function andThenAsync<T, U, E>(resultPromise: Promise<Result<T, E>>, fn: (value: T) => Promise<Result<U, E>>): Promise<Result<U, E>>;
/**
 * Run multiple async operations and collect Results
 */
export declare function allResults<T, E>(promises: Array<Promise<Result<T, E>>>): Promise<Result<T[], E>>;
/**
 * Retry an async operation that returns a Result
 */
export declare function retry<T, E>(fn: () => Promise<Result<T, E>>, options: {
    maxAttempts: number;
    delayMs?: number;
    onRetry?: (attempt: number, error: E) => void;
}): Promise<Result<T, E>>;
/**
 * Extract the Ok type from a Result
 */
export type OkType<T> = T extends Result<infer U, any> ? U : never;
/**
 * Extract the Error type from a Result
 */
export type ErrorType<T> = T extends Result<any, infer E> ? E : never;
/**
 * Extract the value type from an Option
 */
export type SomeType<T> = T extends Option<infer U> ? U : never;
//# sourceMappingURL=RescriptBridge.d.ts.map