// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function toString(state) {
  switch (state) {
    case "Idle" :
        return "idle";
    case "Validating" :
        return "validating";
    case "Requesting" :
        return "requesting";
    case "Streaming" :
        return "streaming";
    case "RateLimited" :
        return "rate_limited";
    case "Retrying" :
        return "retrying";
    case "Completed" :
        return "completed";
    case "Failed" :
        return "failed";
    
  }
}

function fromString(str) {
  switch (str) {
    case "completed" :
        return "Completed";
    case "failed" :
        return "Failed";
    case "idle" :
        return "Idle";
    case "rate_limited" :
        return "RateLimited";
    case "requesting" :
        return "Requesting";
    case "retrying" :
        return "Retrying";
    case "streaming" :
        return "Streaming";
    case "validating" :
        return "Validating";
    default:
      return ;
  }
}

function isTerminal(state) {
  switch (state) {
    case "Completed" :
    case "Failed" :
        return true;
    default:
      return false;
  }
}

function canTransitionTo(from, to) {
  switch (from) {
    case "Idle" :
        if (to === "Validating") {
          return true;
        } else {
          return false;
        }
    case "Validating" :
        switch (to) {
          case "Requesting" :
          case "Failed" :
              return true;
          default:
            return false;
        }
    case "Requesting" :
        switch (to) {
          case "Streaming" :
          case "RateLimited" :
          case "Completed" :
          case "Failed" :
              return true;
          default:
            return false;
        }
    case "Streaming" :
        switch (to) {
          case "Completed" :
          case "Failed" :
              return true;
          default:
            return false;
        }
    case "RateLimited" :
        switch (to) {
          case "Retrying" :
          case "Failed" :
              return true;
          default:
            return false;
        }
    case "Retrying" :
        switch (to) {
          case "Requesting" :
          case "Failed" :
              return true;
          default:
            return false;
        }
    case "Completed" :
        if (to === "Idle") {
          return true;
        } else {
          return false;
        }
    case "Failed" :
        if (to === "Idle") {
          return true;
        } else {
          return false;
        }
    
  }
}

var State = {
  toString: toString,
  fromString: fromString,
  isTerminal: isTerminal,
  canTransitionTo: canTransitionTo
};

function toString$1($$event) {
  if (typeof $$event !== "object") {
    switch ($$event) {
      case "ValidateRequest" :
          return "validate_request";
      case "ValidationPassed" :
          return "validation_passed";
      case "SendRequest" :
          return "send_request";
      case "StreamComplete" :
          return "stream_complete";
      case "Complete" :
          return "complete";
      case "Reset" :
          return "reset";
      
    }
  } else {
    switch ($$event.TAG) {
      case "InitiateRequest" :
          return "initiate_request";
      case "ValidationFailed" :
          return "validation_failed";
      case "ReceiveResponse" :
          return "receive_response";
      case "ReceiveStreamChunk" :
          return "receive_stream_chunk";
      case "RateLimitHit" :
          return "rate_limit_hit";
      case "RetryRequest" :
          return "retry_request";
      case "RequestFailed" :
          return "request_failed";
      case "FallbackToProvider" :
          return "fallback_to_provider";
      
    }
  }
}

function isSystemEvent($$event) {
  if (typeof $$event === "object") {
    return false;
  }
  switch ($$event) {
    case "ValidateRequest" :
    case "SendRequest" :
    case "Complete" :
    case "Reset" :
        return true;
    default:
      return false;
  }
}

function isUserEvent($$event) {
  if (typeof $$event !== "object" || $$event.TAG !== "InitiateRequest") {
    return false;
  } else {
    return true;
  }
}

function isProviderEvent($$event) {
  if (typeof $$event !== "object") {
    if ($$event === "StreamComplete") {
      return true;
    } else {
      return false;
    }
  }
  switch ($$event.TAG) {
    case "ReceiveResponse" :
    case "ReceiveStreamChunk" :
    case "RateLimitHit" :
    case "RequestFailed" :
        return true;
    default:
      return false;
  }
}

var $$Event = {
  toString: toString$1,
  isSystemEvent: isSystemEvent,
  isUserEvent: isUserEvent,
  isProviderEvent: isProviderEvent
};

function create(provider, model, requestId, conversationId, userId, maxAttemptsOpt, param) {
  var maxAttempts = maxAttemptsOpt !== undefined ? maxAttemptsOpt : 3;
  return {
          state: "Idle",
          providerInfo: {
            provider: provider,
            model: model,
            fallbackProvider: undefined
          },
          metrics: {
            startTime: Date.now(),
            endTime: undefined,
            firstTokenLatency: undefined,
            totalDuration: undefined,
            tokenCount: {
              input: 0,
              output: 0,
              total: 0
            }
          },
          retryState: {
            currentAttempt: 0,
            maxAttempts: maxAttempts,
            lastError: undefined
          },
          streamState: {
            chunksReceived: 0,
            totalChunks: undefined,
            streamStartTime: undefined
          },
          metadata: {
            requestId: requestId,
            conversationId: conversationId,
            userId: userId,
            tags: []
          },
          lastEvent: undefined,
          history: ["Idle"]
        };
}

function getCurrentState(ctx) {
  return ctx.state;
}

function getProviderInfo(ctx) {
  return ctx.providerInfo;
}

function getMetrics(ctx) {
  return ctx.metrics;
}

function getRetryState(ctx) {
  return ctx.retryState;
}

function getStreamState(ctx) {
  return ctx.streamState;
}

function getMetadata(ctx) {
  return ctx.metadata;
}

function isRetryable(ctx) {
  return ctx.retryState.currentAttempt < ctx.retryState.maxAttempts;
}

function shouldFallback(ctx) {
  if (isRetryable(ctx)) {
    return false;
  } else {
    return Belt_Option.isSome(ctx.providerInfo.fallbackProvider);
  }
}

function getDuration(ctx) {
  var endTime = ctx.metrics.endTime;
  if (endTime !== undefined) {
    return endTime - ctx.metrics.startTime;
  }
  
}

function addTag(ctx, tag) {
  var init = ctx.metadata;
  return {
          state: ctx.state,
          providerInfo: ctx.providerInfo,
          metrics: ctx.metrics,
          retryState: ctx.retryState,
          streamState: ctx.streamState,
          metadata: {
            requestId: init.requestId,
            conversationId: init.conversationId,
            userId: init.userId,
            tags: Belt_Array.concat(ctx.metadata.tags, [tag])
          },
          lastEvent: ctx.lastEvent,
          history: ctx.history
        };
}

function setFallbackProvider(ctx, fallbackProvider) {
  var init = ctx.providerInfo;
  return {
          state: ctx.state,
          providerInfo: {
            provider: init.provider,
            model: init.model,
            fallbackProvider: fallbackProvider
          },
          metrics: ctx.metrics,
          retryState: ctx.retryState,
          streamState: ctx.streamState,
          metadata: ctx.metadata,
          lastEvent: ctx.lastEvent,
          history: ctx.history
        };
}

function updateMetrics(ctx, firstTokenLatency, tokenCount, param) {
  var init = ctx.metrics;
  var updatedMetrics_startTime = init.startTime;
  var updatedMetrics_endTime = init.endTime;
  var updatedMetrics_firstTokenLatency = firstTokenLatency !== undefined ? firstTokenLatency : ctx.metrics.firstTokenLatency;
  var updatedMetrics_totalDuration = init.totalDuration;
  var updatedMetrics_tokenCount = tokenCount !== undefined ? Caml_option.valFromOption(tokenCount) : ctx.metrics.tokenCount;
  var updatedMetrics = {
    startTime: updatedMetrics_startTime,
    endTime: updatedMetrics_endTime,
    firstTokenLatency: updatedMetrics_firstTokenLatency,
    totalDuration: updatedMetrics_totalDuration,
    tokenCount: updatedMetrics_tokenCount
  };
  return {
          state: ctx.state,
          providerInfo: ctx.providerInfo,
          metrics: updatedMetrics,
          retryState: ctx.retryState,
          streamState: ctx.streamState,
          metadata: ctx.metadata,
          lastEvent: ctx.lastEvent,
          history: ctx.history
        };
}

function recordStreamChunk(ctx) {
  var now = Date.now();
  var time = ctx.streamState.streamStartTime;
  var streamStartTime = time !== undefined ? time : now;
  var init = ctx.metrics;
  var latency = ctx.metrics.firstTokenLatency;
  var init$1 = ctx.streamState;
  return {
          state: ctx.state,
          providerInfo: ctx.providerInfo,
          metrics: {
            startTime: init.startTime,
            endTime: init.endTime,
            firstTokenLatency: latency !== undefined ? latency : now - ctx.metrics.startTime,
            totalDuration: init.totalDuration,
            tokenCount: init.tokenCount
          },
          retryState: ctx.retryState,
          streamState: {
            chunksReceived: ctx.streamState.chunksReceived + 1 | 0,
            totalChunks: init$1.totalChunks,
            streamStartTime: streamStartTime
          },
          metadata: ctx.metadata,
          lastEvent: ctx.lastEvent,
          history: ctx.history
        };
}

function incrementRetry(ctx, error) {
  var init = ctx.retryState;
  return {
          state: ctx.state,
          providerInfo: ctx.providerInfo,
          metrics: ctx.metrics,
          retryState: {
            currentAttempt: ctx.retryState.currentAttempt + 1 | 0,
            maxAttempts: init.maxAttempts,
            lastError: error
          },
          streamState: ctx.streamState,
          metadata: ctx.metadata,
          lastEvent: ctx.lastEvent,
          history: ctx.history
        };
}

function completeRequest(ctx) {
  var now = Date.now();
  var init = ctx.metrics;
  return {
          state: ctx.state,
          providerInfo: ctx.providerInfo,
          metrics: {
            startTime: init.startTime,
            endTime: now,
            firstTokenLatency: init.firstTokenLatency,
            totalDuration: now - ctx.metrics.startTime,
            tokenCount: init.tokenCount
          },
          retryState: ctx.retryState,
          streamState: ctx.streamState,
          metadata: ctx.metadata,
          lastEvent: ctx.lastEvent,
          history: ctx.history
        };
}

var Context = {
  create: create,
  getCurrentState: getCurrentState,
  getProviderInfo: getProviderInfo,
  getMetrics: getMetrics,
  getRetryState: getRetryState,
  getStreamState: getStreamState,
  getMetadata: getMetadata,
  isRetryable: isRetryable,
  shouldFallback: shouldFallback,
  getDuration: getDuration,
  addTag: addTag,
  setFallbackProvider: setFallbackProvider,
  updateMetrics: updateMetrics,
  recordStreamChunk: recordStreamChunk,
  incrementRetry: incrementRetry,
  completeRequest: completeRequest
};

function applyEvent(ctx, $$event) {
  var currentState = ctx.state;
  var targetState;
  var exit = 0;
  switch (currentState) {
    case "Idle" :
        if (typeof $$event !== "object") {
          if ($$event === "Complete") {
            exit = 1;
          } else {
            targetState = undefined;
          }
        } else {
          targetState = $$event.TAG === "InitiateRequest" ? "Validating" : undefined;
        }
        break;
    case "Validating" :
        if (typeof $$event !== "object") {
          switch ($$event) {
            case "ValidateRequest" :
                targetState = "Validating";
                break;
            case "ValidationPassed" :
                targetState = "Requesting";
                break;
            case "Complete" :
                exit = 1;
                break;
            default:
              targetState = undefined;
          }
        } else {
          targetState = $$event.TAG === "ValidationFailed" ? "Failed" : undefined;
        }
        break;
    case "Requesting" :
        if (typeof $$event !== "object") {
          switch ($$event) {
            case "SendRequest" :
                targetState = "Requesting";
                break;
            case "Complete" :
                exit = 1;
                break;
            default:
              targetState = undefined;
          }
        } else {
          switch ($$event.TAG) {
            case "ReceiveResponse" :
                targetState = "Completed";
                break;
            case "ReceiveStreamChunk" :
                targetState = "Streaming";
                break;
            case "RateLimitHit" :
                targetState = "RateLimited";
                break;
            case "RequestFailed" :
                targetState = "Failed";
                break;
            default:
              targetState = undefined;
          }
        }
        break;
    case "Streaming" :
        if (typeof $$event !== "object") {
          switch ($$event) {
            case "StreamComplete" :
                targetState = "Completed";
                break;
            case "Complete" :
                exit = 1;
                break;
            default:
              targetState = undefined;
          }
        } else {
          switch ($$event.TAG) {
            case "ReceiveStreamChunk" :
                targetState = "Streaming";
                break;
            case "RequestFailed" :
                targetState = "Failed";
                break;
            default:
              targetState = undefined;
          }
        }
        break;
    case "RateLimited" :
        if (typeof $$event !== "object") {
          if ($$event === "Complete") {
            exit = 1;
          } else {
            targetState = undefined;
          }
        } else {
          switch ($$event.TAG) {
            case "RetryRequest" :
                targetState = "Retrying";
                break;
            case "RequestFailed" :
                targetState = "Failed";
                break;
            default:
              targetState = undefined;
          }
        }
        break;
    case "Retrying" :
        if (typeof $$event !== "object") {
          switch ($$event) {
            case "SendRequest" :
                targetState = "Requesting";
                break;
            case "Complete" :
                exit = 1;
                break;
            default:
              targetState = undefined;
          }
        } else {
          targetState = $$event.TAG === "RequestFailed" ? "Failed" : undefined;
        }
        break;
    case "Completed" :
        if (typeof $$event !== "object") {
          switch ($$event) {
            case "Complete" :
                exit = 1;
                break;
            case "Reset" :
                targetState = "Idle";
                break;
            default:
              targetState = undefined;
          }
        } else {
          targetState = undefined;
        }
        break;
    case "Failed" :
        if (typeof $$event !== "object") {
          switch ($$event) {
            case "Complete" :
                exit = 1;
                break;
            case "Reset" :
                targetState = "Idle";
                break;
            default:
              targetState = undefined;
          }
        } else {
          targetState = $$event.TAG === "FallbackToProvider" ? "Validating" : undefined;
        }
        break;
    
  }
  if (exit === 1) {
    targetState = isTerminal(currentState) ? currentState : undefined;
  }
  if (targetState === undefined) {
    return {
            TAG: "InvalidState",
            state: currentState,
            event: $$event
          };
  }
  if (!canTransitionTo(currentState, targetState)) {
    return {
            TAG: "InvalidTransition",
            from: currentState,
            to: targetState,
            event: $$event
          };
  }
  var updatedCtx_providerInfo = ctx.providerInfo;
  var updatedCtx_metrics = ctx.metrics;
  var updatedCtx_retryState = ctx.retryState;
  var updatedCtx_streamState = ctx.streamState;
  var updatedCtx_metadata = ctx.metadata;
  var updatedCtx_lastEvent = $$event;
  var updatedCtx_history = Belt_Array.concat(ctx.history, [targetState]);
  var updatedCtx = {
    state: targetState,
    providerInfo: updatedCtx_providerInfo,
    metrics: updatedCtx_metrics,
    retryState: updatedCtx_retryState,
    streamState: updatedCtx_streamState,
    metadata: updatedCtx_metadata,
    lastEvent: updatedCtx_lastEvent,
    history: updatedCtx_history
  };
  var finalCtx;
  if (typeof $$event !== "object") {
    finalCtx = $$event === "StreamComplete" ? completeRequest(updatedCtx) : updatedCtx;
  } else {
    switch ($$event.TAG) {
      case "ValidationFailed" :
          finalCtx = addTag(updatedCtx, "validation_failed");
          break;
      case "ReceiveResponse" :
          var withMetrics = updateMetrics(updatedCtx, undefined, Caml_option.some($$event._0.tokens), undefined);
          finalCtx = completeRequest(withMetrics);
          break;
      case "ReceiveStreamChunk" :
          finalCtx = recordStreamChunk(updatedCtx);
          break;
      case "RateLimitHit" :
          finalCtx = addTag(updatedCtx, "rate_limited");
          break;
      case "RetryRequest" :
          var error = ctx.retryState.lastError;
          finalCtx = error !== undefined ? incrementRetry(updatedCtx, error) : incrementRetry(updatedCtx, "unknown_error");
          break;
      case "RequestFailed" :
          var withRetry = incrementRetry(updatedCtx, $$event._0.error);
          finalCtx = addTag(withRetry, "failed");
          break;
      case "FallbackToProvider" :
          var withFallback = setFallbackProvider(updatedCtx, $$event._0.provider);
          finalCtx = addTag(withFallback, "fallback");
          break;
      default:
        finalCtx = updatedCtx;
    }
  }
  return {
          TAG: "Success",
          _0: finalCtx
        };
}

function transition(ctx, $$event) {
  return applyEvent(ctx, $$event);
}

function transitionBatch(ctx, events) {
  var _currentCtx = ctx;
  var _remainingEvents = events;
  while(true) {
    var remainingEvents = _remainingEvents;
    var currentCtx = _currentCtx;
    var $$event = Belt_Array.get(remainingEvents, 0);
    if ($$event === undefined) {
      return {
              TAG: "Ok",
              _0: currentCtx
            };
    }
    var newCtx = applyEvent(currentCtx, $$event);
    switch (newCtx.TAG) {
      case "Success" :
          _remainingEvents = Belt_Array.sliceToEnd(remainingEvents, 1);
          _currentCtx = newCtx._0;
          continue ;
      case "InvalidTransition" :
      case "InvalidState" :
          return {
                  TAG: "Error",
                  _0: newCtx
                };
      
    }
  };
}

function canApplyEvent(ctx, $$event) {
  var match = applyEvent(ctx, $$event);
  switch (match.TAG) {
    case "Success" :
        return true;
    case "InvalidTransition" :
    case "InvalidState" :
        return false;
    
  }
}

function resultToString(result) {
  switch (result.TAG) {
    case "Success" :
        return "Success: transitioned to " + toString(result._0.state);
    case "InvalidTransition" :
        return "InvalidTransition: cannot transition from " + toString(result.from) + " to " + toString(result.to) + " on event " + toString$1(result.event);
    case "InvalidState" :
        return "InvalidState: event " + toString$1(result.event) + " is invalid for state " + toString(result.state);
    
  }
}

var Transition = {
  applyEvent: applyEvent,
  transition: transition,
  transitionBatch: transitionBatch,
  canApplyEvent: canApplyEvent,
  resultToString: resultToString
};

export {
  State ,
  $$Event ,
  Context ,
  Transition ,
}
/* No side effect */
