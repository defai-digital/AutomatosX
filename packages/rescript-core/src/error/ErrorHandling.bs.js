// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_array from "rescript/lib/es6/js_array.js";
import * as Caml_array from "rescript/lib/es6/caml_array.js";
import * as Js_promise from "rescript/lib/es6/js_promise.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";

function isOk(result) {
  if (result.TAG === "Ok") {
    return true;
  } else {
    return false;
  }
}

function isError(result) {
  if (result.TAG === "Ok") {
    return false;
  } else {
    return true;
  }
}

function getOr(result, defaultValue) {
  if (result.TAG === "Ok") {
    return result._0;
  } else {
    return defaultValue;
  }
}

function getOrElse(result, fn) {
  if (result.TAG === "Ok") {
    return result._0;
  } else {
    return fn();
  }
}

function getErrorOr(result, defaultValue) {
  if (result.TAG === "Ok") {
    return defaultValue;
  } else {
    return result._0;
  }
}

function map(result, fn) {
  if (result.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: fn(result._0)
          };
  } else {
    return {
            TAG: "Error",
            _0: result._0
          };
  }
}

function mapError(result, fn) {
  if (result.TAG === "Ok") {
    return {
            TAG: "Ok",
            _0: result._0
          };
  } else {
    return {
            TAG: "Error",
            _0: fn(result._0)
          };
  }
}

function flatMap(result, fn) {
  if (result.TAG === "Ok") {
    return fn(result._0);
  } else {
    return {
            TAG: "Error",
            _0: result._0
          };
  }
}

function apply(resultFn, resultValue) {
  if (resultFn.TAG === "Ok") {
    if (resultValue.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: resultFn._0(resultValue._0)
            };
    } else {
      return {
              TAG: "Error",
              _0: resultValue._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: resultFn._0
          };
  }
}

function fromOption(opt, error) {
  if (opt !== undefined) {
    return {
            TAG: "Ok",
            _0: Caml_option.valFromOption(opt)
          };
  } else {
    return {
            TAG: "Error",
            _0: error
          };
  }
}

function toOption(result) {
  if (result.TAG === "Ok") {
    return Caml_option.some(result._0);
  }
  
}

function recover(result, strategy) {
  if (result.TAG === "Ok") {
    return result;
  }
  if (typeof strategy !== "object") {
    return result;
  }
  switch (strategy.TAG) {
    case "Retry" :
    case "FallbackFn" :
        return result;
    case "Fallback" :
    case "Ignore" :
        return {
                TAG: "Ok",
                _0: strategy._0
              };
    
  }
}

function fromPromise(promise, onError) {
  var __x = (function (__x) {
        return Js_promise.then_((function (value) {
                      return Promise.resolve({
                                  TAG: "Ok",
                                  _0: value
                                });
                    }), __x);
      })(promise);
  return Js_promise.$$catch((function (error) {
                return Promise.resolve({
                            TAG: "Error",
                            _0: onError(error)
                          });
              }), __x);
}

function toPromise(result) {
  if (result.TAG === "Ok") {
    return Promise.resolve(result._0);
  } else {
    return Promise.reject(Js_exn.raiseError("Result is Error"));
  }
}

function combine2(r1, r2) {
  if (r1.TAG === "Ok") {
    if (r2.TAG === "Ok") {
      return {
              TAG: "Ok",
              _0: [
                r1._0,
                r2._0
              ]
            };
    } else {
      return {
              TAG: "Error",
              _0: r2._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: r1._0
          };
  }
}

function combine3(r1, r2, r3) {
  if (r1.TAG === "Ok") {
    if (r2.TAG === "Ok") {
      if (r3.TAG === "Ok") {
        return {
                TAG: "Ok",
                _0: [
                  r1._0,
                  r2._0,
                  r3._0
                ]
              };
      } else {
        return {
                TAG: "Error",
                _0: r3._0
              };
      }
    } else {
      return {
              TAG: "Error",
              _0: r2._0
            };
    }
  } else {
    return {
            TAG: "Error",
            _0: r1._0
          };
  }
}

function combineArray(results) {
  var values = [];
  var error;
  for(var i = 0 ,i_finish = results.length; i < i_finish; ++i){
    var value = Caml_array.get(results, i);
    if (value.TAG === "Ok") {
      if (error === undefined) {
        Js_array.push(value._0, values);
      }
      
    } else if (error === undefined) {
      error = Caml_option.some(value._0);
    }
    
  }
  var err = error;
  if (err !== undefined) {
    return {
            TAG: "Error",
            _0: Caml_option.valFromOption(err)
          };
  } else {
    return {
            TAG: "Ok",
            _0: values
          };
  }
}

function daoErrorToAppError(err) {
  return {
          TAG: "DaoError",
          _0: err
        };
}

function networkErrorToAppError(err) {
  return {
          TAG: "NetworkError",
          _0: err
        };
}

function validationErrorToAppError(err) {
  return {
          TAG: "ValidationError",
          _0: err
        };
}

function daoErrorToString(err) {
  switch (err.TAG) {
    case "NotFound" :
        return err._0 + " not found";
    case "DatabaseError" :
        return "Database error: " + err._0;
    case "ValidationError" :
        return "Validation error: " + err._0;
    case "ConnectionError" :
        return "Connection error: " + err._0;
    case "TimeoutError" :
        return "Operation timed out after " + String(err._0) + "ms";
    case "ConstraintViolation" :
        return "Constraint violation: " + err._0;
    
  }
}

function networkErrorToString(err) {
  if (typeof err !== "object") {
    if (err === "Unauthorized") {
      return "Unauthorized (401)";
    } else {
      return "Forbidden (403)";
    }
  }
  switch (err.TAG) {
    case "RequestFailed" :
        return "Request failed (" + String(err._0) + "): " + err._1;
    case "NetworkTimeout" :
        return "Network timeout after " + String(err._0) + "ms";
    case "InvalidResponse" :
        return "Invalid response: " + err._0;
    case "RateLimited" :
        return "Rate limited, retry after " + String(err._0) + "s";
    
  }
}

function validationErrorToString(err) {
  switch (err.TAG) {
    case "MissingField" :
        return "Missing required field: " + err._0;
    case "InvalidFormat" :
        return "Invalid format for " + err._0 + ": " + err._1;
    case "OutOfRange" :
        return err._0 + " out of range (" + String(err._1) + "-" + String(err._2) + ")";
    case "TooLong" :
        return err._0 + " too long (" + String(err._1) + " > " + String(err._2) + ")";
    case "TooShort" :
        return err._0 + " too short (" + String(err._1) + " < " + String(err._2) + ")";
    
  }
}

function appErrorToString(err) {
  switch (err.TAG) {
    case "DaoError" :
        return daoErrorToString(err._0);
    case "NetworkError" :
        return networkErrorToString(err._0);
    case "ValidationError" :
        return validationErrorToString(err._0);
    case "BusinessLogicError" :
        return "Business logic error: " + err._0;
    case "ConfigurationError" :
        return "Configuration error: " + err._0;
    case "UnknownError" :
        return "Unknown error: " + err._0;
    
  }
}

var chain = flatMap;

export {
  isOk ,
  isError ,
  getOr ,
  getOrElse ,
  getErrorOr ,
  map ,
  mapError ,
  flatMap ,
  chain ,
  apply ,
  fromOption ,
  toOption ,
  recover ,
  fromPromise ,
  toPromise ,
  combine2 ,
  combine3 ,
  combineArray ,
  daoErrorToAppError ,
  networkErrorToAppError ,
  validationErrorToAppError ,
  daoErrorToString ,
  networkErrorToString ,
  validationErrorToString ,
  appErrorToString ,
}
/* No side effect */
