/**
 * Enhanced Init Command - Claude Code Quality
 *
 * Generates comprehensive AX.md with:
 * - Multi-paragraph descriptions
 * - Categorized real commands
 * - File structure documentation
 * - Architecture flow diagrams
 * - No placeholders
 *
 * @since v8.5.0
 */

import type { CommandModule } from 'yargs';
import { writeFile, readFile, access, rename } from 'node:fs/promises';
import { constants } from 'node:fs';
import { join } from 'path';
import chalk from 'chalk';
import { logger } from '../../shared/logging/logger.js';
import { printError } from '../../shared/errors/error-formatter.js';
import {
  detectProjectInfo,
  type ProjectInfo,
  type CategorizedScripts,
  type FileStructure
} from './project-detector.js';
import {
  parseAXMD,
  detectDetailedChanges,
  formatChangeSummary
} from './init-parser.js';

interface InitOptions {
  force?: boolean;
}

/**
 * Generate enhanced AX.md content (Claude Code quality)
 */
function generateAXMD(info: ProjectInfo): string {
  const today = new Date().toISOString().split('T')[0];

  return `# Project Context for ${info.name}

> Last updated: ${today}
> Project: ${info.name}${info.version ? ` (v${info.version})` : ''}

## Project Overview

${generateProjectOverview(info)}

## Architecture

${generateArchitecture(info)}

## File Structure

${generateFileStructure(info)}

${generateGettingStarted(info)}

${generateTroubleshooting(info)}

${generateDevWorkflow(info)}

${generateDatabaseSchema(info)}

${generateAPIDocumentation(info)}

${generateAgentRules(info)}

${generateCodingConventions(info)}

${generateCriticalGuardrails(info)}

${generateCommands(info)}

${generateUsefulLinks(info)}

---

**Generated by \`ax init\` â€¢ Run regularly to keep up-to-date**
`;
}

/**
 * Generate comprehensive project overview
 */
function generateProjectOverview(info: ProjectInfo): string {
  const sections: string[] = [];

  // Multi-paragraph description from README
  if (info.detailedDescription) {
    sections.push(info.detailedDescription);
  } else if (info.description) {
    sections.push(`**${info.description}**`);
  } else {
    sections.push(`**${info.framework || 'Node.js'} project${info.hasTypeScript ? ' with TypeScript' : ''}**`);
  }

  // Key info
  const keyInfo: string[] = [];
  keyInfo.push(`**Version:** ${info.version || 'Not specified'}`);
  keyInfo.push(`**Language:** ${info.language}`);
  if (info.framework) keyInfo.push(`**Framework:** ${info.framework}`);
  if (info.buildTool) keyInfo.push(`**Build Tool:** ${info.buildTool}`);
  if (info.testFramework) keyInfo.push(`**Test Framework:** ${info.testFramework}`);
  if (info.isMonorepo) keyInfo.push(`**Type:** Monorepo`);

  sections.push('\n' + keyInfo.join('  \n'));

  // Stack
  sections.push(`\n**Stack:** ${info.stack}`);

  // Team size (only if detected)
  if (info.teamSize) {
    sections.push(`\n**Team:** ${info.teamSize}`);
  }

  return sections.join('\n');
}

/**
 * Generate architecture section
 */
function generateArchitecture(info: ProjectInfo): string {
  const sections: string[] = [];

  // Architecture type
  sections.push(`**Type:** ${detectArchitectureType(info)}`);

  // Flow diagram
  if (info.architectureFlow) {
    sections.push('\n**Flow:**\n```');
    sections.push(info.architectureFlow.trim());
    sections.push('```');
  }

  // Key components
  if (info.keyComponents && info.keyComponents.length > 0) {
    sections.push('\n**Key Components:**');
    for (const comp of info.keyComponents) {
      if (comp.purpose) {
        sections.push(`- \`${comp.path}\` - ${comp.purpose}`);
      } else {
        sections.push(`- \`${comp.path}\``);
      }
    }
  }

  return sections.join('\n');
}

/**
 * Detect architecture type
 */
function detectArchitectureType(info: ProjectInfo): string {
  if (info.dependencies.includes('next') || info.dependencies.includes('nuxt')) {
    return 'Full-stack framework (SSR/SSG)';
  }
  if (info.dependencies.includes('express') || info.dependencies.includes('fastify')) {
    if (info.framework === 'React' || info.framework === 'Vue') {
      return 'Client-server architecture';
    }
    return 'REST API server';
  }
  if (info.dependencies.includes('apollo-server') || info.dependencies.includes('graphql')) {
    return 'GraphQL API server';
  }
  if (info.framework === 'React' || info.framework === 'Vue') {
    return 'Single Page Application (SPA)';
  }
  if (info.dependencies.some(d => d.includes('commander') || d.includes('yargs'))) {
    return 'Command-line interface (CLI)';
  }
  return 'Node.js application';
}

/**
 * Generate file structure documentation
 */
function generateFileStructure(info: ProjectInfo): string {
  if (!info.fileStructure || info.fileStructure.directories.length === 0) {
    return '';  // Omit if no structure detected
  }

  const sections: string[] = [];

  // Entry point
  if (info.fileStructure.entryPoint) {
    sections.push(`**Entry Point:** \`${info.fileStructure.entryPoint}\``);
  }

  // Directory structure
  sections.push('\n**Directories:**');
  for (const dir of info.fileStructure.directories) {
    if (dir.purpose) {
      sections.push(`- \`${dir.path}/\` - ${dir.purpose} (${dir.fileCount} files)`);
    } else {
      sections.push(`- \`${dir.path}/\` - ${dir.fileCount} files`);
    }
  }

  // Total
  sections.push(`\n**Total Files:** ${info.fileStructure.totalFiles}`);

  return sections.join('\n');
}

/**
 * Generate Getting Started section
 */
function generateGettingStarted(info: ProjectInfo): string {
  if (!info.gettingStarted) {
    return '';  // Skip if no getting started info
  }

  const sections: string[] = ['## Getting Started', ''];

  // Prerequisites
  if (info.gettingStarted.prerequisites.length > 0) {
    sections.push('### Prerequisites');
    for (const prereq of info.gettingStarted.prerequisites) {
      sections.push(`- ${prereq}`);
    }
    sections.push('');
  }

  // First Time Setup
  if (info.gettingStarted.setupSteps.length > 0) {
    sections.push('### First Time Setup');
    for (const step of info.gettingStarted.setupSteps) {
      sections.push(step);
    }
    sections.push('');
  }

  // Environment Variables
  if (info.gettingStarted.envVars.length > 0) {
    sections.push('### Environment Variables');
    sections.push('');

    const required = info.gettingStarted.envVars.filter(v => v.required);
    const optional = info.gettingStarted.envVars.filter(v => !v.required);

    if (required.length > 0) {
      sections.push('**Required:**');
      for (const envVar of required) {
        sections.push(`- \`${envVar.name}\`${envVar.description ? ` - ${envVar.description}` : ''}`);
        if (envVar.example) {
          sections.push(`  - Example: \`${envVar.example}\``);
        }
      }
      sections.push('');
    }

    if (optional.length > 0) {
      sections.push('**Optional:**');
      for (const envVar of optional) {
        sections.push(`- \`${envVar.name}\`${envVar.description ? ` - ${envVar.description}` : ''}`);
        if (envVar.example) {
          sections.push(`  - Example: \`${envVar.example}\``);
        }
      }
      sections.push('');
    }
  }

  return sections.join('\n');
}

/**
 * Generate Troubleshooting section
 */
function generateTroubleshooting(info: ProjectInfo): string {
  const sections: string[] = ['## Troubleshooting', ''];

  sections.push('### Common Issues');
  sections.push('');

  // Generic issues
  sections.push('**Problem**: `npm install` fails with EACCES');
  sections.push('**Solution**: Fix npm permissions: `sudo chown -R $USER ~/.npm`');
  sections.push('');

  // Database issues
  if (info.dependencies.includes('prisma') || info.dependencies.includes('typeorm') ||
      info.dependencies.includes('pg') || info.dependencies.includes('mongodb')) {
    sections.push('**Problem**: Database connection refused');
    sections.push('**Solution**:');
    sections.push('1. Check Docker is running: `docker ps`');
    sections.push('2. Start services: `docker-compose up -d`');
    if (info.scripts['db:ping']) {
      sections.push(`3. Verify connection: \`${info.packageManager} run db:ping\``);
    }
    sections.push('');
  }

  // Port conflicts
  sections.push('**Problem**: Port already in use');
  sections.push('**Solution**: Kill process: `lsof -ti:3000 | xargs kill`');
  sections.push('');

  // TypeScript issues
  if (info.hasTypeScript) {
    sections.push('**Problem**: TypeScript errors after `git pull`');
    sections.push('**Solution**: Clean install: `rm -rf node_modules && npm install`');
    sections.push('');
  }

  // Framework-specific
  if (info.framework === 'React' || info.framework === 'Next.js' || info.framework === 'Vue') {
    sections.push('**Problem**: Hot reload not working');
    sections.push('**Solution**: Check file watcher limits: `echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf`');
    sections.push('');
  }

  // Debug mode
  sections.push('### Debug Mode');
  sections.push('Run with verbose logging:');
  sections.push('```bash');
  sections.push('DEBUG=* npm run dev');
  if (info.scripts.test) {
    sections.push('LOG_LEVEL=debug npm test');
  }
  sections.push('```');

  return sections.join('\n');
}

/**
 * Generate Development Workflow section
 */
function generateDevWorkflow(info: ProjectInfo): string {
  const sections: string[] = ['## Development Workflow', ''];

  // Daily workflow
  sections.push('### Daily Workflow');
  sections.push('1. Pull latest: `git pull origin main`');
  sections.push('2. Create feature branch: `git checkout -b feature/my-feature`');
  sections.push('3. Make changes');
  if (info.scripts.test) {
    sections.push(`4. Run tests: \`${info.packageManager} test\``);
  }
  sections.push('5. Commit: `git commit -m "feat: add my feature"`');
  sections.push('6. Push: `git push origin feature/my-feature`');
  sections.push('7. Open PR on GitHub');
  sections.push('8. Wait for CI + reviews');
  sections.push('9. Merge to main (squash merge)');
  sections.push('');

  // Code review
  sections.push('### Code Review Process');
  sections.push('- Minimum 1 approval required');
  sections.push('- CI must pass (tests + lint)');
  sections.push('- No merge conflicts');
  sections.push('');

  // Hot reload
  sections.push('### Hot Reload');
  if (info.framework === 'React' || info.framework === 'Vue') {
    if (info.buildTool === 'Vite') {
      sections.push('- Frontend: Vite HMR (instant)');
    } else {
      sections.push('- Frontend: Hot module replacement enabled');
    }
  }
  if (info.dependencies.includes('express') || info.dependencies.includes('fastify')) {
    sections.push('- Backend: Nodemon (restart on save)');
  }
  if (info.framework === 'Next.js') {
    sections.push('- Next.js Fast Refresh (instant updates)');
  }
  sections.push('');

  // Testing strategy
  if (info.testFramework) {
    sections.push('### Testing Strategy');
    if (info.scripts['test:unit']) {
      sections.push(`- Unit tests: \`${info.packageManager} run test:unit\` (fast, no DB)`);
    }
    if (info.scripts['test:integration']) {
      sections.push(`- Integration tests: \`${info.packageManager} run test:integration\` (with test DB)`);
    }
    if (info.scripts['test:e2e']) {
      sections.push(`- E2E tests: \`${info.packageManager} run test:e2e\` (full stack)`);
    }
    if (info.scripts.test) {
      sections.push(`- Run all: \`${info.packageManager} test\``);
    }
  }

  return sections.join('\n');
}

/**
 * Generate Database Schema section
 */
function generateDatabaseSchema(info: ProjectInfo): string {
  if (!info.databaseSchema || info.databaseSchema.models.length === 0) {
    return '';  // Skip if no database schema
  }

  const sections: string[] = ['## Database Schema', ''];
  const schema = info.databaseSchema;

  // ORM info
  if (schema.orm) {
    sections.push(`**ORM:** ${schema.orm}`);
    sections.push('');
  }

  // Models
  if (schema.models.length > 0) {
    sections.push('### Models');
    sections.push('');

    for (const model of schema.models.slice(0, 10)) {  // Show first 10 models
      sections.push(`**${model.name}**`);

      // Fields
      if (model.fields.length > 0) {
        for (const field of model.fields) {
          let fieldDesc = `- \`${field.name}\`: ${field.type}`;
          const attrs: string[] = [];

          if (field.isPrimaryKey) attrs.push('PK');
          if (field.isUnique) attrs.push('unique');
          if (field.isOptional) attrs.push('optional');
          if (field.defaultValue) attrs.push(`default: ${field.defaultValue}`);

          if (attrs.length > 0) {
            fieldDesc += ` (${attrs.join(', ')})`;
          }

          sections.push(fieldDesc);
        }
      }

      // Relations
      if (model.relations.length > 0) {
        for (const rel of model.relations) {
          sections.push(`- \`${rel.name}\`: ${rel.type} â†’ ${rel.relatedModel}`);
        }
      }

      sections.push('');
    }

    if (schema.models.length > 10) {
      sections.push(`*... and ${schema.models.length - 10} more models*`);
      sections.push('');
    }
  }

  // Migrations
  if (schema.migrations.directory && schema.migrations.files.length > 0) {
    sections.push('### Migrations');
    sections.push(`- Location: \`${schema.migrations.directory}\``);
    sections.push(`- Total: ${schema.migrations.files.length} migrations`);

    if (info.scripts['db:migrate'] || info.scripts['migrate'] || info.scripts['prisma:migrate']) {
      const migrateCmd = info.scripts['db:migrate'] ? 'db:migrate' :
                        info.scripts['migrate'] ? 'migrate' :
                        'prisma:migrate';
      sections.push(`- Run: \`${info.packageManager} run ${migrateCmd}\``);
    }

    sections.push('');
  }

  return sections.join('\n');
}

/**
 * Generate API Documentation section
 */
function generateAPIDocumentation(info: ProjectInfo): string {
  if (!info.apiDocumentation) {
    return '';  // Skip if no API documentation
  }

  const sections: string[] = ['## API Documentation', ''];
  const api = info.apiDocumentation;

  // Framework
  if (api.framework) {
    sections.push(`**Framework:** ${api.framework}`);
    sections.push('');
  }

  // OpenAPI spec
  if (api.hasOpenAPI && api.openAPIPath) {
    sections.push(`**OpenAPI Spec:** \`${api.openAPIPath}\``);
    sections.push('');
  }

  // Endpoints
  if (api.endpoints.length > 0) {
    sections.push('### Endpoints');
    sections.push('');

    // Group by resource
    const grouped = new Map<string, typeof api.endpoints>();
    for (const endpoint of api.endpoints) {
      const group = endpoint.group || 'other';
      if (!grouped.has(group)) {
        grouped.set(group, []);
      }
      grouped.get(group)?.push(endpoint);
    }

    // Display grouped endpoints
    for (const [group, endpoints] of grouped) {
      if (group !== 'other') {
        sections.push(`**${group.charAt(0).toUpperCase() + group.slice(1)}**`);
      }

      for (const endpoint of endpoints.slice(0, 20)) {  // Limit to 20 per group
        let line = `- \`${endpoint.method} ${endpoint.path}\``;
        if (endpoint.description) {
          line += ` - ${endpoint.description}`;
        }
        if (endpoint.auth) {
          line += ' ðŸ”’';
        }
        sections.push(line);
      }

      sections.push('');
    }

    if (api.endpoints.length > 20) {
      sections.push(`*... and ${api.endpoints.length - 20} more endpoints*`);
      sections.push('');
    }
  }

  return sections.join('\n');
}

/**
 * Generate agent delegation rules
 */
function generateAgentRules(info: ProjectInfo): string {
  const rules: string[] = ['## Agent Delegation Rules', ''];

  // Development section
  rules.push('### Development');

  if (info.framework === 'React' || info.framework === 'Vue' || info.framework === 'Next.js') {
    rules.push(`- **Frontend/UI (${info.framework})** â†’ @frontend (Frank)`);
  }

  if (info.dependencies.includes('express') || info.dependencies.includes('fastify') || info.dependencies.includes('koa')) {
    rules.push('- **Backend/API** â†’ @backend (Bob) or @fullstack (Felix)');
  }

  if (info.hasTypeScript) {
    rules.push('- **TypeScript issues** â†’ @fullstack (Felix)');
  }

  if (info.dependencies.some(d => d.includes('react-native') || d.includes('expo'))) {
    rules.push('- **Mobile** â†’ @mobile (Maya)');
  }

  rules.push('- **Infrastructure/DevOps** â†’ @devops (Oliver)');
  rules.push('');

  // Quality section
  rules.push('### Quality & Architecture');
  rules.push('- **Tests/QA** â†’ @quality (Queenie)');
  rules.push('- **Security audits** â†’ @security (Steve) - mandatory for: auth, payments, PII');
  rules.push('- **Architecture/ADR** â†’ @architecture (Avery)');
  rules.push('');

  // Documentation section
  rules.push('### Documentation & Product');
  rules.push('- **Technical writing** â†’ @writer (Wendy)');
  rules.push('- **Product management** â†’ @product (Paris)');

  return rules.join('\n');
}

/**
 * Generate coding conventions
 */
function generateCodingConventions(info: ProjectInfo): string {
  const conventions: string[] = ['## Coding Conventions', ''];

  // Testing
  conventions.push('### Testing');
  if (info.testFramework) {
    conventions.push(`- **Framework:** ${info.testFramework}`);
    conventions.push('- **Coverage:** 80% minimum');
    conventions.push(`- **Run:** \`${info.packageManager} test\``);
  } else {
    conventions.push('- Run tests before pushing');
  }
  conventions.push('');

  // Code style
  conventions.push('### Code Style');
  if (info.linter) {
    conventions.push(`- **Linter:** ${info.linter}`);
  }
  if (info.formatter) {
    conventions.push(`- **Formatter:** ${info.formatter}`);
  }
  if (info.hasTypeScript) {
    conventions.push('- **TypeScript:** Strict mode enabled');
  }
  conventions.push('- **Indent:** 2 spaces');
  conventions.push('- **Max line:** 100 chars');
  conventions.push('');

  // Git workflow
  conventions.push('### Git Workflow');
  conventions.push('- **Branch naming:** `feature/description` or `fix/description`');
  conventions.push('- **Commits:** Conventional commits format (feat/fix/chore/docs)');
  conventions.push('- **PRs:** Review required before merge');

  return conventions.join('\n');
}

/**
 * Generate critical guardrails
 */
function generateCriticalGuardrails(info: ProjectInfo): string {
  const guardrails: string[] = ['## Critical Guardrails', ''];

  // Never
  guardrails.push('âš ï¸ **NEVER:**');
  guardrails.push('- Commit to main/production branches directly');
  guardrails.push('- Skip tests before pushing');
  guardrails.push('- Expose API keys or credentials in code');

  // Database-specific
  if (info.dependencies.includes('prisma') || info.dependencies.includes('typeorm')) {
    guardrails.push('- Modify database migrations without approval');
  }

  guardrails.push('');

  // Always
  guardrails.push('âœ… **ALWAYS:**');
  guardrails.push(`- Run \`${info.packageManager} test\` before pushing`);

  if (info.linter) {
    guardrails.push(`- Run \`${info.packageManager} run lint\` to check code style`);
  }

  if (info.formatter) {
    guardrails.push(`- Format code with ${info.formatter} before committing`);
  }

  guardrails.push('- Document breaking changes');
  guardrails.push('- Add tests for new features');

  return guardrails.join('\n');
}

/**
 * Generate commands section with REAL commands (no placeholders!)
 */
function generateCommands(info: ProjectInfo): string {
  const sections: string[] = ['## Canonical Commands', ''];

  if (!info.categorizedScripts) {
    return sections.join('\n') + '```bash\n# No scripts detected\n```';
  }

  const categories = [
    { key: 'development', title: 'Development' },
    { key: 'building', title: 'Building' },
    { key: 'testing', title: 'Testing' },
    { key: 'quality', title: 'Quality Checks' },
    { key: 'deployment', title: 'Deployment' }
  ] as const;

  sections.push('```bash');

  for (const { key, title } of categories) {
    const scripts = info.categorizedScripts[key];
    if (scripts && scripts.length > 0) {
      sections.push(`# ${title}`);
      for (const script of scripts) {
        const cmd = `${info.packageManager} run ${script.name}`;
        const padding = ' '.repeat(Math.max(35 - cmd.length, 1));
        sections.push(`${cmd}${padding}# ${script.description}`);
      }
      sections.push('');
    }
  }

  // Other scripts
  const other = info.categorizedScripts.other;
  if (other && other.length > 0) {
    sections.push('# Other');
    for (const script of other) {
      const cmd = `${info.packageManager} run ${script.name}`;
      const padding = ' '.repeat(Math.max(35 - cmd.length, 1));
      sections.push(`${cmd}${padding}# ${script.description}`);
    }
  }

  sections.push('```');

  return sections.join('\n');
}

/**
 * Generate useful links
 */
function generateUsefulLinks(info: ProjectInfo): string {
  const links: string[] = ['## Useful Links', ''];

  if (info.repository) {
    links.push(`- [Repository](${info.repository})`);
  }

  if (info.fileStructure?.docsDirectory) {
    links.push(`- [Documentation](${info.fileStructure.docsDirectory}/)`);
  }

  return links.join('\n');
}

/**
 * Atomic write (temp file + rename for safety)
 */
async function atomicWrite(filePath: string, content: string): Promise<void> {
  const tempPath = `${filePath}.tmp`;
  await writeFile(tempPath, content, 'utf-8');
  await rename(tempPath, filePath);
}

export const initCommand: CommandModule<Record<string, unknown>, InitOptions> = {
  command: 'init',
  describe: 'Initialize AX.md project context file',

  builder: (yargs) => {
    return yargs
      .option('force', {
        alias: 'f',
        describe: 'Regenerate AX.md from scratch',
        type: 'boolean',
        default: false
      })
      .example([
        ['$0 init', 'Create or update AX.md with current project info'],
        ['$0 init --force', 'Regenerate AX.md from scratch']
      ]);
  },

  handler: async (argv) => {
    const projectDir = process.cwd();
    const axMdPath = join(projectDir, 'AX.md');

    try {
      // Detect current project info (enhanced)
      const projectInfo = await detectProjectInfo(projectDir);

      // Check if AX.md already exists
      const axMdExists = await access(axMdPath, constants.F_OK).then(() => true).catch(() => false);

      if (axMdExists && !argv.force) {
        // Claude Code behavior: UPDATE existing file intelligently
        const existingContent = await readFile(axMdPath, 'utf-8');
        const parsed = parseAXMD(existingContent);

        // Detect changes
        const changes = detectDetailedChanges(parsed, {
          version: projectInfo.version,
          dependencies: projectInfo.dependencies,
          scripts: projectInfo.scripts,
          framework: projectInfo.framework,
          architecture: detectArchitectureType(projectInfo),
          linter: projectInfo.linter,
          formatter: projectInfo.formatter,
          testFramework: projectInfo.testFramework
        });

        if (changes.length === 0) {
          // No changes detected
          console.log(chalk.green('âœ“ AX.md is up to date'));
          logger.info('AX.md unchanged', { projectName: projectInfo.name });
          return;
        }

        // Changes detected - update file
        // Generate new content
        const axMdContent = generateAXMD(projectInfo);

        // Atomic write
        await atomicWrite(axMdPath, axMdContent);

        // Format change summary
        const summary = formatChangeSummary(changes);

        // Claude Code style output
        console.log(chalk.green(`âœ“ Updated AX.md ${summary}`));

        logger.info('AX.md updated', {
          projectName: projectInfo.name,
          changes: changes.length,
          changeTypes: changes.map(c => c.type)
        });

      } else {
        // First time or --force: Create new AX.md
        const axMdContent = generateAXMD(projectInfo);

        // Atomic write
        await atomicWrite(axMdPath, axMdContent);

        // Claude Code style output
        const projectType = projectInfo.framework || projectInfo.language;
        console.log(chalk.green(`âœ“ Created AX.md (${projectType} project)`));

        logger.info('AX.md created', {
          projectName: projectInfo.name,
          framework: projectInfo.framework,
          language: projectInfo.language,
          forced: argv.force
        });
      }

    } catch (error) {
      // Simple error message (Claude Code style)
      console.log(chalk.red('âœ— Error with AX.md'));
      logger.error('AX.md initialization failed', { error });

      if (process.env.DEBUG || process.env.AUTOMATOSX_DEBUG) {
        printError(error);
      }

      process.exit(1);
    }
  }
};
